// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/graph/v2/sources.proto (package chalk.graph.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Value } from "@bufbuild/protobuf";

/**
 * Pointer to an underlying database source -- used by native sql resolvers to identify which DB they are for
 *
 * @generated from message chalk.graph.v2.DatabaseSourceReference
 */
export class DatabaseSourceReference extends Message<DatabaseSourceReference> {
  /**
   * The type of the database source -- e.g. postgres, bigquery
   *
   * @generated from field: string source_type = 1;
   */
  sourceType = "";

  /**
   * The (customer provided) name for the database source. The default source for the given type is represented by the empty string
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<DatabaseSourceReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.graph.v2.DatabaseSourceReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSourceReference {
    return new DatabaseSourceReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSourceReference {
    return new DatabaseSourceReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSourceReference {
    return new DatabaseSourceReference().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSourceReference | PlainMessage<DatabaseSourceReference> | undefined, b: DatabaseSourceReference | PlainMessage<DatabaseSourceReference> | undefined): boolean {
    return proto3.util.equals(DatabaseSourceReference, a, b);
  }
}

/**
 * @generated from message chalk.graph.v2.DatabaseSource
 */
export class DatabaseSource extends Message<DatabaseSource> {
  /**
   * The type of the database source -- e.g. postgres, bigquery
   *
   * @generated from field: string source_type = 1;
   */
  sourceType = "";

  /**
   * The (customer provided) name for the database source. The default source for the given type is represented by the empty string
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Additional source-specific options. DO NOT STORE CREDENTIALS IN HERE.
   *
   * @generated from field: map<string, google.protobuf.Value> options = 3;
   */
  options: { [key: string]: Value } = {};

  constructor(data?: PartialMessage<DatabaseSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.graph.v2.DatabaseSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "options", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSource {
    return new DatabaseSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSource {
    return new DatabaseSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSource {
    return new DatabaseSource().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSource | PlainMessage<DatabaseSource> | undefined, b: DatabaseSource | PlainMessage<DatabaseSource> | undefined): boolean {
    return proto3.util.equals(DatabaseSource, a, b);
  }
}

/**
 * @generated from message chalk.graph.v2.DatabaseSourceGroup
 */
export class DatabaseSourceGroup extends Message<DatabaseSourceGroup> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: chalk.graph.v2.DatabaseSourceReference default_source = 2;
   */
  defaultSource?: DatabaseSourceReference;

  /**
   * @generated from field: map<string, chalk.graph.v2.DatabaseSourceReference> tagged_sources = 3;
   */
  taggedSources: { [key: string]: DatabaseSourceReference } = {};

  constructor(data?: PartialMessage<DatabaseSourceGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.graph.v2.DatabaseSourceGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "default_source", kind: "message", T: DatabaseSourceReference },
    { no: 3, name: "tagged_sources", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: DatabaseSourceReference} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSourceGroup {
    return new DatabaseSourceGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSourceGroup {
    return new DatabaseSourceGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSourceGroup {
    return new DatabaseSourceGroup().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSourceGroup | PlainMessage<DatabaseSourceGroup> | undefined, b: DatabaseSourceGroup | PlainMessage<DatabaseSourceGroup> | undefined): boolean {
    return proto3.util.equals(DatabaseSourceGroup, a, b);
  }
}

/**
 * Pointer to an underlying stream source -- used by stream resolvers
 *
 * @generated from message chalk.graph.v2.StreamSourceReference
 */
export class StreamSourceReference extends Message<StreamSourceReference> {
  /**
   * The type of the stream source -- e.g. kafka, pubsub, sqs
   *
   * @generated from field: string source_type = 1;
   */
  sourceType = "";

  /**
   * The (customer provided) name for the stream source. The default source for the given type is represented by the empty string
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<StreamSourceReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.graph.v2.StreamSourceReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSourceReference {
    return new StreamSourceReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSourceReference {
    return new StreamSourceReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSourceReference {
    return new StreamSourceReference().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSourceReference | PlainMessage<StreamSourceReference> | undefined, b: StreamSourceReference | PlainMessage<StreamSourceReference> | undefined): boolean {
    return proto3.util.equals(StreamSourceReference, a, b);
  }
}

/**
 * @generated from message chalk.graph.v2.StreamSource
 */
export class StreamSource extends Message<StreamSource> {
  /**
   * The type of the stream source -- e.g. kafka, pubsub, sqs
   *
   * @generated from field: string source_type = 1;
   */
  sourceType = "";

  /**
   * The (customer provided) name for the stream source. The default source for the given type is represented by the empty string
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Additional source-specific options. DO NOT STORE CREDENTIALS IN HERE.
   *
   * @generated from field: map<string, google.protobuf.Value> options = 3;
   */
  options: { [key: string]: Value } = {};

  constructor(data?: PartialMessage<StreamSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.graph.v2.StreamSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "options", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSource {
    return new StreamSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSource {
    return new StreamSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSource {
    return new StreamSource().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSource | PlainMessage<StreamSource> | undefined, b: StreamSource | PlainMessage<StreamSource> | undefined): boolean {
    return proto3.util.equals(StreamSource, a, b);
  }
}

/**
 * @generated from message chalk.graph.v2.SourceSecrets
 */
export class SourceSecrets extends Message<SourceSecrets> {
  /**
   * Secrets for sql and stream sources, in the style of integration variables
   *
   * @generated from field: map<string, string> secrets = 1;
   */
  secrets: { [key: string]: string } = {};

  constructor(data?: PartialMessage<SourceSecrets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.graph.v2.SourceSecrets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "secrets", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceSecrets {
    return new SourceSecrets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceSecrets {
    return new SourceSecrets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceSecrets {
    return new SourceSecrets().fromJsonString(jsonString, options);
  }

  static equals(a: SourceSecrets | PlainMessage<SourceSecrets> | undefined, b: SourceSecrets | PlainMessage<SourceSecrets> | undefined): boolean {
    return proto3.util.equals(SourceSecrets, a, b);
  }
}

