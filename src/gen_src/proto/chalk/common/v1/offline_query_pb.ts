// Needed by ChalkSQL, very likely to change in near future

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/common/v1/offline_query.proto (package chalk.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { ListValue, Message, proto3, Value } from "@bufbuild/protobuf";
import { LogicalExprNode } from "../../expression/v1/expression_pb";
import { ExplainOptions } from "./online_query_pb";
import { ChalkError } from "./chalk_error_pb";

/**
 * @generated from message chalk.common.v1.OfflineQueryRecomputeFeatures
 */
export class OfflineQueryRecomputeFeatures extends Message<OfflineQueryRecomputeFeatures> {
  /**
   * @generated from oneof chalk.common.v1.OfflineQueryRecomputeFeatures.impl
   */
  impl: {
    /**
     * @generated from field: bool all_or_none = 1;
     */
    value: boolean;
    case: "allOrNone";
  } | {
    /**
     * @generated from field: chalk.common.v1.OfflineQueryRecomputeFeatures.FeatureList feature_list = 2;
     */
    value: OfflineQueryRecomputeFeatures_FeatureList;
    case: "featureList";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OfflineQueryRecomputeFeatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryRecomputeFeatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "all_or_none", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "impl" },
    { no: 2, name: "feature_list", kind: "message", T: OfflineQueryRecomputeFeatures_FeatureList, oneof: "impl" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryRecomputeFeatures {
    return new OfflineQueryRecomputeFeatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryRecomputeFeatures {
    return new OfflineQueryRecomputeFeatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryRecomputeFeatures {
    return new OfflineQueryRecomputeFeatures().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryRecomputeFeatures | PlainMessage<OfflineQueryRecomputeFeatures> | undefined, b: OfflineQueryRecomputeFeatures | PlainMessage<OfflineQueryRecomputeFeatures> | undefined): boolean {
    return proto3.util.equals(OfflineQueryRecomputeFeatures, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.OfflineQueryRecomputeFeatures.FeatureList
 */
export class OfflineQueryRecomputeFeatures_FeatureList extends Message<OfflineQueryRecomputeFeatures_FeatureList> {
  /**
   * @generated from field: repeated string feature_list = 1;
   */
  featureList: string[] = [];

  constructor(data?: PartialMessage<OfflineQueryRecomputeFeatures_FeatureList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryRecomputeFeatures.FeatureList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feature_list", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryRecomputeFeatures_FeatureList {
    return new OfflineQueryRecomputeFeatures_FeatureList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryRecomputeFeatures_FeatureList {
    return new OfflineQueryRecomputeFeatures_FeatureList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryRecomputeFeatures_FeatureList {
    return new OfflineQueryRecomputeFeatures_FeatureList().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryRecomputeFeatures_FeatureList | PlainMessage<OfflineQueryRecomputeFeatures_FeatureList> | undefined, b: OfflineQueryRecomputeFeatures_FeatureList | PlainMessage<OfflineQueryRecomputeFeatures_FeatureList> | undefined): boolean {
    return proto3.util.equals(OfflineQueryRecomputeFeatures_FeatureList, a, b);
  }
}

/**
 * OfflineQueryExplain is DEPRECATED. DO NOT USE IT!!
 *
 * @generated from message chalk.common.v1.OfflineQueryExplain
 */
export class OfflineQueryExplain extends Message<OfflineQueryExplain> {
  /**
   * @generated from oneof chalk.common.v1.OfflineQueryExplain.impl
   */
  impl: {
    /**
     * @generated from field: bool truthy = 1;
     */
    value: boolean;
    case: "truthy";
  } | {
    /**
     * @generated from field: chalk.common.v1.OfflineQueryExplain.Only only = 2;
     */
    value: OfflineQueryExplain_Only;
    case: "only";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OfflineQueryExplain>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryExplain";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truthy", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "impl" },
    { no: 2, name: "only", kind: "message", T: OfflineQueryExplain_Only, oneof: "impl" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryExplain {
    return new OfflineQueryExplain().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryExplain {
    return new OfflineQueryExplain().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryExplain {
    return new OfflineQueryExplain().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryExplain | PlainMessage<OfflineQueryExplain> | undefined, b: OfflineQueryExplain | PlainMessage<OfflineQueryExplain> | undefined): boolean {
    return proto3.util.equals(OfflineQueryExplain, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.OfflineQueryExplain.Only
 */
export class OfflineQueryExplain_Only extends Message<OfflineQueryExplain_Only> {
  constructor(data?: PartialMessage<OfflineQueryExplain_Only>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryExplain.Only";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryExplain_Only {
    return new OfflineQueryExplain_Only().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryExplain_Only {
    return new OfflineQueryExplain_Only().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryExplain_Only {
    return new OfflineQueryExplain_Only().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryExplain_Only | PlainMessage<OfflineQueryExplain_Only> | undefined, b: OfflineQueryExplain_Only | PlainMessage<OfflineQueryExplain_Only> | undefined): boolean {
    return proto3.util.equals(OfflineQueryExplain_Only, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.OfflineQueryInput
 */
export class OfflineQueryInput extends Message<OfflineQueryInput> {
  /**
   * @generated from field: repeated string columns = 1;
   */
  columns: string[] = [];

  /**
   * Note that this is a list of lists. Each list is the input for a single column
   *
   * @generated from field: repeated google.protobuf.ListValue values = 2;
   */
  values: ListValue[] = [];

  constructor(data?: PartialMessage<OfflineQueryInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "values", kind: "message", T: ListValue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryInput {
    return new OfflineQueryInput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryInput {
    return new OfflineQueryInput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryInput {
    return new OfflineQueryInput().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryInput | PlainMessage<OfflineQueryInput> | undefined, b: OfflineQueryInput | PlainMessage<OfflineQueryInput> | undefined): boolean {
    return proto3.util.equals(OfflineQueryInput, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.OfflineQueryInputSharded
 */
export class OfflineQueryInputSharded extends Message<OfflineQueryInputSharded> {
  /**
   * @generated from field: repeated chalk.common.v1.OfflineQueryInput inputs = 1;
   */
  inputs: OfflineQueryInput[] = [];

  constructor(data?: PartialMessage<OfflineQueryInputSharded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryInputSharded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputs", kind: "message", T: OfflineQueryInput, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryInputSharded {
    return new OfflineQueryInputSharded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryInputSharded {
    return new OfflineQueryInputSharded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryInputSharded {
    return new OfflineQueryInputSharded().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryInputSharded | PlainMessage<OfflineQueryInputSharded> | undefined, b: OfflineQueryInputSharded | PlainMessage<OfflineQueryInputSharded> | undefined): boolean {
    return proto3.util.equals(OfflineQueryInputSharded, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.OfflineQueryInputs
 */
export class OfflineQueryInputs extends Message<OfflineQueryInputs> {
  /**
   * @generated from oneof chalk.common.v1.OfflineQueryInputs.impl
   */
  impl: {
    /**
     * *
     * Should be a feather-compressed table, complete with schema
     *
     * @generated from field: bytes feather_inputs = 1;
     */
    value: Uint8Array;
    case: "featherInputs";
  } | {
    /**
     * @generated from field: chalk.common.v1.OfflineQueryInputs.NoInputs no_inputs = 2;
     */
    value: OfflineQueryInputs_NoInputs;
    case: "noInputs";
  } | {
    /**
     * @generated from field: chalk.common.v1.OfflineQueryInput single_inputs = 3;
     */
    value: OfflineQueryInput;
    case: "singleInputs";
  } | {
    /**
     * @generated from field: chalk.common.v1.OfflineQueryInputSharded sharded_inputs = 4;
     */
    value: OfflineQueryInputSharded;
    case: "shardedInputs";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OfflineQueryInputs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryInputs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feather_inputs", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "impl" },
    { no: 2, name: "no_inputs", kind: "message", T: OfflineQueryInputs_NoInputs, oneof: "impl" },
    { no: 3, name: "single_inputs", kind: "message", T: OfflineQueryInput, oneof: "impl" },
    { no: 4, name: "sharded_inputs", kind: "message", T: OfflineQueryInputSharded, oneof: "impl" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryInputs {
    return new OfflineQueryInputs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryInputs {
    return new OfflineQueryInputs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryInputs {
    return new OfflineQueryInputs().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryInputs | PlainMessage<OfflineQueryInputs> | undefined, b: OfflineQueryInputs | PlainMessage<OfflineQueryInputs> | undefined): boolean {
    return proto3.util.equals(OfflineQueryInputs, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.OfflineQueryInputs.NoInputs
 */
export class OfflineQueryInputs_NoInputs extends Message<OfflineQueryInputs_NoInputs> {
  constructor(data?: PartialMessage<OfflineQueryInputs_NoInputs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryInputs.NoInputs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryInputs_NoInputs {
    return new OfflineQueryInputs_NoInputs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryInputs_NoInputs {
    return new OfflineQueryInputs_NoInputs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryInputs_NoInputs {
    return new OfflineQueryInputs_NoInputs().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryInputs_NoInputs | PlainMessage<OfflineQueryInputs_NoInputs> | undefined, b: OfflineQueryInputs_NoInputs | PlainMessage<OfflineQueryInputs_NoInputs> | undefined): boolean {
    return proto3.util.equals(OfflineQueryInputs_NoInputs, a, b);
  }
}

/**
 * *
 * A gRPC representation of the JSON body expected by the offline query endpoint in the http engine.
 * Note that this is being used by chalkSQL
 *
 * Light mirror of go-api-server/shared/rpc_models_query.go#CreateOfflineQueryJobRequest
 *
 * @generated from message chalk.common.v1.OfflineQueryRequest
 */
export class OfflineQueryRequest extends Message<OfflineQueryRequest> {
  /**
   * @generated from field: chalk.common.v1.OfflineQueryInputs inputs = 1;
   */
  inputs?: OfflineQueryInputs;

  /**
   * A list of output feature root fqns to query
   *
   * @generated from field: repeated string outputs = 2;
   */
  outputs: string[] = [];

  /**
   * A list of required output feature root fqns
   *
   * @generated from field: repeated string required_outputs = 3;
   */
  requiredOutputs: string[] = [];

  /**
   * The desired output format. Should be 'CSV' or 'PARQUET
   *
   * @generated from field: string destination_format = 4;
   */
  destinationFormat = "";

  /**
   * @generated from field: optional string branch = 5;
   */
  branch?: string;

  /**
   * @generated from field: optional string dataset_name = 6;
   */
  datasetName?: string;

  /**
   * @generated from field: chalk.common.v1.OfflineQueryRecomputeFeatures recompute_features = 7;
   */
  recomputeFeatures?: OfflineQueryRecomputeFeatures;

  /**
   * @generated from field: bool store_plan_stages = 8;
   */
  storePlanStages = false;

  /**
   * "Where" clause
   *
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode filters = 11;
   */
  filters: LogicalExprNode[] = [];

  /**
   * This is an alternative way to specify inputs - a SQL query that retrieves outputs
   *
   * @generated from field: optional string spine_sql_query = 12;
   */
  spineSqlQuery?: string;

  /**
   * The maximum number of samples. If None, no limit
   *
   * @generated from field: optional int32 max_samples = 101;
   */
  maxSamples?: number;

  /**
   *
   * The maximum staleness, in seconds, for how old the view on the offline store can be. That is,
   * data ingested within this interval will not be reflected in this offline query.
   * Set to ``0`` to ignore the cache. If not specified, it defaults to OFFLINE_QUERY_MAX_CACHE_AGE_SECS
   * in chalk engine config.
   *
   * @generated from field: optional int32 max_cache_age_secs = 102;
   */
  maxCacheAgeSecs?: number;

  /**
   * Field is deprecated because we shouldn't have OnlineExplain that differs from OfflineExplain
   * Use explain2
   *
   * @generated from field: chalk.common.v1.OfflineQueryExplain explain = 103 [deprecated = true];
   * @deprecated
   */
  explain?: OfflineQueryExplain;

  /**
   * @generated from field: chalk.common.v1.ExplainOptions explain2 = 106;
   */
  explain2?: ExplainOptions;

  /**
   * @generated from field: repeated string tags = 104;
   */
  tags: string[] = [];

  /**
   * @generated from field: optional string correlation_id = 105;
   */
  correlationId?: string;

  /**
   * @generated from field: repeated string required_resolver_tags = 107;
   */
  requiredResolverTags: string[] = [];

  /**
   * The lower bound for the observed at timestamp (inclusive). If not specified, defaults to the beginning of time
   *
   * @generated from field: optional string observed_at_lower_bound = 201;
   */
  observedAtLowerBound?: string;

  /**
   * The upper bound for the observed at timestamp (inclusive). If not specified, defaults to the end of time
   *
   * @generated from field: optional string observed_at_upper_bound = 202;
   */
  observedAtUpperBound?: string;

  /**
   * Planner options to pass to the engine, overriding any default/set by environment variable
   *
   * @generated from field: map<string, google.protobuf.Value> planner_options = 203;
   */
  plannerOptions: { [key: string]: Value } = {};

  /**
   * Whether computed results should be persisted in the online/offline store
   *
   * @generated from field: optional bool store_online = 204;
   */
  storeOnline?: boolean;

  /**
   * @generated from field: optional bool store_offline = 205;
   */
  storeOffline?: boolean;

  /**
   * Whether or not to run this offline query asynchronously.
   *
   * @generated from field: optional bool use_multiple_computers = 206;
   */
  useMultipleComputers?: boolean;

  /**
   * @generated from field: optional int32 num_shards = 207;
   */
  numShards?: number;

  /**
   * @generated from field: optional int32 num_workers = 208;
   */
  numWorkers?: number;

  /**
   * Additional context passed in to resolvers
   *
   * @generated from field: map<string, google.protobuf.Value> query_context = 209;
   */
  queryContext: { [key: string]: Value } = {};

  constructor(data?: PartialMessage<OfflineQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.OfflineQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputs", kind: "message", T: OfflineQueryInputs },
    { no: 2, name: "outputs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "required_outputs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "destination_format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "dataset_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "recompute_features", kind: "message", T: OfflineQueryRecomputeFeatures },
    { no: 8, name: "store_plan_stages", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "filters", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 12, name: "spine_sql_query", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 101, name: "max_samples", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 102, name: "max_cache_age_secs", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 103, name: "explain", kind: "message", T: OfflineQueryExplain },
    { no: 106, name: "explain2", kind: "message", T: ExplainOptions },
    { no: 104, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 105, name: "correlation_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 107, name: "required_resolver_tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 201, name: "observed_at_lower_bound", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 202, name: "observed_at_upper_bound", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 203, name: "planner_options", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
    { no: 204, name: "store_online", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 205, name: "store_offline", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 206, name: "use_multiple_computers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 207, name: "num_shards", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 208, name: "num_workers", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 209, name: "query_context", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineQueryRequest {
    return new OfflineQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineQueryRequest {
    return new OfflineQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineQueryRequest {
    return new OfflineQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OfflineQueryRequest | PlainMessage<OfflineQueryRequest> | undefined, b: OfflineQueryRequest | PlainMessage<OfflineQueryRequest> | undefined): boolean {
    return proto3.util.equals(OfflineQueryRequest, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.ColumnMetadataList
 */
export class ColumnMetadataList extends Message<ColumnMetadataList> {
  /**
   * @generated from field: repeated chalk.common.v1.ColumnMetadataList.ColumnMetadata metadata = 1;
   */
  metadata: ColumnMetadataList_ColumnMetadata[] = [];

  constructor(data?: PartialMessage<ColumnMetadataList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.ColumnMetadataList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: ColumnMetadataList_ColumnMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnMetadataList {
    return new ColumnMetadataList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnMetadataList {
    return new ColumnMetadataList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnMetadataList {
    return new ColumnMetadataList().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnMetadataList | PlainMessage<ColumnMetadataList> | undefined, b: ColumnMetadataList | PlainMessage<ColumnMetadataList> | undefined): boolean {
    return proto3.util.equals(ColumnMetadataList, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.ColumnMetadataList.ColumnMetadata
 */
export class ColumnMetadataList_ColumnMetadata extends Message<ColumnMetadataList_ColumnMetadata> {
  /**
   * The root FQN of the feature for a column
   *
   * @generated from field: string feature_fqn = 1;
   */
  featureFqn = "";

  /**
   * The name of the column that corresponds to this feature
   *
   * @generated from field: string column_name = 2;
   */
  columnName = "";

  /**
   * The data type for this feature
   *
   * @generated from field: string dtype = 3;
   */
  dtype = "";

  constructor(data?: PartialMessage<ColumnMetadataList_ColumnMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.ColumnMetadataList.ColumnMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feature_fqn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dtype", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnMetadataList_ColumnMetadata {
    return new ColumnMetadataList_ColumnMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnMetadataList_ColumnMetadata {
    return new ColumnMetadataList_ColumnMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnMetadataList_ColumnMetadata {
    return new ColumnMetadataList_ColumnMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnMetadataList_ColumnMetadata | PlainMessage<ColumnMetadataList_ColumnMetadata> | undefined, b: ColumnMetadataList_ColumnMetadata | PlainMessage<ColumnMetadataList_ColumnMetadata> | undefined): boolean {
    return proto3.util.equals(ColumnMetadataList_ColumnMetadata, a, b);
  }
}

/**
 * This represents the response returned by engine chalksql/get_offline_job_proto_v4
 * For the message that v4/offline_query returns, check out common/v1/dataset_response.proto
 *
 * @generated from message chalk.common.v1.GetOfflineQueryJobResponse
 */
export class GetOfflineQueryJobResponse extends Message<GetOfflineQueryJobResponse> {
  /**
   * @generated from field: bool is_finished = 1;
   */
  isFinished = false;

  /**
   * @generated from field: int32 version = 2;
   */
  version = 0;

  /**
   * @generated from field: repeated string urls = 3;
   */
  urls: string[] = [];

  /**
   * @generated from field: repeated chalk.common.v1.ChalkError errors = 4;
   */
  errors: ChalkError[] = [];

  /**
   * @generated from field: optional chalk.common.v1.ColumnMetadataList columns = 5;
   */
  columns?: ColumnMetadataList;

  constructor(data?: PartialMessage<GetOfflineQueryJobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.GetOfflineQueryJobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_finished", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "urls", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "errors", kind: "message", T: ChalkError, repeated: true },
    { no: 5, name: "columns", kind: "message", T: ColumnMetadataList, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOfflineQueryJobResponse {
    return new GetOfflineQueryJobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOfflineQueryJobResponse {
    return new GetOfflineQueryJobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOfflineQueryJobResponse {
    return new GetOfflineQueryJobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetOfflineQueryJobResponse | PlainMessage<GetOfflineQueryJobResponse> | undefined, b: GetOfflineQueryJobResponse | PlainMessage<GetOfflineQueryJobResponse> | undefined): boolean {
    return proto3.util.equals(GetOfflineQueryJobResponse, a, b);
  }
}

