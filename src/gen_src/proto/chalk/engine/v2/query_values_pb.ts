// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/engine/v2/query_values.proto (package chalk.engine.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { QueryLogFilters } from "../../common/v1/query_log_pb";

/**
 * @generated from message chalk.engine.v2.OperationIdTableIdentifier
 */
export class OperationIdTableIdentifier extends Message<OperationIdTableIdentifier> {
  /**
   * If you want the results for a particular operation id, no need to look up the value tables separately.
   * The engine will do that for you
   *
   * @generated from field: string operation_id = 1;
   */
  operationId = "";

  constructor(data?: PartialMessage<OperationIdTableIdentifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v2.OperationIdTableIdentifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperationIdTableIdentifier {
    return new OperationIdTableIdentifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperationIdTableIdentifier {
    return new OperationIdTableIdentifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperationIdTableIdentifier {
    return new OperationIdTableIdentifier().fromJsonString(jsonString, options);
  }

  static equals(a: OperationIdTableIdentifier | PlainMessage<OperationIdTableIdentifier> | undefined, b: OperationIdTableIdentifier | PlainMessage<OperationIdTableIdentifier> | undefined): boolean {
    return proto3.util.equals(OperationIdTableIdentifier, a, b);
  }
}

/**
 * @generated from message chalk.engine.v2.TableNameTableIdentifier
 */
export class TableNameTableIdentifier extends Message<TableNameTableIdentifier> {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * Optionally, you can filter. Specifying any filters will result in a join against the query log table.
   *
   * @generated from field: chalk.common.v1.QueryLogFilters filters = 2;
   */
  filters?: QueryLogFilters;

  constructor(data?: PartialMessage<TableNameTableIdentifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v2.TableNameTableIdentifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "filters", kind: "message", T: QueryLogFilters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableNameTableIdentifier {
    return new TableNameTableIdentifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableNameTableIdentifier {
    return new TableNameTableIdentifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableNameTableIdentifier {
    return new TableNameTableIdentifier().fromJsonString(jsonString, options);
  }

  static equals(a: TableNameTableIdentifier | PlainMessage<TableNameTableIdentifier> | undefined, b: TableNameTableIdentifier | PlainMessage<TableNameTableIdentifier> | undefined): boolean {
    return proto3.util.equals(TableNameTableIdentifier, a, b);
  }
}

/**
 * Internal protobuf representing a next page token. Contains the operation id and the query timestamp for the last row in the previous batch. Results are sorted query timestamp
 * then by operation id lexicographically then by row id, so this is all we need to know where the next page begins
 *
 * @generated from message chalk.engine.v2.GetQueryValuesPageToken
 */
export class GetQueryValuesPageToken extends Message<GetQueryValuesPageToken> {
  /**
   * @generated from field: google.protobuf.Timestamp query_timestamp_hwm = 1;
   */
  queryTimestampHwm?: Timestamp;

  /**
   * @generated from field: string operation_id_hwm = 2;
   */
  operationIdHwm = "";

  /**
   * @generated from field: int64 row_id_hwm = 3;
   */
  rowIdHwm = protoInt64.zero;

  constructor(data?: PartialMessage<GetQueryValuesPageToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v2.GetQueryValuesPageToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_timestamp_hwm", kind: "message", T: Timestamp },
    { no: 2, name: "operation_id_hwm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "row_id_hwm", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryValuesPageToken {
    return new GetQueryValuesPageToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryValuesPageToken {
    return new GetQueryValuesPageToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryValuesPageToken {
    return new GetQueryValuesPageToken().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryValuesPageToken | PlainMessage<GetQueryValuesPageToken> | undefined, b: GetQueryValuesPageToken | PlainMessage<GetQueryValuesPageToken> | undefined): boolean {
    return proto3.util.equals(GetQueryValuesPageToken, a, b);
  }
}

/**
 * @generated from message chalk.engine.v2.GetQueryValuesRequest
 */
export class GetQueryValuesRequest extends Message<GetQueryValuesRequest> {
  /**
   * @generated from oneof chalk.engine.v2.GetQueryValuesRequest.table_identifier
   */
  tableIdentifier: {
    /**
     * Forcing the client to specify the table name can be a bit gnarly. Instead, for use case 1), it can be easier to allow the client to specify the operation id,
     * and the engine can figure out what table to query.
     *
     * @generated from field: chalk.engine.v2.OperationIdTableIdentifier operation_id_identifier = 1;
     */
    value: OperationIdTableIdentifier;
    case: "operationIdIdentifier";
  } | {
    /**
     * For use case 2, you have to specify which table name to look up, if you want to query across multiple queries
     *
     * @generated from field: chalk.engine.v2.TableNameTableIdentifier table_name_identifier = 2;
     */
    value: TableNameTableIdentifier;
    case: "tableNameIdentifier";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * This is always required.
   * If you know the operation id, then its feasible that you know the exact query timestamp, too.
   *
   * @generated from field: google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 3;
   */
  queryTimestampLowerBoundInclusive?: Timestamp;

  /**
   * If the upper bound is omitted, then the lower bound will be used as an exact (equality) filter
   *
   * @generated from field: optional google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 4;
   */
  queryTimestampUpperBoundExclusive?: Timestamp;

  /**
   * If you're interested in a subset of features, specify those here. Other columns won't be selected from the database, which will help reduce query costs.
   * If empty, all features will be returned
   *
   * @generated from field: repeated string features = 5;
   */
  features: string[] = [];

  /**
   * The (maximum) page size for results. If zero, then the server picks.
   *
   * @generated from field: int32 page_size = 7;
   */
  pageSize = 0;

  /**
   * When dealing with paginated responses, specify the next token to resume where you left off. The subsequent request must be identical to the original (except for the value of the next_token)
   * Leave empty if querying for the zeroth page.
   *
   * @generated from field: string page_token = 8;
   */
  pageToken = "";

  constructor(data?: PartialMessage<GetQueryValuesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v2.GetQueryValuesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id_identifier", kind: "message", T: OperationIdTableIdentifier, oneof: "table_identifier" },
    { no: 2, name: "table_name_identifier", kind: "message", T: TableNameTableIdentifier, oneof: "table_identifier" },
    { no: 3, name: "query_timestamp_lower_bound_inclusive", kind: "message", T: Timestamp },
    { no: 4, name: "query_timestamp_upper_bound_exclusive", kind: "message", T: Timestamp, opt: true },
    { no: 5, name: "features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryValuesRequest {
    return new GetQueryValuesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryValuesRequest {
    return new GetQueryValuesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryValuesRequest {
    return new GetQueryValuesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryValuesRequest | PlainMessage<GetQueryValuesRequest> | undefined, b: GetQueryValuesRequest | PlainMessage<GetQueryValuesRequest> | undefined): boolean {
    return proto3.util.equals(GetQueryValuesRequest, a, b);
  }
}

/**
 * @generated from message chalk.engine.v2.GetQueryValuesResponse
 */
export class GetQueryValuesResponse extends Message<GetQueryValuesResponse> {
  /**
   * If non-empty, call this endpoint again, with this next token to get the next page of responses.
   *
   * @generated from field: string next_page_token = 1;
   */
  nextPageToken = "";

  /**
   * The response payload. Defining as a one-of to future-proof it should we decide to support multiple encodings (parquet, feather, ...)
   *
   * @generated from oneof chalk.engine.v2.GetQueryValuesResponse.payload
   */
  payload: {
    /**
     * @generated from field: bytes parquet = 2;
     */
    value: Uint8Array;
    case: "parquet";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetQueryValuesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v2.GetQueryValuesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "parquet", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryValuesResponse {
    return new GetQueryValuesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryValuesResponse {
    return new GetQueryValuesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryValuesResponse {
    return new GetQueryValuesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryValuesResponse | PlainMessage<GetQueryValuesResponse> | undefined, b: GetQueryValuesResponse | PlainMessage<GetQueryValuesResponse> | undefined): boolean {
    return proto3.util.equals(GetQueryValuesResponse, a, b);
  }
}

