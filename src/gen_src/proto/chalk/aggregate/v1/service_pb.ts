// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/aggregate/v1/service.proto (package chalk.aggregate.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { AggregateBackfillCostEstimate, AggregateBackfillJob, AggregateBackfillUserParams, AggregateBackfillWithCostEstimate, CronAggregateBackfill } from "./backfill_pb";
import { AggregateTimeSeries } from "./timeseries_pb";

/**
 * @generated from message chalk.aggregate.v1.PlanAggregateBackfillRequest
 */
export class PlanAggregateBackfillRequest extends Message<PlanAggregateBackfillRequest> {
  /**
   * @generated from field: chalk.aggregate.v1.AggregateBackfillUserParams params = 1;
   */
  params?: AggregateBackfillUserParams;

  constructor(data?: PartialMessage<PlanAggregateBackfillRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.PlanAggregateBackfillRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: AggregateBackfillUserParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlanAggregateBackfillRequest {
    return new PlanAggregateBackfillRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlanAggregateBackfillRequest {
    return new PlanAggregateBackfillRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlanAggregateBackfillRequest {
    return new PlanAggregateBackfillRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PlanAggregateBackfillRequest | PlainMessage<PlanAggregateBackfillRequest> | undefined, b: PlanAggregateBackfillRequest | PlainMessage<PlanAggregateBackfillRequest> | undefined): boolean {
    return proto3.util.equals(PlanAggregateBackfillRequest, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.PlanAggregateBackfillResponse
 */
export class PlanAggregateBackfillResponse extends Message<PlanAggregateBackfillResponse> {
  /**
   * @generated from field: chalk.aggregate.v1.AggregateBackfillCostEstimate estimate = 2;
   */
  estimate?: AggregateBackfillCostEstimate;

  /**
   * @generated from field: repeated string errors = 4;
   */
  errors: string[] = [];

  /**
   * @generated from field: repeated chalk.aggregate.v1.AggregateBackfillWithCostEstimate backfills = 6;
   */
  backfills: AggregateBackfillWithCostEstimate[] = [];

  /**
   * @generated from field: string aggregate_backfill_id = 7;
   */
  aggregateBackfillId = "";

  constructor(data?: PartialMessage<PlanAggregateBackfillResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.PlanAggregateBackfillResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "estimate", kind: "message", T: AggregateBackfillCostEstimate },
    { no: 4, name: "errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "backfills", kind: "message", T: AggregateBackfillWithCostEstimate, repeated: true },
    { no: 7, name: "aggregate_backfill_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlanAggregateBackfillResponse {
    return new PlanAggregateBackfillResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlanAggregateBackfillResponse {
    return new PlanAggregateBackfillResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlanAggregateBackfillResponse {
    return new PlanAggregateBackfillResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PlanAggregateBackfillResponse | PlainMessage<PlanAggregateBackfillResponse> | undefined, b: PlanAggregateBackfillResponse | PlainMessage<PlanAggregateBackfillResponse> | undefined): boolean {
    return proto3.util.equals(PlanAggregateBackfillResponse, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetAggregatesRequest
 */
export class GetAggregatesRequest extends Message<GetAggregatesRequest> {
  /**
   * @generated from field: repeated string for_features = 1;
   */
  forFeatures: string[] = [];

  constructor(data?: PartialMessage<GetAggregatesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetAggregatesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "for_features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregatesRequest {
    return new GetAggregatesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregatesRequest {
    return new GetAggregatesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregatesRequest {
    return new GetAggregatesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAggregatesRequest | PlainMessage<GetAggregatesRequest> | undefined, b: GetAggregatesRequest | PlainMessage<GetAggregatesRequest> | undefined): boolean {
    return proto3.util.equals(GetAggregatesRequest, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetAggregatesResponse
 */
export class GetAggregatesResponse extends Message<GetAggregatesResponse> {
  /**
   * @generated from field: repeated chalk.aggregate.v1.AggregateTimeSeries series = 1;
   */
  series: AggregateTimeSeries[] = [];

  /**
   * @generated from field: repeated string errors = 2;
   */
  errors: string[] = [];

  constructor(data?: PartialMessage<GetAggregatesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetAggregatesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "series", kind: "message", T: AggregateTimeSeries, repeated: true },
    { no: 2, name: "errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregatesResponse {
    return new GetAggregatesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregatesResponse {
    return new GetAggregatesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregatesResponse {
    return new GetAggregatesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAggregatesResponse | PlainMessage<GetAggregatesResponse> | undefined, b: GetAggregatesResponse | PlainMessage<GetAggregatesResponse> | undefined): boolean {
    return proto3.util.equals(GetAggregatesResponse, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetAggregateBackfillJobsRequest
 */
export class GetAggregateBackfillJobsRequest extends Message<GetAggregateBackfillJobsRequest> {
  /**
   * @generated from field: int32 limit = 1;
   */
  limit = 0;

  /**
   * @generated from field: string cursor = 2;
   */
  cursor = "";

  /**
   * @generated from field: optional string plan_hash = 3;
   */
  planHash?: string;

  constructor(data?: PartialMessage<GetAggregateBackfillJobsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetAggregateBackfillJobsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "plan_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregateBackfillJobsRequest {
    return new GetAggregateBackfillJobsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobsRequest {
    return new GetAggregateBackfillJobsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobsRequest {
    return new GetAggregateBackfillJobsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAggregateBackfillJobsRequest | PlainMessage<GetAggregateBackfillJobsRequest> | undefined, b: GetAggregateBackfillJobsRequest | PlainMessage<GetAggregateBackfillJobsRequest> | undefined): boolean {
    return proto3.util.equals(GetAggregateBackfillJobsRequest, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetAggregateBackfillJobsResponse
 */
export class GetAggregateBackfillJobsResponse extends Message<GetAggregateBackfillJobsResponse> {
  /**
   * @generated from field: repeated chalk.aggregate.v1.AggregateBackfillJob jobs = 1;
   */
  jobs: AggregateBackfillJob[] = [];

  /**
   * @generated from field: string cursor = 2;
   */
  cursor = "";

  constructor(data?: PartialMessage<GetAggregateBackfillJobsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetAggregateBackfillJobsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jobs", kind: "message", T: AggregateBackfillJob, repeated: true },
    { no: 2, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregateBackfillJobsResponse {
    return new GetAggregateBackfillJobsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobsResponse {
    return new GetAggregateBackfillJobsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobsResponse {
    return new GetAggregateBackfillJobsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAggregateBackfillJobsResponse | PlainMessage<GetAggregateBackfillJobsResponse> | undefined, b: GetAggregateBackfillJobsResponse | PlainMessage<GetAggregateBackfillJobsResponse> | undefined): boolean {
    return proto3.util.equals(GetAggregateBackfillJobsResponse, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetAggregateBackfillJobRequest
 */
export class GetAggregateBackfillJobRequest extends Message<GetAggregateBackfillJobRequest> {
  /**
   * @generated from field: string aggregate_backfill_id = 1;
   */
  aggregateBackfillId = "";

  constructor(data?: PartialMessage<GetAggregateBackfillJobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetAggregateBackfillJobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_backfill_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregateBackfillJobRequest {
    return new GetAggregateBackfillJobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobRequest {
    return new GetAggregateBackfillJobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobRequest {
    return new GetAggregateBackfillJobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAggregateBackfillJobRequest | PlainMessage<GetAggregateBackfillJobRequest> | undefined, b: GetAggregateBackfillJobRequest | PlainMessage<GetAggregateBackfillJobRequest> | undefined): boolean {
    return proto3.util.equals(GetAggregateBackfillJobRequest, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetAggregateBackfillJobResponse
 */
export class GetAggregateBackfillJobResponse extends Message<GetAggregateBackfillJobResponse> {
  /**
   * @generated from field: chalk.aggregate.v1.AggregateBackfillJob job = 1;
   */
  job?: AggregateBackfillJob;

  constructor(data?: PartialMessage<GetAggregateBackfillJobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetAggregateBackfillJobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: AggregateBackfillJob },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregateBackfillJobResponse {
    return new GetAggregateBackfillJobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobResponse {
    return new GetAggregateBackfillJobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregateBackfillJobResponse {
    return new GetAggregateBackfillJobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAggregateBackfillJobResponse | PlainMessage<GetAggregateBackfillJobResponse> | undefined, b: GetAggregateBackfillJobResponse | PlainMessage<GetAggregateBackfillJobResponse> | undefined): boolean {
    return proto3.util.equals(GetAggregateBackfillJobResponse, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetCronAggregateBackfillRequest
 */
export class GetCronAggregateBackfillRequest extends Message<GetCronAggregateBackfillRequest> {
  /**
   * @generated from field: string cron_aggregate_backfill_id = 1 [deprecated = true];
   * @deprecated
   */
  cronAggregateBackfillId = "";

  /**
   * @generated from field: string plan_hash = 2;
   */
  planHash = "";

  constructor(data?: PartialMessage<GetCronAggregateBackfillRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetCronAggregateBackfillRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cron_aggregate_backfill_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "plan_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCronAggregateBackfillRequest {
    return new GetCronAggregateBackfillRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCronAggregateBackfillRequest {
    return new GetCronAggregateBackfillRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCronAggregateBackfillRequest {
    return new GetCronAggregateBackfillRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCronAggregateBackfillRequest | PlainMessage<GetCronAggregateBackfillRequest> | undefined, b: GetCronAggregateBackfillRequest | PlainMessage<GetCronAggregateBackfillRequest> | undefined): boolean {
    return proto3.util.equals(GetCronAggregateBackfillRequest, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetCronAggregateBackfillResponse
 */
export class GetCronAggregateBackfillResponse extends Message<GetCronAggregateBackfillResponse> {
  /**
   * @generated from field: chalk.aggregate.v1.CronAggregateBackfill cron_aggregate_backfill = 1;
   */
  cronAggregateBackfill?: CronAggregateBackfill;

  constructor(data?: PartialMessage<GetCronAggregateBackfillResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetCronAggregateBackfillResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cron_aggregate_backfill", kind: "message", T: CronAggregateBackfill },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCronAggregateBackfillResponse {
    return new GetCronAggregateBackfillResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCronAggregateBackfillResponse {
    return new GetCronAggregateBackfillResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCronAggregateBackfillResponse {
    return new GetCronAggregateBackfillResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCronAggregateBackfillResponse | PlainMessage<GetCronAggregateBackfillResponse> | undefined, b: GetCronAggregateBackfillResponse | PlainMessage<GetCronAggregateBackfillResponse> | undefined): boolean {
    return proto3.util.equals(GetCronAggregateBackfillResponse, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetActiveCronAggregateBackfillsRequest
 */
export class GetActiveCronAggregateBackfillsRequest extends Message<GetActiveCronAggregateBackfillsRequest> {
  constructor(data?: PartialMessage<GetActiveCronAggregateBackfillsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetActiveCronAggregateBackfillsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActiveCronAggregateBackfillsRequest {
    return new GetActiveCronAggregateBackfillsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActiveCronAggregateBackfillsRequest {
    return new GetActiveCronAggregateBackfillsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActiveCronAggregateBackfillsRequest {
    return new GetActiveCronAggregateBackfillsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetActiveCronAggregateBackfillsRequest | PlainMessage<GetActiveCronAggregateBackfillsRequest> | undefined, b: GetActiveCronAggregateBackfillsRequest | PlainMessage<GetActiveCronAggregateBackfillsRequest> | undefined): boolean {
    return proto3.util.equals(GetActiveCronAggregateBackfillsRequest, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.CronAggregateBackfillWithLatestRun
 */
export class CronAggregateBackfillWithLatestRun extends Message<CronAggregateBackfillWithLatestRun> {
  /**
   * @generated from field: chalk.aggregate.v1.CronAggregateBackfill cron_aggregate_backfill = 1;
   */
  cronAggregateBackfill?: CronAggregateBackfill;

  /**
   * @generated from field: chalk.aggregate.v1.AggregateBackfillJob latest_job = 2;
   */
  latestJob?: AggregateBackfillJob;

  constructor(data?: PartialMessage<CronAggregateBackfillWithLatestRun>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.CronAggregateBackfillWithLatestRun";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cron_aggregate_backfill", kind: "message", T: CronAggregateBackfill },
    { no: 2, name: "latest_job", kind: "message", T: AggregateBackfillJob },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CronAggregateBackfillWithLatestRun {
    return new CronAggregateBackfillWithLatestRun().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CronAggregateBackfillWithLatestRun {
    return new CronAggregateBackfillWithLatestRun().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CronAggregateBackfillWithLatestRun {
    return new CronAggregateBackfillWithLatestRun().fromJsonString(jsonString, options);
  }

  static equals(a: CronAggregateBackfillWithLatestRun | PlainMessage<CronAggregateBackfillWithLatestRun> | undefined, b: CronAggregateBackfillWithLatestRun | PlainMessage<CronAggregateBackfillWithLatestRun> | undefined): boolean {
    return proto3.util.equals(CronAggregateBackfillWithLatestRun, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.GetActiveCronAggregateBackfillsResponse
 */
export class GetActiveCronAggregateBackfillsResponse extends Message<GetActiveCronAggregateBackfillsResponse> {
  /**
   * @generated from field: repeated chalk.aggregate.v1.CronAggregateBackfillWithLatestRun cron_aggregate_backfills = 1;
   */
  cronAggregateBackfills: CronAggregateBackfillWithLatestRun[] = [];

  constructor(data?: PartialMessage<GetActiveCronAggregateBackfillsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.GetActiveCronAggregateBackfillsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cron_aggregate_backfills", kind: "message", T: CronAggregateBackfillWithLatestRun, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActiveCronAggregateBackfillsResponse {
    return new GetActiveCronAggregateBackfillsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActiveCronAggregateBackfillsResponse {
    return new GetActiveCronAggregateBackfillsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActiveCronAggregateBackfillsResponse {
    return new GetActiveCronAggregateBackfillsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetActiveCronAggregateBackfillsResponse | PlainMessage<GetActiveCronAggregateBackfillsResponse> | undefined, b: GetActiveCronAggregateBackfillsResponse | PlainMessage<GetActiveCronAggregateBackfillsResponse> | undefined): boolean {
    return proto3.util.equals(GetActiveCronAggregateBackfillsResponse, a, b);
  }
}

