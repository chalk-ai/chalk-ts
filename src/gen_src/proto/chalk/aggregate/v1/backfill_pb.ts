// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/aggregate/v1/backfill.proto (package chalk.aggregate.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AggregateTimeSeries } from "./timeseries_pb";

/**
 * @generated from message chalk.aggregate.v1.AggregateBackfillCostEstimate
 */
export class AggregateBackfillCostEstimate extends Message<AggregateBackfillCostEstimate> {
  /**
   * @generated from field: int64 max_buckets = 1;
   */
  maxBuckets = protoInt64.zero;

  /**
   * @generated from field: int64 expected_buckets = 2;
   */
  expectedBuckets = protoInt64.zero;

  /**
   * @generated from field: int64 expected_bytes = 3;
   */
  expectedBytes = protoInt64.zero;

  /**
   * @generated from field: double expected_storage_cost = 4;
   */
  expectedStorageCost = 0;

  /**
   * @generated from field: google.protobuf.Duration expected_runtime = 5;
   */
  expectedRuntime?: Duration;

  constructor(data?: PartialMessage<AggregateBackfillCostEstimate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.AggregateBackfillCostEstimate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_buckets", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "expected_buckets", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "expected_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "expected_storage_cost", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "expected_runtime", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateBackfillCostEstimate {
    return new AggregateBackfillCostEstimate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateBackfillCostEstimate {
    return new AggregateBackfillCostEstimate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateBackfillCostEstimate {
    return new AggregateBackfillCostEstimate().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateBackfillCostEstimate | PlainMessage<AggregateBackfillCostEstimate> | undefined, b: AggregateBackfillCostEstimate | PlainMessage<AggregateBackfillCostEstimate> | undefined): boolean {
    return proto3.util.equals(AggregateBackfillCostEstimate, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.AggregateBackfillUserParams
 */
export class AggregateBackfillUserParams extends Message<AggregateBackfillUserParams> {
  /**
   * @generated from field: repeated string features = 1;
   */
  features: string[] = [];

  /**
   * @generated from field: optional string resolver = 2;
   */
  resolver?: string;

  /**
   * @generated from field: optional string timestamp_column_name = 3 [deprecated = true];
   * @deprecated
   */
  timestampColumnName?: string;

  /**
   * @generated from field: optional google.protobuf.Timestamp lower_bound = 4;
   */
  lowerBound?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp upper_bound = 5;
   */
  upperBound?: Timestamp;

  /**
   * @generated from field: bool exact = 6;
   */
  exact = false;

  constructor(data?: PartialMessage<AggregateBackfillUserParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.AggregateBackfillUserParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "resolver", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "timestamp_column_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "lower_bound", kind: "message", T: Timestamp, opt: true },
    { no: 5, name: "upper_bound", kind: "message", T: Timestamp, opt: true },
    { no: 6, name: "exact", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateBackfillUserParams {
    return new AggregateBackfillUserParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateBackfillUserParams {
    return new AggregateBackfillUserParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateBackfillUserParams {
    return new AggregateBackfillUserParams().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateBackfillUserParams | PlainMessage<AggregateBackfillUserParams> | undefined, b: AggregateBackfillUserParams | PlainMessage<AggregateBackfillUserParams> | undefined): boolean {
    return proto3.util.equals(AggregateBackfillUserParams, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.AggregateBackfill
 */
export class AggregateBackfill extends Message<AggregateBackfill> {
  /**
   * @generated from field: repeated chalk.aggregate.v1.AggregateTimeSeries series = 1;
   */
  series: AggregateTimeSeries[] = [];

  /**
   * @generated from field: string resolver = 2;
   */
  resolver = "";

  /**
   * @generated from field: string datetime_feature = 3;
   */
  datetimeFeature = "";

  /**
   * @generated from field: google.protobuf.Duration bucket_duration = 4;
   */
  bucketDuration?: Duration;

  /**
   * @generated from field: string filters_description = 5;
   */
  filtersDescription = "";

  /**
   * @generated from field: repeated string group_by = 6;
   */
  groupBy: string[] = [];

  /**
   * @generated from field: google.protobuf.Duration max_retention = 7;
   */
  maxRetention?: Duration;

  /**
   * @generated from field: google.protobuf.Timestamp lower_bound = 8;
   */
  lowerBound?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp upper_bound = 9;
   */
  upperBound?: Timestamp;

  constructor(data?: PartialMessage<AggregateBackfill>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.AggregateBackfill";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "series", kind: "message", T: AggregateTimeSeries, repeated: true },
    { no: 2, name: "resolver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "datetime_feature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "bucket_duration", kind: "message", T: Duration },
    { no: 5, name: "filters_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "group_by", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "max_retention", kind: "message", T: Duration },
    { no: 8, name: "lower_bound", kind: "message", T: Timestamp },
    { no: 9, name: "upper_bound", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateBackfill {
    return new AggregateBackfill().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateBackfill {
    return new AggregateBackfill().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateBackfill {
    return new AggregateBackfill().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateBackfill | PlainMessage<AggregateBackfill> | undefined, b: AggregateBackfill | PlainMessage<AggregateBackfill> | undefined): boolean {
    return proto3.util.equals(AggregateBackfill, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.AggregateBackfillWithCostEstimate
 */
export class AggregateBackfillWithCostEstimate extends Message<AggregateBackfillWithCostEstimate> {
  /**
   * @generated from field: chalk.aggregate.v1.AggregateBackfill backfill = 1;
   */
  backfill?: AggregateBackfill;

  /**
   * @generated from field: chalk.aggregate.v1.AggregateBackfillCostEstimate estimate = 2;
   */
  estimate?: AggregateBackfillCostEstimate;

  constructor(data?: PartialMessage<AggregateBackfillWithCostEstimate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.AggregateBackfillWithCostEstimate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backfill", kind: "message", T: AggregateBackfill },
    { no: 2, name: "estimate", kind: "message", T: AggregateBackfillCostEstimate },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateBackfillWithCostEstimate {
    return new AggregateBackfillWithCostEstimate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateBackfillWithCostEstimate {
    return new AggregateBackfillWithCostEstimate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateBackfillWithCostEstimate {
    return new AggregateBackfillWithCostEstimate().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateBackfillWithCostEstimate | PlainMessage<AggregateBackfillWithCostEstimate> | undefined, b: AggregateBackfillWithCostEstimate | PlainMessage<AggregateBackfillWithCostEstimate> | undefined): boolean {
    return proto3.util.equals(AggregateBackfillWithCostEstimate, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.AggregateBackfillJob
 */
export class AggregateBackfillJob extends Message<AggregateBackfillJob> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string environment_id = 2;
   */
  environmentId = "";

  /**
   * @generated from field: optional string resolver = 3;
   */
  resolver?: string;

  /**
   * @generated from field: repeated string features = 4;
   */
  features: string[] = [];

  /**
   * @generated from field: optional string agent_id = 5;
   */
  agentId?: string;

  /**
   * @generated from field: optional string deployment_id = 6;
   */
  deploymentId?: string;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 8;
   */
  updatedAt?: Timestamp;

  /**
   * @generated from field: repeated string resolvers = 9;
   */
  resolvers: string[] = [];

  /**
   * @generated from field: optional string cron_aggregate_backfill_id = 10;
   */
  cronAggregateBackfillId?: string;

  /**
   * @generated from field: optional string plan_hash = 11;
   */
  planHash?: string;

  constructor(data?: PartialMessage<AggregateBackfillJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.AggregateBackfillJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "environment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "resolver", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "agent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "deployment_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 8, name: "updated_at", kind: "message", T: Timestamp },
    { no: 9, name: "resolvers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "cron_aggregate_backfill_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "plan_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateBackfillJob {
    return new AggregateBackfillJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateBackfillJob {
    return new AggregateBackfillJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateBackfillJob {
    return new AggregateBackfillJob().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateBackfillJob | PlainMessage<AggregateBackfillJob> | undefined, b: AggregateBackfillJob | PlainMessage<AggregateBackfillJob> | undefined): boolean {
    return proto3.util.equals(AggregateBackfillJob, a, b);
  }
}

/**
 * @generated from message chalk.aggregate.v1.CronAggregateBackfill
 */
export class CronAggregateBackfill extends Message<CronAggregateBackfill> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string environment_id = 2;
   */
  environmentId = "";

  /**
   * @generated from field: string deployment_id = 3;
   */
  deploymentId = "";

  /**
   * @generated from field: string schedule = 4;
   */
  schedule = "";

  /**
   * @generated from field: string plan_hash = 5;
   */
  planHash = "";

  /**
   * @generated from field: repeated string features = 8;
   */
  features: string[] = [];

  /**
   * @generated from field: repeated string resolvers = 9;
   */
  resolvers: string[] = [];

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 7;
   */
  updatedAt?: Timestamp;

  constructor(data?: PartialMessage<CronAggregateBackfill>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.aggregate.v1.CronAggregateBackfill";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "environment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deployment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "schedule", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "plan_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "resolvers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
    { no: 7, name: "updated_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CronAggregateBackfill {
    return new CronAggregateBackfill().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CronAggregateBackfill {
    return new CronAggregateBackfill().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CronAggregateBackfill {
    return new CronAggregateBackfill().fromJsonString(jsonString, options);
  }

  static equals(a: CronAggregateBackfill | PlainMessage<CronAggregateBackfill> | undefined, b: CronAggregateBackfill | PlainMessage<CronAggregateBackfill> | undefined): boolean {
    return proto3.util.equals(CronAggregateBackfill, a, b);
  }
}

