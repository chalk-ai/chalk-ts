// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/common/v1/feature_values.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration.pb";
import { Timestamp } from "../../../google/protobuf/timestamp.pb";
import { DenseTimeSeriesChart } from "../../chart/v1/densetimeserieschart.pb";
import { Chart } from "./chart.pb";

export const protobufPackage = "chalk.common.v1";

/** @deprecated */
export enum FeatureValueAggregation {
  FEATURE_VALUE_AGGREGATION_UNSPECIFIED = 0,
  FEATURE_VALUE_AGGREGATION_UNIQUE_VALUES = 1,
  FEATURE_VALUE_AGGREGATION_TOTAL_OBSERVATIONS = 2,
  FEATURE_VALUE_AGGREGATION_NULL_PERCENTAGE = 3,
  FEATURE_VALUE_AGGREGATION_MAX_VALUE = 4,
  FEATURE_VALUE_AGGREGATION_MIN_VALUE = 5,
  FEATURE_VALUE_AGGREGATION_AVERAGE = 6,
  FEATURE_VALUE_AGGREGATION_UNIQUE_PKEYS = 7,
  FEATURE_VALUE_AGGREGATION_P95 = 8,
  FEATURE_VALUE_AGGREGATION_P75 = 9,
  FEATURE_VALUE_AGGREGATION_P50 = 10,
  FEATURE_VALUE_AGGREGATION_P25 = 11,
  FEATURE_VALUE_AGGREGATION_P05 = 12,
  UNRECOGNIZED = -1,
}

export function featureValueAggregationFromJSON(object: any): FeatureValueAggregation {
  switch (object) {
    case 0:
    case "FEATURE_VALUE_AGGREGATION_UNSPECIFIED":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_UNSPECIFIED;
    case 1:
    case "FEATURE_VALUE_AGGREGATION_UNIQUE_VALUES":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_UNIQUE_VALUES;
    case 2:
    case "FEATURE_VALUE_AGGREGATION_TOTAL_OBSERVATIONS":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_TOTAL_OBSERVATIONS;
    case 3:
    case "FEATURE_VALUE_AGGREGATION_NULL_PERCENTAGE":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_NULL_PERCENTAGE;
    case 4:
    case "FEATURE_VALUE_AGGREGATION_MAX_VALUE":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_MAX_VALUE;
    case 5:
    case "FEATURE_VALUE_AGGREGATION_MIN_VALUE":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_MIN_VALUE;
    case 6:
    case "FEATURE_VALUE_AGGREGATION_AVERAGE":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_AVERAGE;
    case 7:
    case "FEATURE_VALUE_AGGREGATION_UNIQUE_PKEYS":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_UNIQUE_PKEYS;
    case 8:
    case "FEATURE_VALUE_AGGREGATION_P95":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P95;
    case 9:
    case "FEATURE_VALUE_AGGREGATION_P75":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P75;
    case 10:
    case "FEATURE_VALUE_AGGREGATION_P50":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P50;
    case 11:
    case "FEATURE_VALUE_AGGREGATION_P25":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P25;
    case 12:
    case "FEATURE_VALUE_AGGREGATION_P05":
      return FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P05;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureValueAggregation.UNRECOGNIZED;
  }
}

export function featureValueAggregationToJSON(object: FeatureValueAggregation): string {
  switch (object) {
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_UNSPECIFIED:
      return "FEATURE_VALUE_AGGREGATION_UNSPECIFIED";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_UNIQUE_VALUES:
      return "FEATURE_VALUE_AGGREGATION_UNIQUE_VALUES";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_TOTAL_OBSERVATIONS:
      return "FEATURE_VALUE_AGGREGATION_TOTAL_OBSERVATIONS";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_NULL_PERCENTAGE:
      return "FEATURE_VALUE_AGGREGATION_NULL_PERCENTAGE";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_MAX_VALUE:
      return "FEATURE_VALUE_AGGREGATION_MAX_VALUE";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_MIN_VALUE:
      return "FEATURE_VALUE_AGGREGATION_MIN_VALUE";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_AVERAGE:
      return "FEATURE_VALUE_AGGREGATION_AVERAGE";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_UNIQUE_PKEYS:
      return "FEATURE_VALUE_AGGREGATION_UNIQUE_PKEYS";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P95:
      return "FEATURE_VALUE_AGGREGATION_P95";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P75:
      return "FEATURE_VALUE_AGGREGATION_P75";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P50:
      return "FEATURE_VALUE_AGGREGATION_P50";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P25:
      return "FEATURE_VALUE_AGGREGATION_P25";
    case FeatureValueAggregation.FEATURE_VALUE_AGGREGATION_P05:
      return "FEATURE_VALUE_AGGREGATION_P05";
    case FeatureValueAggregation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** @deprecated */
export interface GetFeatureValuesChartRequest {
  fqn: string;
  aggregateBy: FeatureValueAggregation[];
  /**
   * The size of each time bucket + how far apart time points are in the chart
   * Ideally a divisor of the total window between end and start ms
   * If not, the bucket aligned with end_ms will be of size total_window % window_period
   */
  windowPeriod?: string | undefined;
  startMs: number;
  /** If not provided, will assume current time is the ending time */
  endMs?: number | undefined;
}

/** @deprecated */
export interface GetFeatureValuesChartResponse {
  chart: Chart | undefined;
}

/** @deprecated */
export interface GetFeatureValuesTimeSeriesChartRequest {
  fqn: string;
  aggregateBy: FeatureValueAggregation[];
  /**
   * The size of each time bucket + how far apart time points are in the chart
   * Ideally a divisor of the total window between end and start ms
   * If not, the bucket aligned with end_timestamp_exclusive will be of size total_window % window_period
   * For JSON format, this is a string `${duration_in_seconds}s`
   */
  windowPeriod?: Duration | undefined;
  startTimestampInclusive:
    | Date
    | undefined;
  /** If not provided, will assume current time is the ending time */
  endTimestampExclusive?: Date | undefined;
}

/** @deprecated */
export interface GetFeatureValuesTimeSeriesChartResponse {
}

/** @deprecated */
export interface GetFeatureValuesTimeSeriesChartV2Request {
  fqn: string;
  aggregateBy: FeatureValueAggregation[];
  /**
   * The size of each time bucket + how far apart time points are in the chart
   * Ideally a divisor of the total window between end and start ms
   * If not, the bucket aligned with end_timestamp_exclusive will be of size total_window % window_period
   * For JSON format, this is a string `${duration_in_seconds}s`
   */
  windowPeriod?: Duration | undefined;
  startTimestampInclusive:
    | Date
    | undefined;
  /** If not provided, will assume current time is the ending time */
  endTimestampExclusive?: Date | undefined;
}

/** @deprecated */
export interface GetFeatureValuesTimeSeriesChartV2Response {
  chart: DenseTimeSeriesChart | undefined;
}

function createBaseGetFeatureValuesChartRequest(): GetFeatureValuesChartRequest {
  return { fqn: "", aggregateBy: [], windowPeriod: undefined, startMs: 0, endMs: undefined };
}

export const GetFeatureValuesChartRequest: MessageFns<GetFeatureValuesChartRequest> = {
  encode(message: GetFeatureValuesChartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    writer.uint32(18).fork();
    for (const v of message.aggregateBy) {
      writer.int32(v);
    }
    writer.join();
    if (message.windowPeriod !== undefined) {
      writer.uint32(26).string(message.windowPeriod);
    }
    if (message.startMs !== 0) {
      writer.uint32(32).int64(message.startMs);
    }
    if (message.endMs !== undefined) {
      writer.uint32(40).int64(message.endMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureValuesChartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureValuesChartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.aggregateBy.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aggregateBy.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowPeriod = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startMs = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.endMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureValuesChartRequest {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      aggregateBy: globalThis.Array.isArray(object?.aggregateBy)
        ? object.aggregateBy.map((e: any) => featureValueAggregationFromJSON(e))
        : [],
      windowPeriod: isSet(object.windowPeriod) ? globalThis.String(object.windowPeriod) : undefined,
      startMs: isSet(object.startMs) ? globalThis.Number(object.startMs) : 0,
      endMs: isSet(object.endMs) ? globalThis.Number(object.endMs) : undefined,
    };
  },

  toJSON(message: GetFeatureValuesChartRequest): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.aggregateBy?.length) {
      obj.aggregateBy = message.aggregateBy.map((e) => featureValueAggregationToJSON(e));
    }
    if (message.windowPeriod !== undefined) {
      obj.windowPeriod = message.windowPeriod;
    }
    if (message.startMs !== 0) {
      obj.startMs = Math.round(message.startMs);
    }
    if (message.endMs !== undefined) {
      obj.endMs = Math.round(message.endMs);
    }
    return obj;
  },
};

function createBaseGetFeatureValuesChartResponse(): GetFeatureValuesChartResponse {
  return { chart: undefined };
}

export const GetFeatureValuesChartResponse: MessageFns<GetFeatureValuesChartResponse> = {
  encode(message: GetFeatureValuesChartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chart !== undefined) {
      Chart.encode(message.chart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureValuesChartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureValuesChartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chart = Chart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureValuesChartResponse {
    return { chart: isSet(object.chart) ? Chart.fromJSON(object.chart) : undefined };
  },

  toJSON(message: GetFeatureValuesChartResponse): unknown {
    const obj: any = {};
    if (message.chart !== undefined) {
      obj.chart = Chart.toJSON(message.chart);
    }
    return obj;
  },
};

function createBaseGetFeatureValuesTimeSeriesChartRequest(): GetFeatureValuesTimeSeriesChartRequest {
  return {
    fqn: "",
    aggregateBy: [],
    windowPeriod: undefined,
    startTimestampInclusive: undefined,
    endTimestampExclusive: undefined,
  };
}

export const GetFeatureValuesTimeSeriesChartRequest: MessageFns<GetFeatureValuesTimeSeriesChartRequest> = {
  encode(message: GetFeatureValuesTimeSeriesChartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    writer.uint32(18).fork();
    for (const v of message.aggregateBy) {
      writer.int32(v);
    }
    writer.join();
    if (message.windowPeriod !== undefined) {
      Duration.encode(message.windowPeriod, writer.uint32(26).fork()).join();
    }
    if (message.startTimestampInclusive !== undefined) {
      Timestamp.encode(toTimestamp(message.startTimestampInclusive), writer.uint32(34).fork()).join();
    }
    if (message.endTimestampExclusive !== undefined) {
      Timestamp.encode(toTimestamp(message.endTimestampExclusive), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureValuesTimeSeriesChartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureValuesTimeSeriesChartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.aggregateBy.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aggregateBy.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startTimestampInclusive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endTimestampExclusive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureValuesTimeSeriesChartRequest {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      aggregateBy: globalThis.Array.isArray(object?.aggregateBy)
        ? object.aggregateBy.map((e: any) => featureValueAggregationFromJSON(e))
        : [],
      windowPeriod: isSet(object.windowPeriod) ? Duration.fromJSON(object.windowPeriod) : undefined,
      startTimestampInclusive: isSet(object.startTimestampInclusive)
        ? fromJsonTimestamp(object.startTimestampInclusive)
        : undefined,
      endTimestampExclusive: isSet(object.endTimestampExclusive)
        ? fromJsonTimestamp(object.endTimestampExclusive)
        : undefined,
    };
  },

  toJSON(message: GetFeatureValuesTimeSeriesChartRequest): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.aggregateBy?.length) {
      obj.aggregateBy = message.aggregateBy.map((e) => featureValueAggregationToJSON(e));
    }
    if (message.windowPeriod !== undefined) {
      obj.windowPeriod = Duration.toJSON(message.windowPeriod);
    }
    if (message.startTimestampInclusive !== undefined) {
      obj.startTimestampInclusive = message.startTimestampInclusive.toISOString();
    }
    if (message.endTimestampExclusive !== undefined) {
      obj.endTimestampExclusive = message.endTimestampExclusive.toISOString();
    }
    return obj;
  },
};

function createBaseGetFeatureValuesTimeSeriesChartResponse(): GetFeatureValuesTimeSeriesChartResponse {
  return {};
}

export const GetFeatureValuesTimeSeriesChartResponse: MessageFns<GetFeatureValuesTimeSeriesChartResponse> = {
  encode(_: GetFeatureValuesTimeSeriesChartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureValuesTimeSeriesChartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureValuesTimeSeriesChartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetFeatureValuesTimeSeriesChartResponse {
    return {};
  },

  toJSON(_: GetFeatureValuesTimeSeriesChartResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetFeatureValuesTimeSeriesChartV2Request(): GetFeatureValuesTimeSeriesChartV2Request {
  return {
    fqn: "",
    aggregateBy: [],
    windowPeriod: undefined,
    startTimestampInclusive: undefined,
    endTimestampExclusive: undefined,
  };
}

export const GetFeatureValuesTimeSeriesChartV2Request: MessageFns<GetFeatureValuesTimeSeriesChartV2Request> = {
  encode(message: GetFeatureValuesTimeSeriesChartV2Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    writer.uint32(18).fork();
    for (const v of message.aggregateBy) {
      writer.int32(v);
    }
    writer.join();
    if (message.windowPeriod !== undefined) {
      Duration.encode(message.windowPeriod, writer.uint32(26).fork()).join();
    }
    if (message.startTimestampInclusive !== undefined) {
      Timestamp.encode(toTimestamp(message.startTimestampInclusive), writer.uint32(34).fork()).join();
    }
    if (message.endTimestampExclusive !== undefined) {
      Timestamp.encode(toTimestamp(message.endTimestampExclusive), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureValuesTimeSeriesChartV2Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureValuesTimeSeriesChartV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.aggregateBy.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aggregateBy.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startTimestampInclusive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endTimestampExclusive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureValuesTimeSeriesChartV2Request {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      aggregateBy: globalThis.Array.isArray(object?.aggregateBy)
        ? object.aggregateBy.map((e: any) => featureValueAggregationFromJSON(e))
        : [],
      windowPeriod: isSet(object.windowPeriod) ? Duration.fromJSON(object.windowPeriod) : undefined,
      startTimestampInclusive: isSet(object.startTimestampInclusive)
        ? fromJsonTimestamp(object.startTimestampInclusive)
        : undefined,
      endTimestampExclusive: isSet(object.endTimestampExclusive)
        ? fromJsonTimestamp(object.endTimestampExclusive)
        : undefined,
    };
  },

  toJSON(message: GetFeatureValuesTimeSeriesChartV2Request): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.aggregateBy?.length) {
      obj.aggregateBy = message.aggregateBy.map((e) => featureValueAggregationToJSON(e));
    }
    if (message.windowPeriod !== undefined) {
      obj.windowPeriod = Duration.toJSON(message.windowPeriod);
    }
    if (message.startTimestampInclusive !== undefined) {
      obj.startTimestampInclusive = message.startTimestampInclusive.toISOString();
    }
    if (message.endTimestampExclusive !== undefined) {
      obj.endTimestampExclusive = message.endTimestampExclusive.toISOString();
    }
    return obj;
  },
};

function createBaseGetFeatureValuesTimeSeriesChartV2Response(): GetFeatureValuesTimeSeriesChartV2Response {
  return { chart: undefined };
}

export const GetFeatureValuesTimeSeriesChartV2Response: MessageFns<GetFeatureValuesTimeSeriesChartV2Response> = {
  encode(message: GetFeatureValuesTimeSeriesChartV2Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chart !== undefined) {
      DenseTimeSeriesChart.encode(message.chart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureValuesTimeSeriesChartV2Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureValuesTimeSeriesChartV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chart = DenseTimeSeriesChart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureValuesTimeSeriesChartV2Response {
    return { chart: isSet(object.chart) ? DenseTimeSeriesChart.fromJSON(object.chart) : undefined };
  },

  toJSON(message: GetFeatureValuesTimeSeriesChartV2Response): unknown {
    const obj: any = {};
    if (message.chart !== undefined) {
      obj.chart = DenseTimeSeriesChart.toJSON(message.chart);
    }
    return obj;
  },
};

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
