// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/common/v1/chalk_error.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "chalk.common.v1";

export enum ErrorCode {
  /** ERROR_CODE_INTERNAL_SERVER_ERROR_UNSPECIFIED - An unspecified error occurred. */
  ERROR_CODE_INTERNAL_SERVER_ERROR_UNSPECIFIED = 0,
  /** ERROR_CODE_PARSE_FAILED - The query contained features that do not exist */
  ERROR_CODE_PARSE_FAILED = 1,
  /**
   * ERROR_CODE_RESOLVER_NOT_FOUND - A resolver was required as part of running the dependency
   * graph that could not be found.
   */
  ERROR_CODE_RESOLVER_NOT_FOUND = 2,
  /**
   * ERROR_CODE_INVALID_QUERY - The query is invalid. All supplied features need to be
   * rooted in the same top-level entity.
   */
  ERROR_CODE_INVALID_QUERY = 3,
  /**
   * ERROR_CODE_VALIDATION_FAILED - A feature value did not match the expected schema
   * (e.g. `incompatible type "int"; expected "str"`)
   */
  ERROR_CODE_VALIDATION_FAILED = 4,
  /** ERROR_CODE_RESOLVER_FAILED - The resolver for a feature errored. */
  ERROR_CODE_RESOLVER_FAILED = 5,
  /** ERROR_CODE_RESOLVER_TIMED_OUT - The resolver for a feature timed out. */
  ERROR_CODE_RESOLVER_TIMED_OUT = 6,
  /**
   * ERROR_CODE_UPSTREAM_FAILED - A crash in a resolver that was to produce an input for
   * the resolver crashed, and so the resolver could not run
   * crashed, and so the resolver could not run.
   */
  ERROR_CODE_UPSTREAM_FAILED = 7,
  /** ERROR_CODE_UNAUTHENTICATED - The request was submitted with an invalid authentication header. */
  ERROR_CODE_UNAUTHENTICATED = 8,
  /** ERROR_CODE_UNAUTHORIZED - The supplied credentials do not provide the right authorization to execute the request. */
  ERROR_CODE_UNAUTHORIZED = 9,
  /** ERROR_CODE_CANCELLED - The operation was cancelled, typically by the caller. */
  ERROR_CODE_CANCELLED = 10,
  /** ERROR_CODE_DEADLINE_EXCEEDED - The deadline expired before the operation could complete. */
  ERROR_CODE_DEADLINE_EXCEEDED = 11,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_INTERNAL_SERVER_ERROR_UNSPECIFIED":
      return ErrorCode.ERROR_CODE_INTERNAL_SERVER_ERROR_UNSPECIFIED;
    case 1:
    case "ERROR_CODE_PARSE_FAILED":
      return ErrorCode.ERROR_CODE_PARSE_FAILED;
    case 2:
    case "ERROR_CODE_RESOLVER_NOT_FOUND":
      return ErrorCode.ERROR_CODE_RESOLVER_NOT_FOUND;
    case 3:
    case "ERROR_CODE_INVALID_QUERY":
      return ErrorCode.ERROR_CODE_INVALID_QUERY;
    case 4:
    case "ERROR_CODE_VALIDATION_FAILED":
      return ErrorCode.ERROR_CODE_VALIDATION_FAILED;
    case 5:
    case "ERROR_CODE_RESOLVER_FAILED":
      return ErrorCode.ERROR_CODE_RESOLVER_FAILED;
    case 6:
    case "ERROR_CODE_RESOLVER_TIMED_OUT":
      return ErrorCode.ERROR_CODE_RESOLVER_TIMED_OUT;
    case 7:
    case "ERROR_CODE_UPSTREAM_FAILED":
      return ErrorCode.ERROR_CODE_UPSTREAM_FAILED;
    case 8:
    case "ERROR_CODE_UNAUTHENTICATED":
      return ErrorCode.ERROR_CODE_UNAUTHENTICATED;
    case 9:
    case "ERROR_CODE_UNAUTHORIZED":
      return ErrorCode.ERROR_CODE_UNAUTHORIZED;
    case 10:
    case "ERROR_CODE_CANCELLED":
      return ErrorCode.ERROR_CODE_CANCELLED;
    case 11:
    case "ERROR_CODE_DEADLINE_EXCEEDED":
      return ErrorCode.ERROR_CODE_DEADLINE_EXCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_CODE_INTERNAL_SERVER_ERROR_UNSPECIFIED:
      return "ERROR_CODE_INTERNAL_SERVER_ERROR_UNSPECIFIED";
    case ErrorCode.ERROR_CODE_PARSE_FAILED:
      return "ERROR_CODE_PARSE_FAILED";
    case ErrorCode.ERROR_CODE_RESOLVER_NOT_FOUND:
      return "ERROR_CODE_RESOLVER_NOT_FOUND";
    case ErrorCode.ERROR_CODE_INVALID_QUERY:
      return "ERROR_CODE_INVALID_QUERY";
    case ErrorCode.ERROR_CODE_VALIDATION_FAILED:
      return "ERROR_CODE_VALIDATION_FAILED";
    case ErrorCode.ERROR_CODE_RESOLVER_FAILED:
      return "ERROR_CODE_RESOLVER_FAILED";
    case ErrorCode.ERROR_CODE_RESOLVER_TIMED_OUT:
      return "ERROR_CODE_RESOLVER_TIMED_OUT";
    case ErrorCode.ERROR_CODE_UPSTREAM_FAILED:
      return "ERROR_CODE_UPSTREAM_FAILED";
    case ErrorCode.ERROR_CODE_UNAUTHENTICATED:
      return "ERROR_CODE_UNAUTHENTICATED";
    case ErrorCode.ERROR_CODE_UNAUTHORIZED:
      return "ERROR_CODE_UNAUTHORIZED";
    case ErrorCode.ERROR_CODE_CANCELLED:
      return "ERROR_CODE_CANCELLED";
    case ErrorCode.ERROR_CODE_DEADLINE_EXCEEDED:
      return "ERROR_CODE_DEADLINE_EXCEEDED";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Network errors are thrown outside your resolvers.
 * For example, your request was unauthenticated,
 * connection failed, or an error occurred within Chalk.
 */
export enum ErrorCodeCategory {
  /** ERROR_CODE_CATEGORY_NETWORK_UNSPECIFIED - -- DEFAULT VALUE -- */
  ERROR_CODE_CATEGORY_NETWORK_UNSPECIFIED = 0,
  /**
   * ERROR_CODE_CATEGORY_REQUEST - Request errors are raised before execution of your
   * resolver code. They may occur due to invalid feature
   * names in the input or a request that cannot be satisfied
   * by the resolvers you have defined.
   */
  ERROR_CODE_CATEGORY_REQUEST = 1,
  /**
   * ERROR_CODE_CATEGORY_FIELD - Field errors are raised while running a feature resolver
   * for a particular field. For this type of error, you'll
   * find a feature and resolver attribute in the error type.
   * When a feature resolver crashes, you will receive null
   * value in the response. To differentiate from a resolver
   * returning a null value and a failure in the resolver,
   * you need to check the error schema.
   */
  ERROR_CODE_CATEGORY_FIELD = 2,
  UNRECOGNIZED = -1,
}

export function errorCodeCategoryFromJSON(object: any): ErrorCodeCategory {
  switch (object) {
    case 0:
    case "ERROR_CODE_CATEGORY_NETWORK_UNSPECIFIED":
      return ErrorCodeCategory.ERROR_CODE_CATEGORY_NETWORK_UNSPECIFIED;
    case 1:
    case "ERROR_CODE_CATEGORY_REQUEST":
      return ErrorCodeCategory.ERROR_CODE_CATEGORY_REQUEST;
    case 2:
    case "ERROR_CODE_CATEGORY_FIELD":
      return ErrorCodeCategory.ERROR_CODE_CATEGORY_FIELD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCodeCategory.UNRECOGNIZED;
  }
}

export function errorCodeCategoryToJSON(object: ErrorCodeCategory): string {
  switch (object) {
    case ErrorCodeCategory.ERROR_CODE_CATEGORY_NETWORK_UNSPECIFIED:
      return "ERROR_CODE_CATEGORY_NETWORK_UNSPECIFIED";
    case ErrorCodeCategory.ERROR_CODE_CATEGORY_REQUEST:
      return "ERROR_CODE_CATEGORY_REQUEST";
    case ErrorCodeCategory.ERROR_CODE_CATEGORY_FIELD:
      return "ERROR_CODE_CATEGORY_FIELD";
    case ErrorCodeCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ChalkException {
  /** The name of the class of the exception. */
  kind: string;
  /** The message taken from the exception. */
  message: string;
  /** The stacktrace produced by the code. */
  stacktrace: string;
  /** The stacktrace produced by the code, full detail. */
  internalStacktrace: string;
}

export interface ChalkError {
  code: ErrorCode;
  category: ErrorCodeCategory;
  /** A readable description of the error message. */
  message: string;
  /** A human-readable hint that can be used to identify the entity that this error is associated with. */
  displayPrimaryKey?:
    | string
    | undefined;
  /** If provided, can be used to add additional context to 'display_primary_key'. */
  displayPrimaryKeyFqn?:
    | string
    | undefined;
  /** The exception that caused the failure, if applicable. */
  exception?:
    | ChalkException
    | undefined;
  /** The fully qualified name of the failing feature, e.g. `user.identity.has_voip_phone`. */
  feature?:
    | string
    | undefined;
  /** The fully qualified name of the failing resolver, e.g. `my.project.get_fraud_score`. */
  resolver?: string | undefined;
}

function createBaseChalkException(): ChalkException {
  return { kind: "", message: "", stacktrace: "", internalStacktrace: "" };
}

export const ChalkException: MessageFns<ChalkException> = {
  encode(message: ChalkException, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.stacktrace !== "") {
      writer.uint32(26).string(message.stacktrace);
    }
    if (message.internalStacktrace !== "") {
      writer.uint32(34).string(message.internalStacktrace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChalkException {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChalkException();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stacktrace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.internalStacktrace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChalkException {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      stacktrace: isSet(object.stacktrace) ? globalThis.String(object.stacktrace) : "",
      internalStacktrace: isSet(object.internalStacktrace) ? globalThis.String(object.internalStacktrace) : "",
    };
  },

  toJSON(message: ChalkException): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.stacktrace !== "") {
      obj.stacktrace = message.stacktrace;
    }
    if (message.internalStacktrace !== "") {
      obj.internalStacktrace = message.internalStacktrace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChalkException>, I>>(base?: I): ChalkException {
    return ChalkException.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChalkException>, I>>(object: I): ChalkException {
    const message = createBaseChalkException();
    message.kind = object.kind ?? "";
    message.message = object.message ?? "";
    message.stacktrace = object.stacktrace ?? "";
    message.internalStacktrace = object.internalStacktrace ?? "";
    return message;
  },
};

function createBaseChalkError(): ChalkError {
  return {
    code: 0,
    category: 0,
    message: "",
    displayPrimaryKey: undefined,
    displayPrimaryKeyFqn: undefined,
    exception: undefined,
    feature: undefined,
    resolver: undefined,
  };
}

export const ChalkError: MessageFns<ChalkError> = {
  encode(message: ChalkError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.displayPrimaryKey !== undefined) {
      writer.uint32(810).string(message.displayPrimaryKey);
    }
    if (message.displayPrimaryKeyFqn !== undefined) {
      writer.uint32(818).string(message.displayPrimaryKeyFqn);
    }
    if (message.exception !== undefined) {
      ChalkException.encode(message.exception, writer.uint32(826).fork()).join();
    }
    if (message.feature !== undefined) {
      writer.uint32(834).string(message.feature);
    }
    if (message.resolver !== undefined) {
      writer.uint32(842).string(message.resolver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChalkError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChalkError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.displayPrimaryKey = reader.string();
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.displayPrimaryKeyFqn = reader.string();
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.exception = ChalkException.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.feature = reader.string();
          continue;
        }
        case 105: {
          if (tag !== 842) {
            break;
          }

          message.resolver = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChalkError {
    return {
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
      category: isSet(object.category) ? errorCodeCategoryFromJSON(object.category) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      displayPrimaryKey: isSet(object.displayPrimaryKey) ? globalThis.String(object.displayPrimaryKey) : undefined,
      displayPrimaryKeyFqn: isSet(object.displayPrimaryKeyFqn)
        ? globalThis.String(object.displayPrimaryKeyFqn)
        : undefined,
      exception: isSet(object.exception) ? ChalkException.fromJSON(object.exception) : undefined,
      feature: isSet(object.feature) ? globalThis.String(object.feature) : undefined,
      resolver: isSet(object.resolver) ? globalThis.String(object.resolver) : undefined,
    };
  },

  toJSON(message: ChalkError): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    if (message.category !== 0) {
      obj.category = errorCodeCategoryToJSON(message.category);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.displayPrimaryKey !== undefined) {
      obj.displayPrimaryKey = message.displayPrimaryKey;
    }
    if (message.displayPrimaryKeyFqn !== undefined) {
      obj.displayPrimaryKeyFqn = message.displayPrimaryKeyFqn;
    }
    if (message.exception !== undefined) {
      obj.exception = ChalkException.toJSON(message.exception);
    }
    if (message.feature !== undefined) {
      obj.feature = message.feature;
    }
    if (message.resolver !== undefined) {
      obj.resolver = message.resolver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChalkError>, I>>(base?: I): ChalkError {
    return ChalkError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChalkError>, I>>(object: I): ChalkError {
    const message = createBaseChalkError();
    message.code = object.code ?? 0;
    message.category = object.category ?? 0;
    message.message = object.message ?? "";
    message.displayPrimaryKey = object.displayPrimaryKey ?? undefined;
    message.displayPrimaryKeyFqn = object.displayPrimaryKeyFqn ?? undefined;
    message.exception = (object.exception !== undefined && object.exception !== null)
      ? ChalkException.fromPartial(object.exception)
      : undefined;
    message.feature = object.feature ?? undefined;
    message.resolver = object.resolver ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
