// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/common/v1/dataset_response.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { ChalkError } from "./chalk_error";
import { QueryStatus, queryStatusFromJSON, queryStatusToJSON } from "./query_status";

export const protobufPackage = "chalk.common.v1";

export interface DatasetSampleFilter {
  lowerBound?: Date | undefined;
  upperBound?: Date | undefined;
  maxSamples?: number | undefined;
}

export interface DatasetFilter {
  sampleFilters: DatasetSampleFilter | undefined;
  maxCacheAgeSecs?: number | undefined;
}

export interface DatasetRevisionResponse {
  datasetName?: string | undefined;
  datasetId?: string | undefined;
  environmentId?: string | undefined;
  revisionId?: string | undefined;
  creatorId: string;
  outputs: string[];
  givensUri?: string | undefined;
  status: QueryStatus;
  filters: DatasetFilter | undefined;
  numPartitions: number;
  numBytes?: number | undefined;
  outputUris: string;
  outputVersion: number;
  branch?: string | undefined;
  dashboardUrl?: string | undefined;
  createdAt?: Date | undefined;
  startedAt?: Date | undefined;
  terminatedAt?: Date | undefined;
}

export interface DatasetResponse {
  /** Whether the export job is finished (it runs asynchronously) */
  isFinished: boolean;
  /**
   * Version number representing the format of the data. The client uses this version number
   * to properly decode and load the query results into DataFrames.
   */
  version: number;
  environmentId: string;
  datasetId: string;
  datasetName: string;
  errors: ChalkError[];
  revisions: DatasetRevisionResponse[];
}

function createBaseDatasetSampleFilter(): DatasetSampleFilter {
  return { lowerBound: undefined, upperBound: undefined, maxSamples: undefined };
}

export const DatasetSampleFilter: MessageFns<DatasetSampleFilter> = {
  encode(message: DatasetSampleFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowerBound !== undefined) {
      Timestamp.encode(toTimestamp(message.lowerBound), writer.uint32(10).fork()).join();
    }
    if (message.upperBound !== undefined) {
      Timestamp.encode(toTimestamp(message.upperBound), writer.uint32(18).fork()).join();
    }
    if (message.maxSamples !== undefined) {
      writer.uint32(24).int32(message.maxSamples);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetSampleFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetSampleFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lowerBound = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upperBound = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxSamples = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetSampleFilter {
    return {
      lowerBound: isSet(object.lowerBound) ? fromJsonTimestamp(object.lowerBound) : undefined,
      upperBound: isSet(object.upperBound) ? fromJsonTimestamp(object.upperBound) : undefined,
      maxSamples: isSet(object.maxSamples) ? globalThis.Number(object.maxSamples) : undefined,
    };
  },

  toJSON(message: DatasetSampleFilter): unknown {
    const obj: any = {};
    if (message.lowerBound !== undefined) {
      obj.lowerBound = message.lowerBound.toISOString();
    }
    if (message.upperBound !== undefined) {
      obj.upperBound = message.upperBound.toISOString();
    }
    if (message.maxSamples !== undefined) {
      obj.maxSamples = Math.round(message.maxSamples);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetSampleFilter>, I>>(base?: I): DatasetSampleFilter {
    return DatasetSampleFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetSampleFilter>, I>>(object: I): DatasetSampleFilter {
    const message = createBaseDatasetSampleFilter();
    message.lowerBound = object.lowerBound ?? undefined;
    message.upperBound = object.upperBound ?? undefined;
    message.maxSamples = object.maxSamples ?? undefined;
    return message;
  },
};

function createBaseDatasetFilter(): DatasetFilter {
  return { sampleFilters: undefined, maxCacheAgeSecs: undefined };
}

export const DatasetFilter: MessageFns<DatasetFilter> = {
  encode(message: DatasetFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleFilters !== undefined) {
      DatasetSampleFilter.encode(message.sampleFilters, writer.uint32(10).fork()).join();
    }
    if (message.maxCacheAgeSecs !== undefined) {
      writer.uint32(21).float(message.maxCacheAgeSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sampleFilters = DatasetSampleFilter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxCacheAgeSecs = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetFilter {
    return {
      sampleFilters: isSet(object.sampleFilters) ? DatasetSampleFilter.fromJSON(object.sampleFilters) : undefined,
      maxCacheAgeSecs: isSet(object.maxCacheAgeSecs) ? globalThis.Number(object.maxCacheAgeSecs) : undefined,
    };
  },

  toJSON(message: DatasetFilter): unknown {
    const obj: any = {};
    if (message.sampleFilters !== undefined) {
      obj.sampleFilters = DatasetSampleFilter.toJSON(message.sampleFilters);
    }
    if (message.maxCacheAgeSecs !== undefined) {
      obj.maxCacheAgeSecs = message.maxCacheAgeSecs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetFilter>, I>>(base?: I): DatasetFilter {
    return DatasetFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetFilter>, I>>(object: I): DatasetFilter {
    const message = createBaseDatasetFilter();
    message.sampleFilters = (object.sampleFilters !== undefined && object.sampleFilters !== null)
      ? DatasetSampleFilter.fromPartial(object.sampleFilters)
      : undefined;
    message.maxCacheAgeSecs = object.maxCacheAgeSecs ?? undefined;
    return message;
  },
};

function createBaseDatasetRevisionResponse(): DatasetRevisionResponse {
  return {
    datasetName: undefined,
    datasetId: undefined,
    environmentId: undefined,
    revisionId: undefined,
    creatorId: "",
    outputs: [],
    givensUri: undefined,
    status: 0,
    filters: undefined,
    numPartitions: 0,
    numBytes: undefined,
    outputUris: "",
    outputVersion: 0,
    branch: undefined,
    dashboardUrl: undefined,
    createdAt: undefined,
    startedAt: undefined,
    terminatedAt: undefined,
  };
}

export const DatasetRevisionResponse: MessageFns<DatasetRevisionResponse> = {
  encode(message: DatasetRevisionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetName !== undefined) {
      writer.uint32(10).string(message.datasetName);
    }
    if (message.datasetId !== undefined) {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.environmentId !== undefined) {
      writer.uint32(26).string(message.environmentId);
    }
    if (message.revisionId !== undefined) {
      writer.uint32(34).string(message.revisionId);
    }
    if (message.creatorId !== "") {
      writer.uint32(42).string(message.creatorId);
    }
    for (const v of message.outputs) {
      writer.uint32(50).string(v!);
    }
    if (message.givensUri !== undefined) {
      writer.uint32(58).string(message.givensUri);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.filters !== undefined) {
      DatasetFilter.encode(message.filters, writer.uint32(74).fork()).join();
    }
    if (message.numPartitions !== 0) {
      writer.uint32(80).int32(message.numPartitions);
    }
    if (message.numBytes !== undefined) {
      writer.uint32(88).int32(message.numBytes);
    }
    if (message.outputUris !== "") {
      writer.uint32(98).string(message.outputUris);
    }
    if (message.outputVersion !== 0) {
      writer.uint32(104).int32(message.outputVersion);
    }
    if (message.branch !== undefined) {
      writer.uint32(114).string(message.branch);
    }
    if (message.dashboardUrl !== undefined) {
      writer.uint32(122).string(message.dashboardUrl);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(810).fork()).join();
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(818).fork()).join();
    }
    if (message.terminatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.terminatedAt), writer.uint32(826).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetRevisionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetRevisionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.datasetName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputs.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.givensUri = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.filters = DatasetFilter.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.numPartitions = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.numBytes = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.outputUris = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.outputVersion = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.dashboardUrl = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.terminatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetRevisionResponse {
    return {
      datasetName: isSet(object.datasetName) ? globalThis.String(object.datasetName) : undefined,
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : undefined,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : undefined,
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : undefined,
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => globalThis.String(e)) : [],
      givensUri: isSet(object.givensUri) ? globalThis.String(object.givensUri) : undefined,
      status: isSet(object.status) ? queryStatusFromJSON(object.status) : 0,
      filters: isSet(object.filters) ? DatasetFilter.fromJSON(object.filters) : undefined,
      numPartitions: isSet(object.numPartitions) ? globalThis.Number(object.numPartitions) : 0,
      numBytes: isSet(object.numBytes) ? globalThis.Number(object.numBytes) : undefined,
      outputUris: isSet(object.outputUris) ? globalThis.String(object.outputUris) : "",
      outputVersion: isSet(object.outputVersion) ? globalThis.Number(object.outputVersion) : 0,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
      dashboardUrl: isSet(object.dashboardUrl) ? globalThis.String(object.dashboardUrl) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      terminatedAt: isSet(object.terminatedAt) ? fromJsonTimestamp(object.terminatedAt) : undefined,
    };
  },

  toJSON(message: DatasetRevisionResponse): unknown {
    const obj: any = {};
    if (message.datasetName !== undefined) {
      obj.datasetName = message.datasetName;
    }
    if (message.datasetId !== undefined) {
      obj.datasetId = message.datasetId;
    }
    if (message.environmentId !== undefined) {
      obj.environmentId = message.environmentId;
    }
    if (message.revisionId !== undefined) {
      obj.revisionId = message.revisionId;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs;
    }
    if (message.givensUri !== undefined) {
      obj.givensUri = message.givensUri;
    }
    if (message.status !== 0) {
      obj.status = queryStatusToJSON(message.status);
    }
    if (message.filters !== undefined) {
      obj.filters = DatasetFilter.toJSON(message.filters);
    }
    if (message.numPartitions !== 0) {
      obj.numPartitions = Math.round(message.numPartitions);
    }
    if (message.numBytes !== undefined) {
      obj.numBytes = Math.round(message.numBytes);
    }
    if (message.outputUris !== "") {
      obj.outputUris = message.outputUris;
    }
    if (message.outputVersion !== 0) {
      obj.outputVersion = Math.round(message.outputVersion);
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    if (message.dashboardUrl !== undefined) {
      obj.dashboardUrl = message.dashboardUrl;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.terminatedAt !== undefined) {
      obj.terminatedAt = message.terminatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetRevisionResponse>, I>>(base?: I): DatasetRevisionResponse {
    return DatasetRevisionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetRevisionResponse>, I>>(object: I): DatasetRevisionResponse {
    const message = createBaseDatasetRevisionResponse();
    message.datasetName = object.datasetName ?? undefined;
    message.datasetId = object.datasetId ?? undefined;
    message.environmentId = object.environmentId ?? undefined;
    message.revisionId = object.revisionId ?? undefined;
    message.creatorId = object.creatorId ?? "";
    message.outputs = object.outputs?.map((e) => e) || [];
    message.givensUri = object.givensUri ?? undefined;
    message.status = object.status ?? 0;
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? DatasetFilter.fromPartial(object.filters)
      : undefined;
    message.numPartitions = object.numPartitions ?? 0;
    message.numBytes = object.numBytes ?? undefined;
    message.outputUris = object.outputUris ?? "";
    message.outputVersion = object.outputVersion ?? 0;
    message.branch = object.branch ?? undefined;
    message.dashboardUrl = object.dashboardUrl ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.terminatedAt = object.terminatedAt ?? undefined;
    return message;
  },
};

function createBaseDatasetResponse(): DatasetResponse {
  return {
    isFinished: false,
    version: 0,
    environmentId: "",
    datasetId: "",
    datasetName: "",
    errors: [],
    revisions: [],
  };
}

export const DatasetResponse: MessageFns<DatasetResponse> = {
  encode(message: DatasetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isFinished !== false) {
      writer.uint32(8).bool(message.isFinished);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.environmentId !== "") {
      writer.uint32(26).string(message.environmentId);
    }
    if (message.datasetId !== "") {
      writer.uint32(34).string(message.datasetId);
    }
    if (message.datasetName !== "") {
      writer.uint32(42).string(message.datasetName);
    }
    for (const v of message.errors) {
      ChalkError.encode(v!, writer.uint32(810).fork()).join();
    }
    for (const v of message.revisions) {
      DatasetRevisionResponse.encode(v!, writer.uint32(818).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isFinished = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.datasetName = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.errors.push(ChalkError.decode(reader, reader.uint32()));
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.revisions.push(DatasetRevisionResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetResponse {
    return {
      isFinished: isSet(object.isFinished) ? globalThis.Boolean(object.isFinished) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetName: isSet(object.datasetName) ? globalThis.String(object.datasetName) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ChalkError.fromJSON(e)) : [],
      revisions: globalThis.Array.isArray(object?.revisions)
        ? object.revisions.map((e: any) => DatasetRevisionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DatasetResponse): unknown {
    const obj: any = {};
    if (message.isFinished !== false) {
      obj.isFinished = message.isFinished;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetName !== "") {
      obj.datasetName = message.datasetName;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ChalkError.toJSON(e));
    }
    if (message.revisions?.length) {
      obj.revisions = message.revisions.map((e) => DatasetRevisionResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatasetResponse>, I>>(base?: I): DatasetResponse {
    return DatasetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatasetResponse>, I>>(object: I): DatasetResponse {
    const message = createBaseDatasetResponse();
    message.isFinished = object.isFinished ?? false;
    message.version = object.version ?? 0;
    message.environmentId = object.environmentId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.datasetName = object.datasetName ?? "";
    message.errors = object.errors?.map((e) => ChalkError.fromPartial(e)) || [];
    message.revisions = object.revisions?.map((e) => DatasetRevisionResponse.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
