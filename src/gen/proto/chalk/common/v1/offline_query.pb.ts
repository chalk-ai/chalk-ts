// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/common/v1/offline_query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ListValue, Value } from "../../../google/protobuf/struct.pb";
import { LogicalExprNode } from "../../expression/v1/expression.pb";
import { OverlayGraph } from "../../graph/v1/graph.pb";
import { ChalkError } from "./chalk_error.pb";
import { ExplainOptions } from "./online_query.pb";

export const protobufPackage = "chalk.common.v1";

export interface OfflineQueryRecomputeFeatures {
  allOrNone?: boolean | undefined;
  featureList?: OfflineQueryRecomputeFeatures_FeatureList | undefined;
}

export interface OfflineQueryRecomputeFeatures_FeatureList {
  featureList: string[];
}

/** OfflineQueryExplain is DEPRECATED. DO NOT USE IT!! */
export interface OfflineQueryExplain {
  truthy?: boolean | undefined;
  only?: OfflineQueryExplain_Only | undefined;
}

export interface OfflineQueryExplain_Only {
}

export interface OfflineQueryInput {
  columns: string[];
  /** Note that this is a list of lists. Each list is the input for a single column */
  values: Array<any>[];
}

export interface OfflineQueryInputSharded {
  inputs: OfflineQueryInput[];
}

export interface OfflineQueryInputs {
  /** Should be a feather-compressed table, complete with schema */
  featherInputs?: Uint8Array | undefined;
  noInputs?: OfflineQueryInputs_NoInputs | undefined;
  singleInputs?: OfflineQueryInput | undefined;
  shardedInputs?: OfflineQueryInputSharded | undefined;
}

export interface OfflineQueryInputs_NoInputs {
}

/**
 * A gRPC representation of the JSON body expected by the offline query endpoint in the http engine.
 * Note that this is being used by chalkSQL
 *
 * Light mirror of go-api-server/shared/rpc_models_query.go#CreateOfflineQueryJobRequest
 */
export interface OfflineQueryRequest {
  inputs:
    | OfflineQueryInputs
    | undefined;
  /** A list of output feature root fqns to query */
  outputs: string[];
  /** A list of required output feature root fqns */
  requiredOutputs: string[];
  /** The desired output format. Should be 'CSV' or 'PARQUET */
  destinationFormat: string;
  branch?: string | undefined;
  datasetName?: string | undefined;
  recomputeFeatures: OfflineQueryRecomputeFeatures | undefined;
  storePlanStages: boolean;
  /** "Where" clause */
  filters: LogicalExprNode[];
  /** This is an alternative way to specify inputs - a SQL query that retrieves outputs */
  spineSqlQuery?:
    | string
    | undefined;
  /** The maximum number of samples. If None, no limit */
  maxSamples?:
    | number
    | undefined;
  /**
   * The maximum staleness, in seconds, for how old the view on the offline store can be. That is,
   * data ingested within this interval will not be reflected in this offline query.
   * Set to ``0`` to ignore the cache. If not specified, it defaults to OFFLINE_QUERY_MAX_CACHE_AGE_SECS
   * in chalk engine config.
   */
  maxCacheAgeSecs?:
    | number
    | undefined;
  /**
   * Field is deprecated because we shouldn't have OnlineExplain that differs from OfflineExplain
   * Use explain2
   *
   * @deprecated
   */
  explain: OfflineQueryExplain | undefined;
  explain2: ExplainOptions | undefined;
  tags: string[];
  correlationId?: string | undefined;
  requiredResolverTags: string[];
  /** The lower bound for the observed at timestamp (inclusive). If not specified, defaults to the beginning of time */
  observedAtLowerBound?:
    | string
    | undefined;
  /** The upper bound for the observed at timestamp (inclusive). If not specified, defaults to the end of time */
  observedAtUpperBound?:
    | string
    | undefined;
  /** Planner options to pass to the engine, overriding any default/set by environment variable */
  plannerOptions: { [key: string]: any | undefined };
  /** Whether computed results should be persisted in the online/offline store */
  storeOnline?: boolean | undefined;
  storeOffline?:
    | boolean
    | undefined;
  /** Whether or not to run this offline query asynchronously. */
  useMultipleComputers?: boolean | undefined;
  numShards?: number | undefined;
  numWorkers?:
    | number
    | undefined;
  /** Additional customer-defined context passed in to resolvers (see https://docs.chalk.ai/api-docs#ChalkContext) */
  queryContext: { [key: string]: any | undefined };
  /** Additional features and resolvers to be used to plan this specific query */
  overlayGraph?: OverlayGraph | undefined;
}

export interface OfflineQueryRequest_PlannerOptionsEntry {
  key: string;
  value: any | undefined;
}

export interface OfflineQueryRequest_QueryContextEntry {
  key: string;
  value: any | undefined;
}

export interface ColumnMetadataList {
  metadata: ColumnMetadataList_ColumnMetadata[];
}

export interface ColumnMetadataList_ColumnMetadata {
  /** The root FQN of the feature for a column */
  featureFqn: string;
  /** The name of the column that corresponds to this feature */
  columnName: string;
  /** The data type for this feature */
  dtype: string;
}

/**
 * This represents the response returned by engine chalksql/get_offline_job_proto_v4
 * For the message that v4/offline_query returns, check out common/v1/dataset_response.proto
 */
export interface GetOfflineQueryJobResponse {
  isFinished: boolean;
  version: number;
  urls: string[];
  errors: ChalkError[];
  columns?: ColumnMetadataList | undefined;
}

function createBaseOfflineQueryRecomputeFeatures(): OfflineQueryRecomputeFeatures {
  return { allOrNone: undefined, featureList: undefined };
}

export const OfflineQueryRecomputeFeatures: MessageFns<OfflineQueryRecomputeFeatures> = {
  encode(message: OfflineQueryRecomputeFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allOrNone !== undefined) {
      writer.uint32(8).bool(message.allOrNone);
    }
    if (message.featureList !== undefined) {
      OfflineQueryRecomputeFeatures_FeatureList.encode(message.featureList, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryRecomputeFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryRecomputeFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.allOrNone = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.featureList = OfflineQueryRecomputeFeatures_FeatureList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryRecomputeFeatures {
    return {
      allOrNone: isSet(object.allOrNone) ? globalThis.Boolean(object.allOrNone) : undefined,
      featureList: isSet(object.featureList)
        ? OfflineQueryRecomputeFeatures_FeatureList.fromJSON(object.featureList)
        : undefined,
    };
  },

  toJSON(message: OfflineQueryRecomputeFeatures): unknown {
    const obj: any = {};
    if (message.allOrNone !== undefined) {
      obj.allOrNone = message.allOrNone;
    }
    if (message.featureList !== undefined) {
      obj.featureList = OfflineQueryRecomputeFeatures_FeatureList.toJSON(message.featureList);
    }
    return obj;
  },
};

function createBaseOfflineQueryRecomputeFeatures_FeatureList(): OfflineQueryRecomputeFeatures_FeatureList {
  return { featureList: [] };
}

export const OfflineQueryRecomputeFeatures_FeatureList: MessageFns<OfflineQueryRecomputeFeatures_FeatureList> = {
  encode(message: OfflineQueryRecomputeFeatures_FeatureList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.featureList) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryRecomputeFeatures_FeatureList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryRecomputeFeatures_FeatureList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryRecomputeFeatures_FeatureList {
    return {
      featureList: globalThis.Array.isArray(object?.featureList)
        ? object.featureList.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OfflineQueryRecomputeFeatures_FeatureList): unknown {
    const obj: any = {};
    if (message.featureList?.length) {
      obj.featureList = message.featureList;
    }
    return obj;
  },
};

function createBaseOfflineQueryExplain(): OfflineQueryExplain {
  return { truthy: undefined, only: undefined };
}

export const OfflineQueryExplain: MessageFns<OfflineQueryExplain> = {
  encode(message: OfflineQueryExplain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.truthy !== undefined) {
      writer.uint32(8).bool(message.truthy);
    }
    if (message.only !== undefined) {
      OfflineQueryExplain_Only.encode(message.only, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryExplain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryExplain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.truthy = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.only = OfflineQueryExplain_Only.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryExplain {
    return {
      truthy: isSet(object.truthy) ? globalThis.Boolean(object.truthy) : undefined,
      only: isSet(object.only) ? OfflineQueryExplain_Only.fromJSON(object.only) : undefined,
    };
  },

  toJSON(message: OfflineQueryExplain): unknown {
    const obj: any = {};
    if (message.truthy !== undefined) {
      obj.truthy = message.truthy;
    }
    if (message.only !== undefined) {
      obj.only = OfflineQueryExplain_Only.toJSON(message.only);
    }
    return obj;
  },
};

function createBaseOfflineQueryExplain_Only(): OfflineQueryExplain_Only {
  return {};
}

export const OfflineQueryExplain_Only: MessageFns<OfflineQueryExplain_Only> = {
  encode(_: OfflineQueryExplain_Only, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryExplain_Only {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryExplain_Only();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OfflineQueryExplain_Only {
    return {};
  },

  toJSON(_: OfflineQueryExplain_Only): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseOfflineQueryInput(): OfflineQueryInput {
  return { columns: [], values: [] };
}

export const OfflineQueryInput: MessageFns<OfflineQueryInput> = {
  encode(message: OfflineQueryInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.values) {
      ListValue.encode(ListValue.wrap(v!), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.values.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryInput {
    return {
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => [...e]) : [],
    };
  },

  toJSON(message: OfflineQueryInput): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
};

function createBaseOfflineQueryInputSharded(): OfflineQueryInputSharded {
  return { inputs: [] };
}

export const OfflineQueryInputSharded: MessageFns<OfflineQueryInputSharded> = {
  encode(message: OfflineQueryInputSharded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputs) {
      OfflineQueryInput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryInputSharded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryInputSharded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputs.push(OfflineQueryInput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryInputSharded {
    return {
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => OfflineQueryInput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OfflineQueryInputSharded): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => OfflineQueryInput.toJSON(e));
    }
    return obj;
  },
};

function createBaseOfflineQueryInputs(): OfflineQueryInputs {
  return { featherInputs: undefined, noInputs: undefined, singleInputs: undefined, shardedInputs: undefined };
}

export const OfflineQueryInputs: MessageFns<OfflineQueryInputs> = {
  encode(message: OfflineQueryInputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featherInputs !== undefined) {
      writer.uint32(10).bytes(message.featherInputs);
    }
    if (message.noInputs !== undefined) {
      OfflineQueryInputs_NoInputs.encode(message.noInputs, writer.uint32(18).fork()).join();
    }
    if (message.singleInputs !== undefined) {
      OfflineQueryInput.encode(message.singleInputs, writer.uint32(26).fork()).join();
    }
    if (message.shardedInputs !== undefined) {
      OfflineQueryInputSharded.encode(message.shardedInputs, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryInputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryInputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featherInputs = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.noInputs = OfflineQueryInputs_NoInputs.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.singleInputs = OfflineQueryInput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shardedInputs = OfflineQueryInputSharded.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryInputs {
    return {
      featherInputs: isSet(object.featherInputs) ? bytesFromBase64(object.featherInputs) : undefined,
      noInputs: isSet(object.noInputs) ? OfflineQueryInputs_NoInputs.fromJSON(object.noInputs) : undefined,
      singleInputs: isSet(object.singleInputs) ? OfflineQueryInput.fromJSON(object.singleInputs) : undefined,
      shardedInputs: isSet(object.shardedInputs) ? OfflineQueryInputSharded.fromJSON(object.shardedInputs) : undefined,
    };
  },

  toJSON(message: OfflineQueryInputs): unknown {
    const obj: any = {};
    if (message.featherInputs !== undefined) {
      obj.featherInputs = base64FromBytes(message.featherInputs);
    }
    if (message.noInputs !== undefined) {
      obj.noInputs = OfflineQueryInputs_NoInputs.toJSON(message.noInputs);
    }
    if (message.singleInputs !== undefined) {
      obj.singleInputs = OfflineQueryInput.toJSON(message.singleInputs);
    }
    if (message.shardedInputs !== undefined) {
      obj.shardedInputs = OfflineQueryInputSharded.toJSON(message.shardedInputs);
    }
    return obj;
  },
};

function createBaseOfflineQueryInputs_NoInputs(): OfflineQueryInputs_NoInputs {
  return {};
}

export const OfflineQueryInputs_NoInputs: MessageFns<OfflineQueryInputs_NoInputs> = {
  encode(_: OfflineQueryInputs_NoInputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryInputs_NoInputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryInputs_NoInputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OfflineQueryInputs_NoInputs {
    return {};
  },

  toJSON(_: OfflineQueryInputs_NoInputs): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseOfflineQueryRequest(): OfflineQueryRequest {
  return {
    inputs: undefined,
    outputs: [],
    requiredOutputs: [],
    destinationFormat: "",
    branch: undefined,
    datasetName: undefined,
    recomputeFeatures: undefined,
    storePlanStages: false,
    filters: [],
    spineSqlQuery: undefined,
    maxSamples: undefined,
    maxCacheAgeSecs: undefined,
    explain: undefined,
    explain2: undefined,
    tags: [],
    correlationId: undefined,
    requiredResolverTags: [],
    observedAtLowerBound: undefined,
    observedAtUpperBound: undefined,
    plannerOptions: {},
    storeOnline: undefined,
    storeOffline: undefined,
    useMultipleComputers: undefined,
    numShards: undefined,
    numWorkers: undefined,
    queryContext: {},
    overlayGraph: undefined,
  };
}

export const OfflineQueryRequest: MessageFns<OfflineQueryRequest> = {
  encode(message: OfflineQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== undefined) {
      OfflineQueryInputs.encode(message.inputs, writer.uint32(10).fork()).join();
    }
    for (const v of message.outputs) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.requiredOutputs) {
      writer.uint32(26).string(v!);
    }
    if (message.destinationFormat !== "") {
      writer.uint32(34).string(message.destinationFormat);
    }
    if (message.branch !== undefined) {
      writer.uint32(42).string(message.branch);
    }
    if (message.datasetName !== undefined) {
      writer.uint32(50).string(message.datasetName);
    }
    if (message.recomputeFeatures !== undefined) {
      OfflineQueryRecomputeFeatures.encode(message.recomputeFeatures, writer.uint32(58).fork()).join();
    }
    if (message.storePlanStages !== false) {
      writer.uint32(64).bool(message.storePlanStages);
    }
    for (const v of message.filters) {
      LogicalExprNode.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.spineSqlQuery !== undefined) {
      writer.uint32(98).string(message.spineSqlQuery);
    }
    if (message.maxSamples !== undefined) {
      writer.uint32(808).int32(message.maxSamples);
    }
    if (message.maxCacheAgeSecs !== undefined) {
      writer.uint32(816).int32(message.maxCacheAgeSecs);
    }
    if (message.explain !== undefined) {
      OfflineQueryExplain.encode(message.explain, writer.uint32(826).fork()).join();
    }
    if (message.explain2 !== undefined) {
      ExplainOptions.encode(message.explain2, writer.uint32(850).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(834).string(v!);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(842).string(message.correlationId);
    }
    for (const v of message.requiredResolverTags) {
      writer.uint32(858).string(v!);
    }
    if (message.observedAtLowerBound !== undefined) {
      writer.uint32(1610).string(message.observedAtLowerBound);
    }
    if (message.observedAtUpperBound !== undefined) {
      writer.uint32(1618).string(message.observedAtUpperBound);
    }
    Object.entries(message.plannerOptions).forEach(([key, value]) => {
      if (value !== undefined) {
        OfflineQueryRequest_PlannerOptionsEntry.encode({ key: key as any, value }, writer.uint32(1626).fork()).join();
      }
    });
    if (message.storeOnline !== undefined) {
      writer.uint32(1632).bool(message.storeOnline);
    }
    if (message.storeOffline !== undefined) {
      writer.uint32(1640).bool(message.storeOffline);
    }
    if (message.useMultipleComputers !== undefined) {
      writer.uint32(1648).bool(message.useMultipleComputers);
    }
    if (message.numShards !== undefined) {
      writer.uint32(1656).int32(message.numShards);
    }
    if (message.numWorkers !== undefined) {
      writer.uint32(1664).int32(message.numWorkers);
    }
    Object.entries(message.queryContext).forEach(([key, value]) => {
      if (value !== undefined) {
        OfflineQueryRequest_QueryContextEntry.encode({ key: key as any, value }, writer.uint32(1674).fork()).join();
      }
    });
    if (message.overlayGraph !== undefined) {
      OverlayGraph.encode(message.overlayGraph, writer.uint32(1682).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputs = OfflineQueryInputs.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requiredOutputs.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationFormat = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.datasetName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recomputeFeatures = OfflineQueryRecomputeFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.storePlanStages = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.filters.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.spineSqlQuery = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 808) {
            break;
          }

          message.maxSamples = reader.int32();
          continue;
        }
        case 102: {
          if (tag !== 816) {
            break;
          }

          message.maxCacheAgeSecs = reader.int32();
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.explain = OfflineQueryExplain.decode(reader, reader.uint32());
          continue;
        }
        case 106: {
          if (tag !== 850) {
            break;
          }

          message.explain2 = ExplainOptions.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 105: {
          if (tag !== 842) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 107: {
          if (tag !== 858) {
            break;
          }

          message.requiredResolverTags.push(reader.string());
          continue;
        }
        case 201: {
          if (tag !== 1610) {
            break;
          }

          message.observedAtLowerBound = reader.string();
          continue;
        }
        case 202: {
          if (tag !== 1618) {
            break;
          }

          message.observedAtUpperBound = reader.string();
          continue;
        }
        case 203: {
          if (tag !== 1626) {
            break;
          }

          const entry203 = OfflineQueryRequest_PlannerOptionsEntry.decode(reader, reader.uint32());
          if (entry203.value !== undefined) {
            message.plannerOptions[entry203.key] = entry203.value;
          }
          continue;
        }
        case 204: {
          if (tag !== 1632) {
            break;
          }

          message.storeOnline = reader.bool();
          continue;
        }
        case 205: {
          if (tag !== 1640) {
            break;
          }

          message.storeOffline = reader.bool();
          continue;
        }
        case 206: {
          if (tag !== 1648) {
            break;
          }

          message.useMultipleComputers = reader.bool();
          continue;
        }
        case 207: {
          if (tag !== 1656) {
            break;
          }

          message.numShards = reader.int32();
          continue;
        }
        case 208: {
          if (tag !== 1664) {
            break;
          }

          message.numWorkers = reader.int32();
          continue;
        }
        case 209: {
          if (tag !== 1674) {
            break;
          }

          const entry209 = OfflineQueryRequest_QueryContextEntry.decode(reader, reader.uint32());
          if (entry209.value !== undefined) {
            message.queryContext[entry209.key] = entry209.value;
          }
          continue;
        }
        case 210: {
          if (tag !== 1682) {
            break;
          }

          message.overlayGraph = OverlayGraph.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryRequest {
    return {
      inputs: isSet(object.inputs) ? OfflineQueryInputs.fromJSON(object.inputs) : undefined,
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => globalThis.String(e)) : [],
      requiredOutputs: globalThis.Array.isArray(object?.requiredOutputs)
        ? object.requiredOutputs.map((e: any) => globalThis.String(e))
        : [],
      destinationFormat: isSet(object.destinationFormat) ? globalThis.String(object.destinationFormat) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
      datasetName: isSet(object.datasetName) ? globalThis.String(object.datasetName) : undefined,
      recomputeFeatures: isSet(object.recomputeFeatures)
        ? OfflineQueryRecomputeFeatures.fromJSON(object.recomputeFeatures)
        : undefined,
      storePlanStages: isSet(object.storePlanStages) ? globalThis.Boolean(object.storePlanStages) : false,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      spineSqlQuery: isSet(object.spineSqlQuery) ? globalThis.String(object.spineSqlQuery) : undefined,
      maxSamples: isSet(object.maxSamples) ? globalThis.Number(object.maxSamples) : undefined,
      maxCacheAgeSecs: isSet(object.maxCacheAgeSecs) ? globalThis.Number(object.maxCacheAgeSecs) : undefined,
      explain: isSet(object.explain) ? OfflineQueryExplain.fromJSON(object.explain) : undefined,
      explain2: isSet(object.explain2) ? ExplainOptions.fromJSON(object.explain2) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : undefined,
      requiredResolverTags: globalThis.Array.isArray(object?.requiredResolverTags)
        ? object.requiredResolverTags.map((e: any) => globalThis.String(e))
        : [],
      observedAtLowerBound: isSet(object.observedAtLowerBound)
        ? globalThis.String(object.observedAtLowerBound)
        : undefined,
      observedAtUpperBound: isSet(object.observedAtUpperBound)
        ? globalThis.String(object.observedAtUpperBound)
        : undefined,
      plannerOptions: isObject(object.plannerOptions)
        ? Object.entries(object.plannerOptions).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      storeOnline: isSet(object.storeOnline) ? globalThis.Boolean(object.storeOnline) : undefined,
      storeOffline: isSet(object.storeOffline) ? globalThis.Boolean(object.storeOffline) : undefined,
      useMultipleComputers: isSet(object.useMultipleComputers)
        ? globalThis.Boolean(object.useMultipleComputers)
        : undefined,
      numShards: isSet(object.numShards) ? globalThis.Number(object.numShards) : undefined,
      numWorkers: isSet(object.numWorkers) ? globalThis.Number(object.numWorkers) : undefined,
      queryContext: isObject(object.queryContext)
        ? Object.entries(object.queryContext).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      overlayGraph: isSet(object.overlayGraph) ? OverlayGraph.fromJSON(object.overlayGraph) : undefined,
    };
  },

  toJSON(message: OfflineQueryRequest): unknown {
    const obj: any = {};
    if (message.inputs !== undefined) {
      obj.inputs = OfflineQueryInputs.toJSON(message.inputs);
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs;
    }
    if (message.requiredOutputs?.length) {
      obj.requiredOutputs = message.requiredOutputs;
    }
    if (message.destinationFormat !== "") {
      obj.destinationFormat = message.destinationFormat;
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    if (message.datasetName !== undefined) {
      obj.datasetName = message.datasetName;
    }
    if (message.recomputeFeatures !== undefined) {
      obj.recomputeFeatures = OfflineQueryRecomputeFeatures.toJSON(message.recomputeFeatures);
    }
    if (message.storePlanStages !== false) {
      obj.storePlanStages = message.storePlanStages;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.spineSqlQuery !== undefined) {
      obj.spineSqlQuery = message.spineSqlQuery;
    }
    if (message.maxSamples !== undefined) {
      obj.maxSamples = Math.round(message.maxSamples);
    }
    if (message.maxCacheAgeSecs !== undefined) {
      obj.maxCacheAgeSecs = Math.round(message.maxCacheAgeSecs);
    }
    if (message.explain !== undefined) {
      obj.explain = OfflineQueryExplain.toJSON(message.explain);
    }
    if (message.explain2 !== undefined) {
      obj.explain2 = ExplainOptions.toJSON(message.explain2);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    if (message.requiredResolverTags?.length) {
      obj.requiredResolverTags = message.requiredResolverTags;
    }
    if (message.observedAtLowerBound !== undefined) {
      obj.observedAtLowerBound = message.observedAtLowerBound;
    }
    if (message.observedAtUpperBound !== undefined) {
      obj.observedAtUpperBound = message.observedAtUpperBound;
    }
    if (message.plannerOptions) {
      const entries = Object.entries(message.plannerOptions);
      if (entries.length > 0) {
        obj.plannerOptions = {};
        entries.forEach(([k, v]) => {
          obj.plannerOptions[k] = v;
        });
      }
    }
    if (message.storeOnline !== undefined) {
      obj.storeOnline = message.storeOnline;
    }
    if (message.storeOffline !== undefined) {
      obj.storeOffline = message.storeOffline;
    }
    if (message.useMultipleComputers !== undefined) {
      obj.useMultipleComputers = message.useMultipleComputers;
    }
    if (message.numShards !== undefined) {
      obj.numShards = Math.round(message.numShards);
    }
    if (message.numWorkers !== undefined) {
      obj.numWorkers = Math.round(message.numWorkers);
    }
    if (message.queryContext) {
      const entries = Object.entries(message.queryContext);
      if (entries.length > 0) {
        obj.queryContext = {};
        entries.forEach(([k, v]) => {
          obj.queryContext[k] = v;
        });
      }
    }
    if (message.overlayGraph !== undefined) {
      obj.overlayGraph = OverlayGraph.toJSON(message.overlayGraph);
    }
    return obj;
  },
};

function createBaseOfflineQueryRequest_PlannerOptionsEntry(): OfflineQueryRequest_PlannerOptionsEntry {
  return { key: "", value: undefined };
}

export const OfflineQueryRequest_PlannerOptionsEntry: MessageFns<OfflineQueryRequest_PlannerOptionsEntry> = {
  encode(message: OfflineQueryRequest_PlannerOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryRequest_PlannerOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryRequest_PlannerOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryRequest_PlannerOptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: OfflineQueryRequest_PlannerOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseOfflineQueryRequest_QueryContextEntry(): OfflineQueryRequest_QueryContextEntry {
  return { key: "", value: undefined };
}

export const OfflineQueryRequest_QueryContextEntry: MessageFns<OfflineQueryRequest_QueryContextEntry> = {
  encode(message: OfflineQueryRequest_QueryContextEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineQueryRequest_QueryContextEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineQueryRequest_QueryContextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineQueryRequest_QueryContextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: OfflineQueryRequest_QueryContextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseColumnMetadataList(): ColumnMetadataList {
  return { metadata: [] };
}

export const ColumnMetadataList: MessageFns<ColumnMetadataList> = {
  encode(message: ColumnMetadataList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metadata) {
      ColumnMetadataList_ColumnMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMetadataList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMetadataList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata.push(ColumnMetadataList_ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMetadataList {
    return {
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => ColumnMetadataList_ColumnMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ColumnMetadataList): unknown {
    const obj: any = {};
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => ColumnMetadataList_ColumnMetadata.toJSON(e));
    }
    return obj;
  },
};

function createBaseColumnMetadataList_ColumnMetadata(): ColumnMetadataList_ColumnMetadata {
  return { featureFqn: "", columnName: "", dtype: "" };
}

export const ColumnMetadataList_ColumnMetadata: MessageFns<ColumnMetadataList_ColumnMetadata> = {
  encode(message: ColumnMetadataList_ColumnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featureFqn !== "") {
      writer.uint32(10).string(message.featureFqn);
    }
    if (message.columnName !== "") {
      writer.uint32(18).string(message.columnName);
    }
    if (message.dtype !== "") {
      writer.uint32(26).string(message.dtype);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMetadataList_ColumnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMetadataList_ColumnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureFqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columnName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dtype = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMetadataList_ColumnMetadata {
    return {
      featureFqn: isSet(object.featureFqn) ? globalThis.String(object.featureFqn) : "",
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      dtype: isSet(object.dtype) ? globalThis.String(object.dtype) : "",
    };
  },

  toJSON(message: ColumnMetadataList_ColumnMetadata): unknown {
    const obj: any = {};
    if (message.featureFqn !== "") {
      obj.featureFqn = message.featureFqn;
    }
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.dtype !== "") {
      obj.dtype = message.dtype;
    }
    return obj;
  },
};

function createBaseGetOfflineQueryJobResponse(): GetOfflineQueryJobResponse {
  return { isFinished: false, version: 0, urls: [], errors: [], columns: undefined };
}

export const GetOfflineQueryJobResponse: MessageFns<GetOfflineQueryJobResponse> = {
  encode(message: GetOfflineQueryJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isFinished !== false) {
      writer.uint32(8).bool(message.isFinished);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    for (const v of message.urls) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.errors) {
      ChalkError.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.columns !== undefined) {
      ColumnMetadataList.encode(message.columns, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOfflineQueryJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOfflineQueryJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isFinished = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errors.push(ChalkError.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.columns = ColumnMetadataList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOfflineQueryJobResponse {
    return {
      isFinished: isSet(object.isFinished) ? globalThis.Boolean(object.isFinished) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      urls: globalThis.Array.isArray(object?.urls) ? object.urls.map((e: any) => globalThis.String(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ChalkError.fromJSON(e)) : [],
      columns: isSet(object.columns) ? ColumnMetadataList.fromJSON(object.columns) : undefined,
    };
  },

  toJSON(message: GetOfflineQueryJobResponse): unknown {
    const obj: any = {};
    if (message.isFinished !== false) {
      obj.isFinished = message.isFinished;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.urls?.length) {
      obj.urls = message.urls;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ChalkError.toJSON(e));
    }
    if (message.columns !== undefined) {
      obj.columns = ColumnMetadataList.toJSON(message.columns);
    }
    return obj;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
