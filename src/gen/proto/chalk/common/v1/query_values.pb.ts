// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/common/v1/query_values.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp.pb";
import { QueryLogFilters } from "./query_log.pb";

export const protobufPackage = "chalk.common.v1";

/** @deprecated */
export interface OperationIdTableIdentifier {
  /**
   * If you want the results for a particular operation id, no need to look up the value tables separately.
   * The engine will do that for you
   */
  operationId: string;
}

/** @deprecated */
export interface TableNameTableIdentifier {
  tableName: string;
  /** Optionally, you can filter. Specifying any filters will result in a join against the query log table. */
  filters: QueryLogFilters | undefined;
}

/**
 * Internal protobuf representing a next page token. Contains the operation id and the query timestamp for the last row in the pervious batch. Results are sorted query timestamp
 * then by operation id lexagraphically then by row id, so this is all we need to know where the next page begins
 *
 * @deprecated
 */
export interface GetQueryValuesPageToken {
  queryTimestampHwm: Date | undefined;
  operationIdHwm: string;
  rowIdHwm: number;
}

/** @deprecated */
export interface GetQueryValuesRequest {
  /**
   * Forcing the client to specify the table name can be a bit narly. Instead, for use case 1), it can be easier to allow the client to specify the operation id,
   * and the engine can figure out what table to query.
   */
  operationIdIdentifier?:
    | OperationIdTableIdentifier
    | undefined;
  /** For use case 2, you have to specify which table name to look up, if you want to query across multiple queries */
  tableNameIdentifier?:
    | TableNameTableIdentifier
    | undefined;
  /**
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   * This is always required.
   * If you know the operation id, then its feasible that you know the exact query timestamp, too.
   */
  queryTimestampLowerBoundInclusive:
    | Date
    | undefined;
  /** If the upper bound is ommitted, then the lower bound will be used as an exact (equality) filter */
  queryTimestampUpperBoundExclusive?:
    | Date
    | undefined;
  /**
   * If you're insterested in a subset of features, specify those here. Other columns won't be selected from the database, which will help reduce query costs.
   * If empty, all features will be returned
   */
  features: string[];
  /** The (maximum) page size for results. If zero, then the server picks. */
  pageSize: number;
  /**
   * When dealing with paginated responses, specify the next token to resume where you left off. The subsequent request must be identicial to the original (except for the value of the next_token)
   * Leave empty if querying for the zeroth page.
   */
  pageToken: string;
}

/** @deprecated */
export interface GetQueryValuesResponse {
  /** If non-empty, call this endpoint again, with this next token to get the next page of responses. */
  nextPageToken: string;
  parquet?: Uint8Array | undefined;
}

function createBaseOperationIdTableIdentifier(): OperationIdTableIdentifier {
  return { operationId: "" };
}

export const OperationIdTableIdentifier: MessageFns<OperationIdTableIdentifier> = {
  encode(message: OperationIdTableIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationId !== "") {
      writer.uint32(10).string(message.operationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationIdTableIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationIdTableIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationIdTableIdentifier {
    return { operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "" };
  },

  toJSON(message: OperationIdTableIdentifier): unknown {
    const obj: any = {};
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    return obj;
  },
};

function createBaseTableNameTableIdentifier(): TableNameTableIdentifier {
  return { tableName: "", filters: undefined };
}

export const TableNameTableIdentifier: MessageFns<TableNameTableIdentifier> = {
  encode(message: TableNameTableIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.filters !== undefined) {
      QueryLogFilters.encode(message.filters, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableNameTableIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableNameTableIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filters = QueryLogFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableNameTableIdentifier {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      filters: isSet(object.filters) ? QueryLogFilters.fromJSON(object.filters) : undefined,
    };
  },

  toJSON(message: TableNameTableIdentifier): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.filters !== undefined) {
      obj.filters = QueryLogFilters.toJSON(message.filters);
    }
    return obj;
  },
};

function createBaseGetQueryValuesPageToken(): GetQueryValuesPageToken {
  return { queryTimestampHwm: undefined, operationIdHwm: "", rowIdHwm: 0 };
}

export const GetQueryValuesPageToken: MessageFns<GetQueryValuesPageToken> = {
  encode(message: GetQueryValuesPageToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryTimestampHwm !== undefined) {
      Timestamp.encode(toTimestamp(message.queryTimestampHwm), writer.uint32(10).fork()).join();
    }
    if (message.operationIdHwm !== "") {
      writer.uint32(18).string(message.operationIdHwm);
    }
    if (message.rowIdHwm !== 0) {
      writer.uint32(24).int64(message.rowIdHwm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryValuesPageToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryValuesPageToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryTimestampHwm = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operationIdHwm = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowIdHwm = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryValuesPageToken {
    return {
      queryTimestampHwm: isSet(object.queryTimestampHwm) ? fromJsonTimestamp(object.queryTimestampHwm) : undefined,
      operationIdHwm: isSet(object.operationIdHwm) ? globalThis.String(object.operationIdHwm) : "",
      rowIdHwm: isSet(object.rowIdHwm) ? globalThis.Number(object.rowIdHwm) : 0,
    };
  },

  toJSON(message: GetQueryValuesPageToken): unknown {
    const obj: any = {};
    if (message.queryTimestampHwm !== undefined) {
      obj.queryTimestampHwm = message.queryTimestampHwm.toISOString();
    }
    if (message.operationIdHwm !== "") {
      obj.operationIdHwm = message.operationIdHwm;
    }
    if (message.rowIdHwm !== 0) {
      obj.rowIdHwm = Math.round(message.rowIdHwm);
    }
    return obj;
  },
};

function createBaseGetQueryValuesRequest(): GetQueryValuesRequest {
  return {
    operationIdIdentifier: undefined,
    tableNameIdentifier: undefined,
    queryTimestampLowerBoundInclusive: undefined,
    queryTimestampUpperBoundExclusive: undefined,
    features: [],
    pageSize: 0,
    pageToken: "",
  };
}

export const GetQueryValuesRequest: MessageFns<GetQueryValuesRequest> = {
  encode(message: GetQueryValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationIdIdentifier !== undefined) {
      OperationIdTableIdentifier.encode(message.operationIdIdentifier, writer.uint32(10).fork()).join();
    }
    if (message.tableNameIdentifier !== undefined) {
      TableNameTableIdentifier.encode(message.tableNameIdentifier, writer.uint32(18).fork()).join();
    }
    if (message.queryTimestampLowerBoundInclusive !== undefined) {
      Timestamp.encode(toTimestamp(message.queryTimestampLowerBoundInclusive), writer.uint32(26).fork()).join();
    }
    if (message.queryTimestampUpperBoundExclusive !== undefined) {
      Timestamp.encode(toTimestamp(message.queryTimestampUpperBoundExclusive), writer.uint32(34).fork()).join();
    }
    for (const v of message.features) {
      writer.uint32(42).string(v!);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(66).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationIdIdentifier = OperationIdTableIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tableNameIdentifier = TableNameTableIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queryTimestampLowerBoundInclusive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.queryTimestampUpperBoundExclusive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.features.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryValuesRequest {
    return {
      operationIdIdentifier: isSet(object.operationIdIdentifier)
        ? OperationIdTableIdentifier.fromJSON(object.operationIdIdentifier)
        : undefined,
      tableNameIdentifier: isSet(object.tableNameIdentifier)
        ? TableNameTableIdentifier.fromJSON(object.tableNameIdentifier)
        : undefined,
      queryTimestampLowerBoundInclusive: isSet(object.queryTimestampLowerBoundInclusive)
        ? fromJsonTimestamp(object.queryTimestampLowerBoundInclusive)
        : undefined,
      queryTimestampUpperBoundExclusive: isSet(object.queryTimestampUpperBoundExclusive)
        ? fromJsonTimestamp(object.queryTimestampUpperBoundExclusive)
        : undefined,
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => globalThis.String(e))
        : [],
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetQueryValuesRequest): unknown {
    const obj: any = {};
    if (message.operationIdIdentifier !== undefined) {
      obj.operationIdIdentifier = OperationIdTableIdentifier.toJSON(message.operationIdIdentifier);
    }
    if (message.tableNameIdentifier !== undefined) {
      obj.tableNameIdentifier = TableNameTableIdentifier.toJSON(message.tableNameIdentifier);
    }
    if (message.queryTimestampLowerBoundInclusive !== undefined) {
      obj.queryTimestampLowerBoundInclusive = message.queryTimestampLowerBoundInclusive.toISOString();
    }
    if (message.queryTimestampUpperBoundExclusive !== undefined) {
      obj.queryTimestampUpperBoundExclusive = message.queryTimestampUpperBoundExclusive.toISOString();
    }
    if (message.features?.length) {
      obj.features = message.features;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },
};

function createBaseGetQueryValuesResponse(): GetQueryValuesResponse {
  return { nextPageToken: "", parquet: undefined };
}

export const GetQueryValuesResponse: MessageFns<GetQueryValuesResponse> = {
  encode(message: GetQueryValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextPageToken !== "") {
      writer.uint32(10).string(message.nextPageToken);
    }
    if (message.parquet !== undefined) {
      writer.uint32(18).bytes(message.parquet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueryValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueryValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parquet = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueryValuesResponse {
    return {
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      parquet: isSet(object.parquet) ? bytesFromBase64(object.parquet) : undefined,
    };
  },

  toJSON(message: GetQueryValuesResponse): unknown {
    const obj: any = {};
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.parquet !== undefined) {
      obj.parquet = base64FromBytes(message.parquet);
    }
    return obj;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
