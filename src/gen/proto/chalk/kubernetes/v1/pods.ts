// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/kubernetes/v1/pods.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "chalk.kubernetes.v1";

/** PodStatusPubSub captures the state of a kubernetes pod. */
export interface KubernetesPodData {
  /** The Chalk team name that incurred the usage. */
  team: string;
  app: string;
  component: string;
  datadogService: string;
  datadogVersion: string;
  podTemplateHash: string;
  /** string status = 7; */
  status: KubernetesPodData_PodStatus | undefined;
  spec:
    | KubernetesPodData_PodSpec
    | undefined;
  /**
   * The time that the instance was created.
   * pod.CreationTimestamp.Unix()
   */
  creationTimestamp: number;
  /**
   * pod.DeletionTimestamp.Unix()
   * The time that the instance was deleted. May be 0 if the instance is still running.
   */
  deletionTimestamp: number;
  /** The time that we polled the instance for usage. */
  observedTimestamp: number;
  /** pod.Labels */
  labels: { [key: string]: string };
  /** pod.Annotations */
  annotations: { [key: string]: string };
  cluster: string;
  /** // node.UID */
  uid: string;
  /** // node.Name */
  name: string;
  namespace: string;
}

/** Volume represents a named volume in a pod that may be accessed by any container in the pod. */
export interface KubernetesPodData_Volume {
  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name: string;
}

/**
 * ClaimSource describes a reference to a ResourceClaim.
 *
 * Exactly one of these fields should be set.  Consumers of this type must
 * treat an empty object as if it has an unknown value.
 */
export interface KubernetesPodData_ClaimSource {
  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   */
  resourceClaimName?:
    | string
    | undefined;
  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   */
  resourceClaimTemplateName?: string | undefined;
}

/**
 * PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 */
export interface KubernetesPodData_PodResourceClaim {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   */
  name: string;
  /** Source describes where to find the ResourceClaim. */
  source?: KubernetesPodData_ClaimSource | undefined;
}

/** PodSpec is a description of a pod. */
export interface KubernetesPodData_PodSpec {
  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge,retainKeys
   * +listType=map
   * +listMapKey=name
   */
  volumes: KubernetesPodData_Volume[];
  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   * +patchMergeKey=name
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=name
   */
  initContainers: KubernetesPodData_Container[];
  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   * +patchMergeKey=name
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=name
   */
  containers: KubernetesPodData_Container[];
  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   * +optional
   */
  restartPolicy?:
    | string
    | undefined;
  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   * +optional
   */
  terminationGracePeriodSeconds?:
    | number
    | undefined;
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * start_time before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   * +optional
   */
  activeDeadlineSeconds?:
    | number
    | undefined;
  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   * +optional
   */
  dnsPolicy?:
    | string
    | undefined;
  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   * +optional
   * +mapType=atomic
   */
  nodeSelector: { [key: string]: string };
  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   * +optional
   */
  serviceAccountName?:
    | string
    | undefined;
  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   * +optional
   */
  automountServiceAccountToken?:
    | boolean
    | undefined;
  /**
   * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
   * the scheduler simply schedules this pod onto that node, assuming that it fits resource
   * requirements.
   * +optional
   */
  nodeName?:
    | string
    | undefined;
  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostNetwork: boolean;
  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostPid: boolean;
  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostIpc: boolean;
  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  shareProcessNamespace: boolean;
  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   * +optional
   */
  hostname?:
    | string
    | undefined;
  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   * +optional
   */
  subdomain?:
    | string
    | undefined;
  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   * +optional
   */
  schedulerName?:
    | string
    | undefined;
  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   * +optional
   */
  priorityClassName?:
    | string
    | undefined;
  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from priority_class_name.
   * The higher the value, the higher the priority.
   * +optional
   */
  priority?:
    | number
    | undefined;
  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   * +optional
   */
  runtimeClassName?:
    | string
    | undefined;
  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   * +optional
   */
  enableServiceLinks?:
    | boolean
    | undefined;
  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   * +optional
   */
  preemptionPolicy?:
    | string
    | undefined;
  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostUsers?:
    | boolean
    | undefined;
  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * +patchMergeKey=name
   * +patchStrategy=merge,retainKeys
   * +listType=map
   * +listMapKey=name
   * +featureGate=DynamicResourceAllocation
   * +optional
   */
  resourceClaims: KubernetesPodData_PodResourceClaim[];
}

export interface KubernetesPodData_PodSpec_NodeSelectorEntry {
  key: string;
  value: string;
}

/**
 * ContainerState holds a possible state of container.
 * Only one of its members may be specified.
 * If none of them is specified, the default one is ContainerStateWaiting.
 */
export interface KubernetesPodData_ContainerState {
  /**
   * Details about a waiting container
   * +optional
   */
  waiting?:
    | KubernetesPodData_ContainerStateWaiting
    | undefined;
  /**
   * Details about a running container
   * +optional
   */
  running?:
    | KubernetesPodData_ContainerStateRunning
    | undefined;
  /**
   * Details about a terminated container
   * +optional
   */
  terminated?: KubernetesPodData_ContainerStateTerminated | undefined;
}

/** ContainerStateRunning is a running state of a container. */
export interface KubernetesPodData_ContainerStateRunning {
  /**
   * Time at which the container was last (re-)started
   * +optional
   */
  startedAt: number;
}

/** ContainerStateTerminated is a terminated state of a container. */
export interface KubernetesPodData_ContainerStateTerminated {
  /** Exit status from the last termination of the container */
  exitCode: number;
  /**
   * Signal from the last termination of the container
   * +optional
   */
  signal?:
    | number
    | undefined;
  /**
   * (brief) reason from the last termination of the container
   * +optional
   */
  reason?:
    | string
    | undefined;
  /**
   * Message regarding the last termination of the container
   * +optional
   */
  message?:
    | string
    | undefined;
  /**
   * Time at which previous execution of the container started
   * +optional
   */
  startedAt?:
    | number
    | undefined;
  /**
   * Time at which the container last terminated
   * +optional
   */
  finishedAt?:
    | number
    | undefined;
  /**
   * Container's ID in the format '<type>://<container_id>'
   * +optional
   */
  containerId?: string | undefined;
}

/** EnvVar represents an environment variable present in a Container. */
export interface KubernetesPodData_EnvVar {
  /** Name of the environment variable. Must be a C_IDENTIFIER. */
  name: string;
  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   */
  value: string;
}

/** A single application container that you want to run within a pod. */
export interface KubernetesPodData_Container {
  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   */
  name: string;
  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   * +optional
   */
  image?:
    | string
    | undefined;
  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   * +listType=atomic
   */
  command: string[];
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   * +listType=atomic
   */
  args: string[];
  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   */
  workingDir?:
    | string
    | undefined;
  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=name
   */
  env: KubernetesPodData_EnvVar[];
  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   */
  resources?:
    | KubernetesPodData_ResourceRequirements
    | undefined;
  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   * +featureGate=SidecarContainers
   * +optional
   */
  restartPolicy?:
    | string
    | undefined;
  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   */
  terminationMessagePath?:
    | string
    | undefined;
  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   */
  terminationMessagePolicy?:
    | string
    | undefined;
  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   */
  imagePullPolicy?:
    | string
    | undefined;
  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   */
  stdin: boolean;
  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   */
  stdinOnce: boolean;
  /** Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. */
  tty: boolean;
}

/** ContainerStateWaiting is a waiting state of a container. */
export interface KubernetesPodData_ContainerStateWaiting {
  /**
   * (brief) reason the container is not yet running.
   * +optional
   */
  reason?:
    | string
    | undefined;
  /**
   * Message regarding why the container is not yet running.
   * +optional
   */
  message?: string | undefined;
}

/** ContainerStatus contains details for the current status of this container. */
export interface KubernetesPodData_ContainerStatus {
  /**
   * Name is a DNS_LABEL representing the unique name of the container.
   * Each container in a pod must have a unique name across all container types.
   * Cannot be updated.
   */
  name: string;
  /**
   * State holds details about the container's current condition.
   * +optional
   */
  state?:
    | KubernetesPodData_ContainerState
    | undefined;
  /**
   * LastTerminationState holds the last termination state of the container to
   * help debug container crashes and restarts. This field is not
   * populated if the container is still running and RestartCount is 0.
   * +optional
   */
  lastState?:
    | KubernetesPodData_ContainerState
    | undefined;
  /**
   * Ready specifies whether the container is currently passing its readiness check.
   * The value will change as readiness probes keep executing. If no readiness
   * probes are specified, this field defaults to true once the container is
   * fully started (see Started field).
   *
   * The value is typically used to determine whether a container is ready to
   * accept traffic.
   */
  ready?:
    | boolean
    | undefined;
  /**
   * RestartCount holds the number of times the container has been restarted.
   * Kubelet makes an effort to always increment the value, but there
   * are cases when the state may be lost due to node restarts and then the value
   * may be reset to 0. The value is never negative.
   */
  restartCount: number;
  /**
   * Image is the name of container image that the container is running.
   * The container image may not match the image used in the PodSpec,
   * as it may have been resolved by the runtime.
   * More info: https://kubernetes.io/docs/concepts/containers/images.
   */
  image: string;
  /**
   * ImageID is the image ID of the container's image. The image ID may not
   * match the image ID of the image used in the PodSpec, as it may have been
   * resolved by the runtime.
   */
  imageId: string;
  /**
   * ContainerID is the ID of the container in the format '<type>://<container_id>'.
   * Where type is a container runtime identifier, returned from Version call of CRI API
   * (for example "containerd").
   * +optional
   */
  containerId: string;
  /**
   * Started indicates whether the container has finished its postStart lifecycle hook
   * and passed its startup probe.
   * Initialized as false, becomes true after startupProbe is considered
   * successful. Resets to false when the container is restarted, or if kubelet
   * loses state temporarily. In both cases, startup probes will run again.
   * Is always true when no startupProbe is defined and container is running and
   * has passed the postStart lifecycle hook.
   */
  started: boolean;
}

export interface KubernetesPodData_Quantity {
  string?: string | undefined;
}

export interface KubernetesPodData_ResourceRequirements {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   */
  limits: { [key: string]: KubernetesPodData_Quantity };
  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   */
  requests: { [key: string]: KubernetesPodData_Quantity };
}

export interface KubernetesPodData_ResourceRequirements_LimitsEntry {
  key: string;
  value: KubernetesPodData_Quantity | undefined;
}

export interface KubernetesPodData_ResourceRequirements_RequestsEntry {
  key: string;
  value: KubernetesPodData_Quantity | undefined;
}

/** PodCondition contains details for the current condition of this pod. */
export interface KubernetesPodData_PodCondition {
  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   */
  type: string;
  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   */
  status: string;
  /**
   * Last time we probed the condition.
   * +optional
   */
  lastProbeTime: number;
  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime: number;
  /**
   * Unique, one-word, CamelCase reason for the condition's last transition.
   * +optional
   */
  reason?:
    | string
    | undefined;
  /**
   * Human-readable message indicating details about last transition.
   * +optional
   */
  message?: string | undefined;
}

/** HostIP represents a single IP address allocated to the host. */
export interface KubernetesPodData_HostIP {
  /** IP is the IP address assigned to the host */
  ip?: string | undefined;
}

/**
 * PodStatus represents information about the status of a pod. Status may trail the actual
 * state of a system, especially if the node that hosts the pod cannot contact the control
 * plane.
 */
export interface KubernetesPodData_PodStatus {
  /**
   * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
   * The conditions array, the reason and message fields, and the individual container status
   * arrays contain more detail about the pod's status.
   * There are five possible phase values:
   *
   * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
   * container images has not been created. This includes time before being scheduled as
   * well as time spent downloading images over the network, which could take a while.
   * Running: The pod has been bound to a node, and all of the containers have been created.
   * At least one container is still running, or is in the process of starting or restarting.
   * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
   * Failed: All containers in the pod have terminated, and at least one container has
   * terminated in failure. The container either exited with non-zero status or was terminated
   * by the system.
   * Unknown: For some reason the state of the pod could not be obtained, typically due to an
   * error in communicating with the host of the pod.
   *
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
   * +optional
   */
  phase?:
    | string
    | undefined;
  /**
   * Current service state of pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=type
   */
  conditions: KubernetesPodData_PodCondition[];
  /**
   * A human readable message indicating details about why the pod is in this condition.
   * +optional
   */
  message?:
    | string
    | undefined;
  /**
   * A brief CamelCase message indicating details about why the pod is in this state.
   * e.g. 'Evicted'
   * +optional
   */
  reason?:
    | string
    | undefined;
  /**
   * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
   * scheduled right away as preemption victims receive their graceful termination periods.
   * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
   * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
   * give the resources on this node to a higher priority pod that is created after preemption.
   * As a result, this field may be different than PodSpec.nodeName when the pod is
   * scheduled.
   * +optional
   */
  nominatedNodeName?:
    | string
    | undefined;
  /**
   * hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
   * A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
   * not be updated even if there is a node is assigned to pod
   * +optional
   */
  hostIp?:
    | string
    | undefined;
  /**
   * hostIPs holds the IP addresses allocated to the host. If this field is specified, the first entry must
   * match the hostIP field. This list is empty if the pod has not started yet.
   * A pod can be assigned to a node that has a problem in kubelet which in turns means that HostIPs will
   * not be updated even if there is a node is assigned to this pod.
   * +optional
   * +patchStrategy=merge
   * +patchMergeKey=ip
   * +listType=atomic
   */
  hostIps: KubernetesPodData_HostIP[];
  /**
   * podIP address allocated to the pod. Routable at least within the cluster.
   * Empty if not yet allocated.
   * +optional
   */
  podIp?:
    | string
    | undefined;
  /**
   * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
   * This is before the Kubelet pulled the container image(s) for the pod.
   * +optional
   */
  startTime?:
    | number
    | undefined;
  /**
   * The list has one entry per init container in the manifest. The most recent successful
   * init container will have ready = true, the most recently started container will have
   * startTime set.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   * +listType=atomic
   */
  initContainerStatuses: KubernetesPodData_ContainerStatus[];
  /**
   * The list has one entry per container in the manifest.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   * +optional
   * +listType=atomic
   */
  containerStatuses: KubernetesPodData_ContainerStatus[];
  /**
   * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
   * See PodQOSClass type for available QOS classes
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
   * +optional
   */
  qosClass?:
    | string
    | undefined;
  /**
   * Status for any ephemeral containers that have run in this pod.
   * +optional
   * +listType=atomic
   */
  ephemeralContainerStatuses: KubernetesPodData_ContainerStatus[];
  /**
   * Status of resources resize desired for pod's containers.
   * It is empty if no resources resize is pending.
   * Any changes to container resources will automatically set this to "Proposed"
   * +featureGate=InPlacePodVerticalScaling
   * +optional
   */
  resize?: string | undefined;
}

export interface KubernetesPodData_LabelsEntry {
  key: string;
  value: string;
}

export interface KubernetesPodData_AnnotationsEntry {
  key: string;
  value: string;
}

function createBaseKubernetesPodData(): KubernetesPodData {
  return {
    team: "",
    app: "",
    component: "",
    datadogService: "",
    datadogVersion: "",
    podTemplateHash: "",
    status: undefined,
    spec: undefined,
    creationTimestamp: 0,
    deletionTimestamp: 0,
    observedTimestamp: 0,
    labels: {},
    annotations: {},
    cluster: "",
    uid: "",
    name: "",
    namespace: "",
  };
}

export const KubernetesPodData: MessageFns<KubernetesPodData> = {
  encode(message: KubernetesPodData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.team !== "") {
      writer.uint32(10).string(message.team);
    }
    if (message.app !== "") {
      writer.uint32(18).string(message.app);
    }
    if (message.component !== "") {
      writer.uint32(26).string(message.component);
    }
    if (message.datadogService !== "") {
      writer.uint32(34).string(message.datadogService);
    }
    if (message.datadogVersion !== "") {
      writer.uint32(42).string(message.datadogVersion);
    }
    if (message.podTemplateHash !== "") {
      writer.uint32(50).string(message.podTemplateHash);
    }
    if (message.status !== undefined) {
      KubernetesPodData_PodStatus.encode(message.status, writer.uint32(58).fork()).join();
    }
    if (message.spec !== undefined) {
      KubernetesPodData_PodSpec.encode(message.spec, writer.uint32(66).fork()).join();
    }
    if (message.creationTimestamp !== 0) {
      writer.uint32(144).int64(message.creationTimestamp);
    }
    if (message.deletionTimestamp !== 0) {
      writer.uint32(152).int64(message.deletionTimestamp);
    }
    if (message.observedTimestamp !== 0) {
      writer.uint32(160).int64(message.observedTimestamp);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      KubernetesPodData_LabelsEntry.encode({ key: key as any, value }, writer.uint32(170).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      KubernetesPodData_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    if (message.cluster !== "") {
      writer.uint32(186).string(message.cluster);
    }
    if (message.uid !== "") {
      writer.uint32(194).string(message.uid);
    }
    if (message.name !== "") {
      writer.uint32(202).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(210).string(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.team = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.app = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.component = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.datadogService = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.datadogVersion = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.podTemplateHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = KubernetesPodData_PodStatus.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.spec = KubernetesPodData_PodSpec.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.creationTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.deletionTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.observedTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          const entry21 = KubernetesPodData_LabelsEntry.decode(reader, reader.uint32());
          if (entry21.value !== undefined) {
            message.labels[entry21.key] = entry21.value;
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          const entry22 = KubernetesPodData_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.annotations[entry22.key] = entry22.value;
          }
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData {
    return {
      team: isSet(object.team) ? globalThis.String(object.team) : "",
      app: isSet(object.app) ? globalThis.String(object.app) : "",
      component: isSet(object.component) ? globalThis.String(object.component) : "",
      datadogService: isSet(object.datadogService) ? globalThis.String(object.datadogService) : "",
      datadogVersion: isSet(object.datadogVersion) ? globalThis.String(object.datadogVersion) : "",
      podTemplateHash: isSet(object.podTemplateHash) ? globalThis.String(object.podTemplateHash) : "",
      status: isSet(object.status) ? KubernetesPodData_PodStatus.fromJSON(object.status) : undefined,
      spec: isSet(object.spec) ? KubernetesPodData_PodSpec.fromJSON(object.spec) : undefined,
      creationTimestamp: isSet(object.creationTimestamp) ? globalThis.Number(object.creationTimestamp) : 0,
      deletionTimestamp: isSet(object.deletionTimestamp) ? globalThis.Number(object.deletionTimestamp) : 0,
      observedTimestamp: isSet(object.observedTimestamp) ? globalThis.Number(object.observedTimestamp) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: KubernetesPodData): unknown {
    const obj: any = {};
    if (message.team !== "") {
      obj.team = message.team;
    }
    if (message.app !== "") {
      obj.app = message.app;
    }
    if (message.component !== "") {
      obj.component = message.component;
    }
    if (message.datadogService !== "") {
      obj.datadogService = message.datadogService;
    }
    if (message.datadogVersion !== "") {
      obj.datadogVersion = message.datadogVersion;
    }
    if (message.podTemplateHash !== "") {
      obj.podTemplateHash = message.podTemplateHash;
    }
    if (message.status !== undefined) {
      obj.status = KubernetesPodData_PodStatus.toJSON(message.status);
    }
    if (message.spec !== undefined) {
      obj.spec = KubernetesPodData_PodSpec.toJSON(message.spec);
    }
    if (message.creationTimestamp !== 0) {
      obj.creationTimestamp = Math.round(message.creationTimestamp);
    }
    if (message.deletionTimestamp !== 0) {
      obj.deletionTimestamp = Math.round(message.deletionTimestamp);
    }
    if (message.observedTimestamp !== 0) {
      obj.observedTimestamp = Math.round(message.observedTimestamp);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData>, I>>(base?: I): KubernetesPodData {
    return KubernetesPodData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData>, I>>(object: I): KubernetesPodData {
    const message = createBaseKubernetesPodData();
    message.team = object.team ?? "";
    message.app = object.app ?? "";
    message.component = object.component ?? "";
    message.datadogService = object.datadogService ?? "";
    message.datadogVersion = object.datadogVersion ?? "";
    message.podTemplateHash = object.podTemplateHash ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? KubernetesPodData_PodStatus.fromPartial(object.status)
      : undefined;
    message.spec = (object.spec !== undefined && object.spec !== null)
      ? KubernetesPodData_PodSpec.fromPartial(object.spec)
      : undefined;
    message.creationTimestamp = object.creationTimestamp ?? 0;
    message.deletionTimestamp = object.deletionTimestamp ?? 0;
    message.observedTimestamp = object.observedTimestamp ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.cluster = object.cluster ?? "";
    message.uid = object.uid ?? "";
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseKubernetesPodData_Volume(): KubernetesPodData_Volume {
  return { name: "" };
}

export const KubernetesPodData_Volume: MessageFns<KubernetesPodData_Volume> = {
  encode(message: KubernetesPodData_Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_Volume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_Volume {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: KubernetesPodData_Volume): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_Volume>, I>>(base?: I): KubernetesPodData_Volume {
    return KubernetesPodData_Volume.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_Volume>, I>>(object: I): KubernetesPodData_Volume {
    const message = createBaseKubernetesPodData_Volume();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseKubernetesPodData_ClaimSource(): KubernetesPodData_ClaimSource {
  return { resourceClaimName: undefined, resourceClaimTemplateName: undefined };
}

export const KubernetesPodData_ClaimSource: MessageFns<KubernetesPodData_ClaimSource> = {
  encode(message: KubernetesPodData_ClaimSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceClaimName !== undefined) {
      writer.uint32(10).string(message.resourceClaimName);
    }
    if (message.resourceClaimTemplateName !== undefined) {
      writer.uint32(18).string(message.resourceClaimTemplateName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ClaimSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ClaimSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceClaimName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceClaimTemplateName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ClaimSource {
    return {
      resourceClaimName: isSet(object.resourceClaimName) ? globalThis.String(object.resourceClaimName) : undefined,
      resourceClaimTemplateName: isSet(object.resourceClaimTemplateName)
        ? globalThis.String(object.resourceClaimTemplateName)
        : undefined,
    };
  },

  toJSON(message: KubernetesPodData_ClaimSource): unknown {
    const obj: any = {};
    if (message.resourceClaimName !== undefined) {
      obj.resourceClaimName = message.resourceClaimName;
    }
    if (message.resourceClaimTemplateName !== undefined) {
      obj.resourceClaimTemplateName = message.resourceClaimTemplateName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ClaimSource>, I>>(base?: I): KubernetesPodData_ClaimSource {
    return KubernetesPodData_ClaimSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ClaimSource>, I>>(
    object: I,
  ): KubernetesPodData_ClaimSource {
    const message = createBaseKubernetesPodData_ClaimSource();
    message.resourceClaimName = object.resourceClaimName ?? undefined;
    message.resourceClaimTemplateName = object.resourceClaimTemplateName ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_PodResourceClaim(): KubernetesPodData_PodResourceClaim {
  return { name: "", source: undefined };
}

export const KubernetesPodData_PodResourceClaim: MessageFns<KubernetesPodData_PodResourceClaim> = {
  encode(message: KubernetesPodData_PodResourceClaim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.source !== undefined) {
      KubernetesPodData_ClaimSource.encode(message.source, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_PodResourceClaim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_PodResourceClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = KubernetesPodData_ClaimSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_PodResourceClaim {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      source: isSet(object.source) ? KubernetesPodData_ClaimSource.fromJSON(object.source) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_PodResourceClaim): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.source !== undefined) {
      obj.source = KubernetesPodData_ClaimSource.toJSON(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_PodResourceClaim>, I>>(
    base?: I,
  ): KubernetesPodData_PodResourceClaim {
    return KubernetesPodData_PodResourceClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_PodResourceClaim>, I>>(
    object: I,
  ): KubernetesPodData_PodResourceClaim {
    const message = createBaseKubernetesPodData_PodResourceClaim();
    message.name = object.name ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? KubernetesPodData_ClaimSource.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBaseKubernetesPodData_PodSpec(): KubernetesPodData_PodSpec {
  return {
    volumes: [],
    initContainers: [],
    containers: [],
    restartPolicy: undefined,
    terminationGracePeriodSeconds: undefined,
    activeDeadlineSeconds: undefined,
    dnsPolicy: undefined,
    nodeSelector: {},
    serviceAccountName: undefined,
    automountServiceAccountToken: undefined,
    nodeName: undefined,
    hostNetwork: false,
    hostPid: false,
    hostIpc: false,
    shareProcessNamespace: false,
    hostname: undefined,
    subdomain: undefined,
    schedulerName: undefined,
    priorityClassName: undefined,
    priority: undefined,
    runtimeClassName: undefined,
    enableServiceLinks: undefined,
    preemptionPolicy: undefined,
    hostUsers: undefined,
    resourceClaims: [],
  };
}

export const KubernetesPodData_PodSpec: MessageFns<KubernetesPodData_PodSpec> = {
  encode(message: KubernetesPodData_PodSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.volumes) {
      KubernetesPodData_Volume.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.initContainers) {
      KubernetesPodData_Container.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.containers) {
      KubernetesPodData_Container.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.restartPolicy !== undefined) {
      writer.uint32(26).string(message.restartPolicy);
    }
    if (message.terminationGracePeriodSeconds !== undefined) {
      writer.uint32(32).int64(message.terminationGracePeriodSeconds);
    }
    if (message.activeDeadlineSeconds !== undefined) {
      writer.uint32(40).int64(message.activeDeadlineSeconds);
    }
    if (message.dnsPolicy !== undefined) {
      writer.uint32(50).string(message.dnsPolicy);
    }
    Object.entries(message.nodeSelector).forEach(([key, value]) => {
      KubernetesPodData_PodSpec_NodeSelectorEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.serviceAccountName !== undefined) {
      writer.uint32(66).string(message.serviceAccountName);
    }
    if (message.automountServiceAccountToken !== undefined) {
      writer.uint32(168).bool(message.automountServiceAccountToken);
    }
    if (message.nodeName !== undefined) {
      writer.uint32(82).string(message.nodeName);
    }
    if (message.hostNetwork !== false) {
      writer.uint32(88).bool(message.hostNetwork);
    }
    if (message.hostPid !== false) {
      writer.uint32(96).bool(message.hostPid);
    }
    if (message.hostIpc !== false) {
      writer.uint32(104).bool(message.hostIpc);
    }
    if (message.shareProcessNamespace !== false) {
      writer.uint32(216).bool(message.shareProcessNamespace);
    }
    if (message.hostname !== undefined) {
      writer.uint32(130).string(message.hostname);
    }
    if (message.subdomain !== undefined) {
      writer.uint32(138).string(message.subdomain);
    }
    if (message.schedulerName !== undefined) {
      writer.uint32(154).string(message.schedulerName);
    }
    if (message.priorityClassName !== undefined) {
      writer.uint32(194).string(message.priorityClassName);
    }
    if (message.priority !== undefined) {
      writer.uint32(200).int32(message.priority);
    }
    if (message.runtimeClassName !== undefined) {
      writer.uint32(234).string(message.runtimeClassName);
    }
    if (message.enableServiceLinks !== undefined) {
      writer.uint32(240).bool(message.enableServiceLinks);
    }
    if (message.preemptionPolicy !== undefined) {
      writer.uint32(250).string(message.preemptionPolicy);
    }
    if (message.hostUsers !== undefined) {
      writer.uint32(296).bool(message.hostUsers);
    }
    for (const v of message.resourceClaims) {
      KubernetesPodData_PodResourceClaim.encode(v!, writer.uint32(314).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_PodSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_PodSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.volumes.push(KubernetesPodData_Volume.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.initContainers.push(KubernetesPodData_Container.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.containers.push(KubernetesPodData_Container.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.restartPolicy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.terminationGracePeriodSeconds = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.activeDeadlineSeconds = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dnsPolicy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = KubernetesPodData_PodSpec_NodeSelectorEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.nodeSelector[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.serviceAccountName = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.automountServiceAccountToken = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.hostNetwork = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hostPid = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.hostIpc = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.shareProcessNamespace = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.subdomain = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.schedulerName = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.priorityClassName = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.runtimeClassName = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.enableServiceLinks = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.preemptionPolicy = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.hostUsers = reader.bool();
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.resourceClaims.push(KubernetesPodData_PodResourceClaim.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_PodSpec {
    return {
      volumes: globalThis.Array.isArray(object?.volumes)
        ? object.volumes.map((e: any) => KubernetesPodData_Volume.fromJSON(e))
        : [],
      initContainers: globalThis.Array.isArray(object?.initContainers)
        ? object.initContainers.map((e: any) => KubernetesPodData_Container.fromJSON(e))
        : [],
      containers: globalThis.Array.isArray(object?.containers)
        ? object.containers.map((e: any) => KubernetesPodData_Container.fromJSON(e))
        : [],
      restartPolicy: isSet(object.restartPolicy) ? globalThis.String(object.restartPolicy) : undefined,
      terminationGracePeriodSeconds: isSet(object.terminationGracePeriodSeconds)
        ? globalThis.Number(object.terminationGracePeriodSeconds)
        : undefined,
      activeDeadlineSeconds: isSet(object.activeDeadlineSeconds)
        ? globalThis.Number(object.activeDeadlineSeconds)
        : undefined,
      dnsPolicy: isSet(object.dnsPolicy) ? globalThis.String(object.dnsPolicy) : undefined,
      nodeSelector: isObject(object.nodeSelector)
        ? Object.entries(object.nodeSelector).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      serviceAccountName: isSet(object.serviceAccountName) ? globalThis.String(object.serviceAccountName) : undefined,
      automountServiceAccountToken: isSet(object.automountServiceAccountToken)
        ? globalThis.Boolean(object.automountServiceAccountToken)
        : undefined,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : undefined,
      hostNetwork: isSet(object.hostNetwork) ? globalThis.Boolean(object.hostNetwork) : false,
      hostPid: isSet(object.hostPid) ? globalThis.Boolean(object.hostPid) : false,
      hostIpc: isSet(object.hostIpc) ? globalThis.Boolean(object.hostIpc) : false,
      shareProcessNamespace: isSet(object.shareProcessNamespace)
        ? globalThis.Boolean(object.shareProcessNamespace)
        : false,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      subdomain: isSet(object.subdomain) ? globalThis.String(object.subdomain) : undefined,
      schedulerName: isSet(object.schedulerName) ? globalThis.String(object.schedulerName) : undefined,
      priorityClassName: isSet(object.priorityClassName) ? globalThis.String(object.priorityClassName) : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
      runtimeClassName: isSet(object.runtimeClassName) ? globalThis.String(object.runtimeClassName) : undefined,
      enableServiceLinks: isSet(object.enableServiceLinks) ? globalThis.Boolean(object.enableServiceLinks) : undefined,
      preemptionPolicy: isSet(object.preemptionPolicy) ? globalThis.String(object.preemptionPolicy) : undefined,
      hostUsers: isSet(object.hostUsers) ? globalThis.Boolean(object.hostUsers) : undefined,
      resourceClaims: globalThis.Array.isArray(object?.resourceClaims)
        ? object.resourceClaims.map((e: any) => KubernetesPodData_PodResourceClaim.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KubernetesPodData_PodSpec): unknown {
    const obj: any = {};
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => KubernetesPodData_Volume.toJSON(e));
    }
    if (message.initContainers?.length) {
      obj.initContainers = message.initContainers.map((e) => KubernetesPodData_Container.toJSON(e));
    }
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => KubernetesPodData_Container.toJSON(e));
    }
    if (message.restartPolicy !== undefined) {
      obj.restartPolicy = message.restartPolicy;
    }
    if (message.terminationGracePeriodSeconds !== undefined) {
      obj.terminationGracePeriodSeconds = Math.round(message.terminationGracePeriodSeconds);
    }
    if (message.activeDeadlineSeconds !== undefined) {
      obj.activeDeadlineSeconds = Math.round(message.activeDeadlineSeconds);
    }
    if (message.dnsPolicy !== undefined) {
      obj.dnsPolicy = message.dnsPolicy;
    }
    if (message.nodeSelector) {
      const entries = Object.entries(message.nodeSelector);
      if (entries.length > 0) {
        obj.nodeSelector = {};
        entries.forEach(([k, v]) => {
          obj.nodeSelector[k] = v;
        });
      }
    }
    if (message.serviceAccountName !== undefined) {
      obj.serviceAccountName = message.serviceAccountName;
    }
    if (message.automountServiceAccountToken !== undefined) {
      obj.automountServiceAccountToken = message.automountServiceAccountToken;
    }
    if (message.nodeName !== undefined) {
      obj.nodeName = message.nodeName;
    }
    if (message.hostNetwork !== false) {
      obj.hostNetwork = message.hostNetwork;
    }
    if (message.hostPid !== false) {
      obj.hostPid = message.hostPid;
    }
    if (message.hostIpc !== false) {
      obj.hostIpc = message.hostIpc;
    }
    if (message.shareProcessNamespace !== false) {
      obj.shareProcessNamespace = message.shareProcessNamespace;
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.subdomain !== undefined) {
      obj.subdomain = message.subdomain;
    }
    if (message.schedulerName !== undefined) {
      obj.schedulerName = message.schedulerName;
    }
    if (message.priorityClassName !== undefined) {
      obj.priorityClassName = message.priorityClassName;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    if (message.runtimeClassName !== undefined) {
      obj.runtimeClassName = message.runtimeClassName;
    }
    if (message.enableServiceLinks !== undefined) {
      obj.enableServiceLinks = message.enableServiceLinks;
    }
    if (message.preemptionPolicy !== undefined) {
      obj.preemptionPolicy = message.preemptionPolicy;
    }
    if (message.hostUsers !== undefined) {
      obj.hostUsers = message.hostUsers;
    }
    if (message.resourceClaims?.length) {
      obj.resourceClaims = message.resourceClaims.map((e) => KubernetesPodData_PodResourceClaim.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_PodSpec>, I>>(base?: I): KubernetesPodData_PodSpec {
    return KubernetesPodData_PodSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_PodSpec>, I>>(object: I): KubernetesPodData_PodSpec {
    const message = createBaseKubernetesPodData_PodSpec();
    message.volumes = object.volumes?.map((e) => KubernetesPodData_Volume.fromPartial(e)) || [];
    message.initContainers = object.initContainers?.map((e) => KubernetesPodData_Container.fromPartial(e)) || [];
    message.containers = object.containers?.map((e) => KubernetesPodData_Container.fromPartial(e)) || [];
    message.restartPolicy = object.restartPolicy ?? undefined;
    message.terminationGracePeriodSeconds = object.terminationGracePeriodSeconds ?? undefined;
    message.activeDeadlineSeconds = object.activeDeadlineSeconds ?? undefined;
    message.dnsPolicy = object.dnsPolicy ?? undefined;
    message.nodeSelector = Object.entries(object.nodeSelector ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.serviceAccountName = object.serviceAccountName ?? undefined;
    message.automountServiceAccountToken = object.automountServiceAccountToken ?? undefined;
    message.nodeName = object.nodeName ?? undefined;
    message.hostNetwork = object.hostNetwork ?? false;
    message.hostPid = object.hostPid ?? false;
    message.hostIpc = object.hostIpc ?? false;
    message.shareProcessNamespace = object.shareProcessNamespace ?? false;
    message.hostname = object.hostname ?? undefined;
    message.subdomain = object.subdomain ?? undefined;
    message.schedulerName = object.schedulerName ?? undefined;
    message.priorityClassName = object.priorityClassName ?? undefined;
    message.priority = object.priority ?? undefined;
    message.runtimeClassName = object.runtimeClassName ?? undefined;
    message.enableServiceLinks = object.enableServiceLinks ?? undefined;
    message.preemptionPolicy = object.preemptionPolicy ?? undefined;
    message.hostUsers = object.hostUsers ?? undefined;
    message.resourceClaims = object.resourceClaims?.map((e) => KubernetesPodData_PodResourceClaim.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKubernetesPodData_PodSpec_NodeSelectorEntry(): KubernetesPodData_PodSpec_NodeSelectorEntry {
  return { key: "", value: "" };
}

export const KubernetesPodData_PodSpec_NodeSelectorEntry: MessageFns<KubernetesPodData_PodSpec_NodeSelectorEntry> = {
  encode(
    message: KubernetesPodData_PodSpec_NodeSelectorEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_PodSpec_NodeSelectorEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_PodSpec_NodeSelectorEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_PodSpec_NodeSelectorEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: KubernetesPodData_PodSpec_NodeSelectorEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_PodSpec_NodeSelectorEntry>, I>>(
    base?: I,
  ): KubernetesPodData_PodSpec_NodeSelectorEntry {
    return KubernetesPodData_PodSpec_NodeSelectorEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_PodSpec_NodeSelectorEntry>, I>>(
    object: I,
  ): KubernetesPodData_PodSpec_NodeSelectorEntry {
    const message = createBaseKubernetesPodData_PodSpec_NodeSelectorEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseKubernetesPodData_ContainerState(): KubernetesPodData_ContainerState {
  return { waiting: undefined, running: undefined, terminated: undefined };
}

export const KubernetesPodData_ContainerState: MessageFns<KubernetesPodData_ContainerState> = {
  encode(message: KubernetesPodData_ContainerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.waiting !== undefined) {
      KubernetesPodData_ContainerStateWaiting.encode(message.waiting, writer.uint32(10).fork()).join();
    }
    if (message.running !== undefined) {
      KubernetesPodData_ContainerStateRunning.encode(message.running, writer.uint32(18).fork()).join();
    }
    if (message.terminated !== undefined) {
      KubernetesPodData_ContainerStateTerminated.encode(message.terminated, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ContainerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ContainerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.waiting = KubernetesPodData_ContainerStateWaiting.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.running = KubernetesPodData_ContainerStateRunning.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.terminated = KubernetesPodData_ContainerStateTerminated.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ContainerState {
    return {
      waiting: isSet(object.waiting) ? KubernetesPodData_ContainerStateWaiting.fromJSON(object.waiting) : undefined,
      running: isSet(object.running) ? KubernetesPodData_ContainerStateRunning.fromJSON(object.running) : undefined,
      terminated: isSet(object.terminated)
        ? KubernetesPodData_ContainerStateTerminated.fromJSON(object.terminated)
        : undefined,
    };
  },

  toJSON(message: KubernetesPodData_ContainerState): unknown {
    const obj: any = {};
    if (message.waiting !== undefined) {
      obj.waiting = KubernetesPodData_ContainerStateWaiting.toJSON(message.waiting);
    }
    if (message.running !== undefined) {
      obj.running = KubernetesPodData_ContainerStateRunning.toJSON(message.running);
    }
    if (message.terminated !== undefined) {
      obj.terminated = KubernetesPodData_ContainerStateTerminated.toJSON(message.terminated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ContainerState>, I>>(
    base?: I,
  ): KubernetesPodData_ContainerState {
    return KubernetesPodData_ContainerState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ContainerState>, I>>(
    object: I,
  ): KubernetesPodData_ContainerState {
    const message = createBaseKubernetesPodData_ContainerState();
    message.waiting = (object.waiting !== undefined && object.waiting !== null)
      ? KubernetesPodData_ContainerStateWaiting.fromPartial(object.waiting)
      : undefined;
    message.running = (object.running !== undefined && object.running !== null)
      ? KubernetesPodData_ContainerStateRunning.fromPartial(object.running)
      : undefined;
    message.terminated = (object.terminated !== undefined && object.terminated !== null)
      ? KubernetesPodData_ContainerStateTerminated.fromPartial(object.terminated)
      : undefined;
    return message;
  },
};

function createBaseKubernetesPodData_ContainerStateRunning(): KubernetesPodData_ContainerStateRunning {
  return { startedAt: 0 };
}

export const KubernetesPodData_ContainerStateRunning: MessageFns<KubernetesPodData_ContainerStateRunning> = {
  encode(message: KubernetesPodData_ContainerStateRunning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startedAt !== 0) {
      writer.uint32(8).int64(message.startedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ContainerStateRunning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ContainerStateRunning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ContainerStateRunning {
    return { startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : 0 };
  },

  toJSON(message: KubernetesPodData_ContainerStateRunning): unknown {
    const obj: any = {};
    if (message.startedAt !== 0) {
      obj.startedAt = Math.round(message.startedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ContainerStateRunning>, I>>(
    base?: I,
  ): KubernetesPodData_ContainerStateRunning {
    return KubernetesPodData_ContainerStateRunning.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ContainerStateRunning>, I>>(
    object: I,
  ): KubernetesPodData_ContainerStateRunning {
    const message = createBaseKubernetesPodData_ContainerStateRunning();
    message.startedAt = object.startedAt ?? 0;
    return message;
  },
};

function createBaseKubernetesPodData_ContainerStateTerminated(): KubernetesPodData_ContainerStateTerminated {
  return {
    exitCode: 0,
    signal: undefined,
    reason: undefined,
    message: undefined,
    startedAt: undefined,
    finishedAt: undefined,
    containerId: undefined,
  };
}

export const KubernetesPodData_ContainerStateTerminated: MessageFns<KubernetesPodData_ContainerStateTerminated> = {
  encode(message: KubernetesPodData_ContainerStateTerminated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.signal !== undefined) {
      writer.uint32(16).int32(message.signal);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    if (message.message !== undefined) {
      writer.uint32(34).string(message.message);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(40).int64(message.startedAt);
    }
    if (message.finishedAt !== undefined) {
      writer.uint32(48).int64(message.finishedAt);
    }
    if (message.containerId !== undefined) {
      writer.uint32(58).string(message.containerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ContainerStateTerminated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ContainerStateTerminated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signal = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startedAt = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.finishedAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ContainerStateTerminated {
    return {
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      signal: isSet(object.signal) ? globalThis.Number(object.signal) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      startedAt: isSet(object.startedAt) ? globalThis.Number(object.startedAt) : undefined,
      finishedAt: isSet(object.finishedAt) ? globalThis.Number(object.finishedAt) : undefined,
      containerId: isSet(object.containerId) ? globalThis.String(object.containerId) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_ContainerStateTerminated): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.signal !== undefined) {
      obj.signal = Math.round(message.signal);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = Math.round(message.startedAt);
    }
    if (message.finishedAt !== undefined) {
      obj.finishedAt = Math.round(message.finishedAt);
    }
    if (message.containerId !== undefined) {
      obj.containerId = message.containerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ContainerStateTerminated>, I>>(
    base?: I,
  ): KubernetesPodData_ContainerStateTerminated {
    return KubernetesPodData_ContainerStateTerminated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ContainerStateTerminated>, I>>(
    object: I,
  ): KubernetesPodData_ContainerStateTerminated {
    const message = createBaseKubernetesPodData_ContainerStateTerminated();
    message.exitCode = object.exitCode ?? 0;
    message.signal = object.signal ?? undefined;
    message.reason = object.reason ?? undefined;
    message.message = object.message ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.finishedAt = object.finishedAt ?? undefined;
    message.containerId = object.containerId ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_EnvVar(): KubernetesPodData_EnvVar {
  return { name: "", value: "" };
}

export const KubernetesPodData_EnvVar: MessageFns<KubernetesPodData_EnvVar> = {
  encode(message: KubernetesPodData_EnvVar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_EnvVar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_EnvVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_EnvVar {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: KubernetesPodData_EnvVar): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_EnvVar>, I>>(base?: I): KubernetesPodData_EnvVar {
    return KubernetesPodData_EnvVar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_EnvVar>, I>>(object: I): KubernetesPodData_EnvVar {
    const message = createBaseKubernetesPodData_EnvVar();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseKubernetesPodData_Container(): KubernetesPodData_Container {
  return {
    name: "",
    image: undefined,
    command: [],
    args: [],
    workingDir: undefined,
    env: [],
    resources: undefined,
    restartPolicy: undefined,
    terminationMessagePath: undefined,
    terminationMessagePolicy: undefined,
    imagePullPolicy: undefined,
    stdin: false,
    stdinOnce: false,
    tty: false,
  };
}

export const KubernetesPodData_Container: MessageFns<KubernetesPodData_Container> = {
  encode(message: KubernetesPodData_Container, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.image !== undefined) {
      writer.uint32(18).string(message.image);
    }
    for (const v of message.command) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.args) {
      writer.uint32(34).string(v!);
    }
    if (message.workingDir !== undefined) {
      writer.uint32(42).string(message.workingDir);
    }
    for (const v of message.env) {
      KubernetesPodData_EnvVar.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.resources !== undefined) {
      KubernetesPodData_ResourceRequirements.encode(message.resources, writer.uint32(66).fork()).join();
    }
    if (message.restartPolicy !== undefined) {
      writer.uint32(194).string(message.restartPolicy);
    }
    if (message.terminationMessagePath !== undefined) {
      writer.uint32(106).string(message.terminationMessagePath);
    }
    if (message.terminationMessagePolicy !== undefined) {
      writer.uint32(162).string(message.terminationMessagePolicy);
    }
    if (message.imagePullPolicy !== undefined) {
      writer.uint32(114).string(message.imagePullPolicy);
    }
    if (message.stdin !== false) {
      writer.uint32(128).bool(message.stdin);
    }
    if (message.stdinOnce !== false) {
      writer.uint32(136).bool(message.stdinOnce);
    }
    if (message.tty !== false) {
      writer.uint32(144).bool(message.tty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_Container {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_Container();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.command.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workingDir = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.env.push(KubernetesPodData_EnvVar.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resources = KubernetesPodData_ResourceRequirements.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.restartPolicy = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.terminationMessagePath = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.terminationMessagePolicy = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.imagePullPolicy = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.stdin = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.stdinOnce = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.tty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_Container {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : undefined,
      command: globalThis.Array.isArray(object?.command) ? object.command.map((e: any) => globalThis.String(e)) : [],
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      workingDir: isSet(object.workingDir) ? globalThis.String(object.workingDir) : undefined,
      env: globalThis.Array.isArray(object?.env)
        ? object.env.map((e: any) => KubernetesPodData_EnvVar.fromJSON(e))
        : [],
      resources: isSet(object.resources)
        ? KubernetesPodData_ResourceRequirements.fromJSON(object.resources)
        : undefined,
      restartPolicy: isSet(object.restartPolicy) ? globalThis.String(object.restartPolicy) : undefined,
      terminationMessagePath: isSet(object.terminationMessagePath)
        ? globalThis.String(object.terminationMessagePath)
        : undefined,
      terminationMessagePolicy: isSet(object.terminationMessagePolicy)
        ? globalThis.String(object.terminationMessagePolicy)
        : undefined,
      imagePullPolicy: isSet(object.imagePullPolicy) ? globalThis.String(object.imagePullPolicy) : undefined,
      stdin: isSet(object.stdin) ? globalThis.Boolean(object.stdin) : false,
      stdinOnce: isSet(object.stdinOnce) ? globalThis.Boolean(object.stdinOnce) : false,
      tty: isSet(object.tty) ? globalThis.Boolean(object.tty) : false,
    };
  },

  toJSON(message: KubernetesPodData_Container): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.image !== undefined) {
      obj.image = message.image;
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.workingDir !== undefined) {
      obj.workingDir = message.workingDir;
    }
    if (message.env?.length) {
      obj.env = message.env.map((e) => KubernetesPodData_EnvVar.toJSON(e));
    }
    if (message.resources !== undefined) {
      obj.resources = KubernetesPodData_ResourceRequirements.toJSON(message.resources);
    }
    if (message.restartPolicy !== undefined) {
      obj.restartPolicy = message.restartPolicy;
    }
    if (message.terminationMessagePath !== undefined) {
      obj.terminationMessagePath = message.terminationMessagePath;
    }
    if (message.terminationMessagePolicy !== undefined) {
      obj.terminationMessagePolicy = message.terminationMessagePolicy;
    }
    if (message.imagePullPolicy !== undefined) {
      obj.imagePullPolicy = message.imagePullPolicy;
    }
    if (message.stdin !== false) {
      obj.stdin = message.stdin;
    }
    if (message.stdinOnce !== false) {
      obj.stdinOnce = message.stdinOnce;
    }
    if (message.tty !== false) {
      obj.tty = message.tty;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_Container>, I>>(base?: I): KubernetesPodData_Container {
    return KubernetesPodData_Container.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_Container>, I>>(object: I): KubernetesPodData_Container {
    const message = createBaseKubernetesPodData_Container();
    message.name = object.name ?? "";
    message.image = object.image ?? undefined;
    message.command = object.command?.map((e) => e) || [];
    message.args = object.args?.map((e) => e) || [];
    message.workingDir = object.workingDir ?? undefined;
    message.env = object.env?.map((e) => KubernetesPodData_EnvVar.fromPartial(e)) || [];
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? KubernetesPodData_ResourceRequirements.fromPartial(object.resources)
      : undefined;
    message.restartPolicy = object.restartPolicy ?? undefined;
    message.terminationMessagePath = object.terminationMessagePath ?? undefined;
    message.terminationMessagePolicy = object.terminationMessagePolicy ?? undefined;
    message.imagePullPolicy = object.imagePullPolicy ?? undefined;
    message.stdin = object.stdin ?? false;
    message.stdinOnce = object.stdinOnce ?? false;
    message.tty = object.tty ?? false;
    return message;
  },
};

function createBaseKubernetesPodData_ContainerStateWaiting(): KubernetesPodData_ContainerStateWaiting {
  return { reason: undefined, message: undefined };
}

export const KubernetesPodData_ContainerStateWaiting: MessageFns<KubernetesPodData_ContainerStateWaiting> = {
  encode(message: KubernetesPodData_ContainerStateWaiting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== undefined) {
      writer.uint32(10).string(message.reason);
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ContainerStateWaiting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ContainerStateWaiting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ContainerStateWaiting {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_ContainerStateWaiting): unknown {
    const obj: any = {};
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ContainerStateWaiting>, I>>(
    base?: I,
  ): KubernetesPodData_ContainerStateWaiting {
    return KubernetesPodData_ContainerStateWaiting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ContainerStateWaiting>, I>>(
    object: I,
  ): KubernetesPodData_ContainerStateWaiting {
    const message = createBaseKubernetesPodData_ContainerStateWaiting();
    message.reason = object.reason ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_ContainerStatus(): KubernetesPodData_ContainerStatus {
  return {
    name: "",
    state: undefined,
    lastState: undefined,
    ready: undefined,
    restartCount: 0,
    image: "",
    imageId: "",
    containerId: "",
    started: false,
  };
}

export const KubernetesPodData_ContainerStatus: MessageFns<KubernetesPodData_ContainerStatus> = {
  encode(message: KubernetesPodData_ContainerStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== undefined) {
      KubernetesPodData_ContainerState.encode(message.state, writer.uint32(18).fork()).join();
    }
    if (message.lastState !== undefined) {
      KubernetesPodData_ContainerState.encode(message.lastState, writer.uint32(26).fork()).join();
    }
    if (message.ready !== undefined) {
      writer.uint32(32).bool(message.ready);
    }
    if (message.restartCount !== 0) {
      writer.uint32(40).int32(message.restartCount);
    }
    if (message.image !== "") {
      writer.uint32(50).string(message.image);
    }
    if (message.imageId !== "") {
      writer.uint32(58).string(message.imageId);
    }
    if (message.containerId !== "") {
      writer.uint32(66).string(message.containerId);
    }
    if (message.started !== false) {
      writer.uint32(72).bool(message.started);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ContainerStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ContainerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = KubernetesPodData_ContainerState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastState = KubernetesPodData_ContainerState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ready = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.restartCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.started = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ContainerStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? KubernetesPodData_ContainerState.fromJSON(object.state) : undefined,
      lastState: isSet(object.lastState) ? KubernetesPodData_ContainerState.fromJSON(object.lastState) : undefined,
      ready: isSet(object.ready) ? globalThis.Boolean(object.ready) : undefined,
      restartCount: isSet(object.restartCount) ? globalThis.Number(object.restartCount) : 0,
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      containerId: isSet(object.containerId) ? globalThis.String(object.containerId) : "",
      started: isSet(object.started) ? globalThis.Boolean(object.started) : false,
    };
  },

  toJSON(message: KubernetesPodData_ContainerStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== undefined) {
      obj.state = KubernetesPodData_ContainerState.toJSON(message.state);
    }
    if (message.lastState !== undefined) {
      obj.lastState = KubernetesPodData_ContainerState.toJSON(message.lastState);
    }
    if (message.ready !== undefined) {
      obj.ready = message.ready;
    }
    if (message.restartCount !== 0) {
      obj.restartCount = Math.round(message.restartCount);
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    if (message.started !== false) {
      obj.started = message.started;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ContainerStatus>, I>>(
    base?: I,
  ): KubernetesPodData_ContainerStatus {
    return KubernetesPodData_ContainerStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ContainerStatus>, I>>(
    object: I,
  ): KubernetesPodData_ContainerStatus {
    const message = createBaseKubernetesPodData_ContainerStatus();
    message.name = object.name ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? KubernetesPodData_ContainerState.fromPartial(object.state)
      : undefined;
    message.lastState = (object.lastState !== undefined && object.lastState !== null)
      ? KubernetesPodData_ContainerState.fromPartial(object.lastState)
      : undefined;
    message.ready = object.ready ?? undefined;
    message.restartCount = object.restartCount ?? 0;
    message.image = object.image ?? "";
    message.imageId = object.imageId ?? "";
    message.containerId = object.containerId ?? "";
    message.started = object.started ?? false;
    return message;
  },
};

function createBaseKubernetesPodData_Quantity(): KubernetesPodData_Quantity {
  return { string: undefined };
}

export const KubernetesPodData_Quantity: MessageFns<KubernetesPodData_Quantity> = {
  encode(message: KubernetesPodData_Quantity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.string !== undefined) {
      writer.uint32(10).string(message.string);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_Quantity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_Quantity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.string = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_Quantity {
    return { string: isSet(object.string) ? globalThis.String(object.string) : undefined };
  },

  toJSON(message: KubernetesPodData_Quantity): unknown {
    const obj: any = {};
    if (message.string !== undefined) {
      obj.string = message.string;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_Quantity>, I>>(base?: I): KubernetesPodData_Quantity {
    return KubernetesPodData_Quantity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_Quantity>, I>>(object: I): KubernetesPodData_Quantity {
    const message = createBaseKubernetesPodData_Quantity();
    message.string = object.string ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_ResourceRequirements(): KubernetesPodData_ResourceRequirements {
  return { limits: {}, requests: {} };
}

export const KubernetesPodData_ResourceRequirements: MessageFns<KubernetesPodData_ResourceRequirements> = {
  encode(message: KubernetesPodData_ResourceRequirements, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.limits).forEach(([key, value]) => {
      KubernetesPodData_ResourceRequirements_LimitsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    Object.entries(message.requests).forEach(([key, value]) => {
      KubernetesPodData_ResourceRequirements_RequestsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ResourceRequirements {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ResourceRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = KubernetesPodData_ResourceRequirements_LimitsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.limits[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = KubernetesPodData_ResourceRequirements_RequestsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.requests[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ResourceRequirements {
    return {
      limits: isObject(object.limits)
        ? Object.entries(object.limits).reduce<{ [key: string]: KubernetesPodData_Quantity }>((acc, [key, value]) => {
          acc[key] = KubernetesPodData_Quantity.fromJSON(value);
          return acc;
        }, {})
        : {},
      requests: isObject(object.requests)
        ? Object.entries(object.requests).reduce<{ [key: string]: KubernetesPodData_Quantity }>((acc, [key, value]) => {
          acc[key] = KubernetesPodData_Quantity.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: KubernetesPodData_ResourceRequirements): unknown {
    const obj: any = {};
    if (message.limits) {
      const entries = Object.entries(message.limits);
      if (entries.length > 0) {
        obj.limits = {};
        entries.forEach(([k, v]) => {
          obj.limits[k] = KubernetesPodData_Quantity.toJSON(v);
        });
      }
    }
    if (message.requests) {
      const entries = Object.entries(message.requests);
      if (entries.length > 0) {
        obj.requests = {};
        entries.forEach(([k, v]) => {
          obj.requests[k] = KubernetesPodData_Quantity.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ResourceRequirements>, I>>(
    base?: I,
  ): KubernetesPodData_ResourceRequirements {
    return KubernetesPodData_ResourceRequirements.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ResourceRequirements>, I>>(
    object: I,
  ): KubernetesPodData_ResourceRequirements {
    const message = createBaseKubernetesPodData_ResourceRequirements();
    message.limits = Object.entries(object.limits ?? {}).reduce<{ [key: string]: KubernetesPodData_Quantity }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = KubernetesPodData_Quantity.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.requests = Object.entries(object.requests ?? {}).reduce<{ [key: string]: KubernetesPodData_Quantity }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = KubernetesPodData_Quantity.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseKubernetesPodData_ResourceRequirements_LimitsEntry(): KubernetesPodData_ResourceRequirements_LimitsEntry {
  return { key: "", value: undefined };
}

export const KubernetesPodData_ResourceRequirements_LimitsEntry: MessageFns<
  KubernetesPodData_ResourceRequirements_LimitsEntry
> = {
  encode(
    message: KubernetesPodData_ResourceRequirements_LimitsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      KubernetesPodData_Quantity.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ResourceRequirements_LimitsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ResourceRequirements_LimitsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = KubernetesPodData_Quantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ResourceRequirements_LimitsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? KubernetesPodData_Quantity.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_ResourceRequirements_LimitsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = KubernetesPodData_Quantity.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ResourceRequirements_LimitsEntry>, I>>(
    base?: I,
  ): KubernetesPodData_ResourceRequirements_LimitsEntry {
    return KubernetesPodData_ResourceRequirements_LimitsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ResourceRequirements_LimitsEntry>, I>>(
    object: I,
  ): KubernetesPodData_ResourceRequirements_LimitsEntry {
    const message = createBaseKubernetesPodData_ResourceRequirements_LimitsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? KubernetesPodData_Quantity.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseKubernetesPodData_ResourceRequirements_RequestsEntry(): KubernetesPodData_ResourceRequirements_RequestsEntry {
  return { key: "", value: undefined };
}

export const KubernetesPodData_ResourceRequirements_RequestsEntry: MessageFns<
  KubernetesPodData_ResourceRequirements_RequestsEntry
> = {
  encode(
    message: KubernetesPodData_ResourceRequirements_RequestsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      KubernetesPodData_Quantity.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_ResourceRequirements_RequestsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_ResourceRequirements_RequestsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = KubernetesPodData_Quantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_ResourceRequirements_RequestsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? KubernetesPodData_Quantity.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_ResourceRequirements_RequestsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = KubernetesPodData_Quantity.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_ResourceRequirements_RequestsEntry>, I>>(
    base?: I,
  ): KubernetesPodData_ResourceRequirements_RequestsEntry {
    return KubernetesPodData_ResourceRequirements_RequestsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_ResourceRequirements_RequestsEntry>, I>>(
    object: I,
  ): KubernetesPodData_ResourceRequirements_RequestsEntry {
    const message = createBaseKubernetesPodData_ResourceRequirements_RequestsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? KubernetesPodData_Quantity.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseKubernetesPodData_PodCondition(): KubernetesPodData_PodCondition {
  return { type: "", status: "", lastProbeTime: 0, lastTransitionTime: 0, reason: undefined, message: undefined };
}

export const KubernetesPodData_PodCondition: MessageFns<KubernetesPodData_PodCondition> = {
  encode(message: KubernetesPodData_PodCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.lastProbeTime !== 0) {
      writer.uint32(24).int64(message.lastProbeTime);
    }
    if (message.lastTransitionTime !== 0) {
      writer.uint32(32).int64(message.lastTransitionTime);
    }
    if (message.reason !== undefined) {
      writer.uint32(42).string(message.reason);
    }
    if (message.message !== undefined) {
      writer.uint32(50).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_PodCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_PodCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastProbeTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastTransitionTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_PodCondition {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastProbeTime: isSet(object.lastProbeTime) ? globalThis.Number(object.lastProbeTime) : 0,
      lastTransitionTime: isSet(object.lastTransitionTime) ? globalThis.Number(object.lastTransitionTime) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_PodCondition): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastProbeTime !== 0) {
      obj.lastProbeTime = Math.round(message.lastProbeTime);
    }
    if (message.lastTransitionTime !== 0) {
      obj.lastTransitionTime = Math.round(message.lastTransitionTime);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_PodCondition>, I>>(base?: I): KubernetesPodData_PodCondition {
    return KubernetesPodData_PodCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_PodCondition>, I>>(
    object: I,
  ): KubernetesPodData_PodCondition {
    const message = createBaseKubernetesPodData_PodCondition();
    message.type = object.type ?? "";
    message.status = object.status ?? "";
    message.lastProbeTime = object.lastProbeTime ?? 0;
    message.lastTransitionTime = object.lastTransitionTime ?? 0;
    message.reason = object.reason ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_HostIP(): KubernetesPodData_HostIP {
  return { ip: undefined };
}

export const KubernetesPodData_HostIP: MessageFns<KubernetesPodData_HostIP> = {
  encode(message: KubernetesPodData_HostIP, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== undefined) {
      writer.uint32(10).string(message.ip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_HostIP {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_HostIP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_HostIP {
    return { ip: isSet(object.ip) ? globalThis.String(object.ip) : undefined };
  },

  toJSON(message: KubernetesPodData_HostIP): unknown {
    const obj: any = {};
    if (message.ip !== undefined) {
      obj.ip = message.ip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_HostIP>, I>>(base?: I): KubernetesPodData_HostIP {
    return KubernetesPodData_HostIP.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_HostIP>, I>>(object: I): KubernetesPodData_HostIP {
    const message = createBaseKubernetesPodData_HostIP();
    message.ip = object.ip ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_PodStatus(): KubernetesPodData_PodStatus {
  return {
    phase: undefined,
    conditions: [],
    message: undefined,
    reason: undefined,
    nominatedNodeName: undefined,
    hostIp: undefined,
    hostIps: [],
    podIp: undefined,
    startTime: undefined,
    initContainerStatuses: [],
    containerStatuses: [],
    qosClass: undefined,
    ephemeralContainerStatuses: [],
    resize: undefined,
  };
}

export const KubernetesPodData_PodStatus: MessageFns<KubernetesPodData_PodStatus> = {
  encode(message: KubernetesPodData_PodStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phase !== undefined) {
      writer.uint32(10).string(message.phase);
    }
    for (const v of message.conditions) {
      KubernetesPodData_PodCondition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    if (message.nominatedNodeName !== undefined) {
      writer.uint32(90).string(message.nominatedNodeName);
    }
    if (message.hostIp !== undefined) {
      writer.uint32(42).string(message.hostIp);
    }
    for (const v of message.hostIps) {
      KubernetesPodData_HostIP.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.podIp !== undefined) {
      writer.uint32(50).string(message.podIp);
    }
    if (message.startTime !== undefined) {
      writer.uint32(56).int64(message.startTime);
    }
    for (const v of message.initContainerStatuses) {
      KubernetesPodData_ContainerStatus.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.containerStatuses) {
      KubernetesPodData_ContainerStatus.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.qosClass !== undefined) {
      writer.uint32(74).string(message.qosClass);
    }
    for (const v of message.ephemeralContainerStatuses) {
      KubernetesPodData_ContainerStatus.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.resize !== undefined) {
      writer.uint32(114).string(message.resize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_PodStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_PodStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.phase = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conditions.push(KubernetesPodData_PodCondition.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nominatedNodeName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hostIp = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.hostIps.push(KubernetesPodData_HostIP.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.podIp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.startTime = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.initContainerStatuses.push(KubernetesPodData_ContainerStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.containerStatuses.push(KubernetesPodData_ContainerStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.qosClass = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.ephemeralContainerStatuses.push(KubernetesPodData_ContainerStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.resize = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_PodStatus {
    return {
      phase: isSet(object.phase) ? globalThis.String(object.phase) : undefined,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => KubernetesPodData_PodCondition.fromJSON(e))
        : [],
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      nominatedNodeName: isSet(object.nominatedNodeName) ? globalThis.String(object.nominatedNodeName) : undefined,
      hostIp: isSet(object.hostIp) ? globalThis.String(object.hostIp) : undefined,
      hostIps: globalThis.Array.isArray(object?.hostIps)
        ? object.hostIps.map((e: any) => KubernetesPodData_HostIP.fromJSON(e))
        : [],
      podIp: isSet(object.podIp) ? globalThis.String(object.podIp) : undefined,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : undefined,
      initContainerStatuses: globalThis.Array.isArray(object?.initContainerStatuses)
        ? object.initContainerStatuses.map((e: any) => KubernetesPodData_ContainerStatus.fromJSON(e))
        : [],
      containerStatuses: globalThis.Array.isArray(object?.containerStatuses)
        ? object.containerStatuses.map((e: any) => KubernetesPodData_ContainerStatus.fromJSON(e))
        : [],
      qosClass: isSet(object.qosClass) ? globalThis.String(object.qosClass) : undefined,
      ephemeralContainerStatuses: globalThis.Array.isArray(object?.ephemeralContainerStatuses)
        ? object.ephemeralContainerStatuses.map((e: any) => KubernetesPodData_ContainerStatus.fromJSON(e))
        : [],
      resize: isSet(object.resize) ? globalThis.String(object.resize) : undefined,
    };
  },

  toJSON(message: KubernetesPodData_PodStatus): unknown {
    const obj: any = {};
    if (message.phase !== undefined) {
      obj.phase = message.phase;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => KubernetesPodData_PodCondition.toJSON(e));
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.nominatedNodeName !== undefined) {
      obj.nominatedNodeName = message.nominatedNodeName;
    }
    if (message.hostIp !== undefined) {
      obj.hostIp = message.hostIp;
    }
    if (message.hostIps?.length) {
      obj.hostIps = message.hostIps.map((e) => KubernetesPodData_HostIP.toJSON(e));
    }
    if (message.podIp !== undefined) {
      obj.podIp = message.podIp;
    }
    if (message.startTime !== undefined) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.initContainerStatuses?.length) {
      obj.initContainerStatuses = message.initContainerStatuses.map((e) => KubernetesPodData_ContainerStatus.toJSON(e));
    }
    if (message.containerStatuses?.length) {
      obj.containerStatuses = message.containerStatuses.map((e) => KubernetesPodData_ContainerStatus.toJSON(e));
    }
    if (message.qosClass !== undefined) {
      obj.qosClass = message.qosClass;
    }
    if (message.ephemeralContainerStatuses?.length) {
      obj.ephemeralContainerStatuses = message.ephemeralContainerStatuses.map((e) =>
        KubernetesPodData_ContainerStatus.toJSON(e)
      );
    }
    if (message.resize !== undefined) {
      obj.resize = message.resize;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_PodStatus>, I>>(base?: I): KubernetesPodData_PodStatus {
    return KubernetesPodData_PodStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_PodStatus>, I>>(object: I): KubernetesPodData_PodStatus {
    const message = createBaseKubernetesPodData_PodStatus();
    message.phase = object.phase ?? undefined;
    message.conditions = object.conditions?.map((e) => KubernetesPodData_PodCondition.fromPartial(e)) || [];
    message.message = object.message ?? undefined;
    message.reason = object.reason ?? undefined;
    message.nominatedNodeName = object.nominatedNodeName ?? undefined;
    message.hostIp = object.hostIp ?? undefined;
    message.hostIps = object.hostIps?.map((e) => KubernetesPodData_HostIP.fromPartial(e)) || [];
    message.podIp = object.podIp ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.initContainerStatuses =
      object.initContainerStatuses?.map((e) => KubernetesPodData_ContainerStatus.fromPartial(e)) || [];
    message.containerStatuses =
      object.containerStatuses?.map((e) => KubernetesPodData_ContainerStatus.fromPartial(e)) || [];
    message.qosClass = object.qosClass ?? undefined;
    message.ephemeralContainerStatuses =
      object.ephemeralContainerStatuses?.map((e) => KubernetesPodData_ContainerStatus.fromPartial(e)) || [];
    message.resize = object.resize ?? undefined;
    return message;
  },
};

function createBaseKubernetesPodData_LabelsEntry(): KubernetesPodData_LabelsEntry {
  return { key: "", value: "" };
}

export const KubernetesPodData_LabelsEntry: MessageFns<KubernetesPodData_LabelsEntry> = {
  encode(message: KubernetesPodData_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: KubernetesPodData_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_LabelsEntry>, I>>(base?: I): KubernetesPodData_LabelsEntry {
    return KubernetesPodData_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_LabelsEntry>, I>>(
    object: I,
  ): KubernetesPodData_LabelsEntry {
    const message = createBaseKubernetesPodData_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseKubernetesPodData_AnnotationsEntry(): KubernetesPodData_AnnotationsEntry {
  return { key: "", value: "" };
}

export const KubernetesPodData_AnnotationsEntry: MessageFns<KubernetesPodData_AnnotationsEntry> = {
  encode(message: KubernetesPodData_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesPodData_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesPodData_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesPodData_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: KubernetesPodData_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KubernetesPodData_AnnotationsEntry>, I>>(
    base?: I,
  ): KubernetesPodData_AnnotationsEntry {
    return KubernetesPodData_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KubernetesPodData_AnnotationsEntry>, I>>(
    object: I,
  ): KubernetesPodData_AnnotationsEntry {
    const message = createBaseKubernetesPodData_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
