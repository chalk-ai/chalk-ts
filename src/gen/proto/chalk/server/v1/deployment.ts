// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/deployment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "chalk.server.v1";

export enum DeploymentStatus {
  DEPLOYMENT_STATUS_UNSPECIFIED = 0,
  DEPLOYMENT_STATUS_UNKNOWN = 1,
  DEPLOYMENT_STATUS_PENDING = 2,
  DEPLOYMENT_STATUS_QUEUED = 3,
  DEPLOYMENT_STATUS_WORKING = 4,
  DEPLOYMENT_STATUS_SUCCESS = 5,
  DEPLOYMENT_STATUS_FAILURE = 6,
  DEPLOYMENT_STATUS_INTERNAL_ERROR = 7,
  DEPLOYMENT_STATUS_TIMEOUT = 8,
  DEPLOYMENT_STATUS_CANCELLED = 9,
  DEPLOYMENT_STATUS_EXPIRED = 10,
  DEPLOYMENT_STATUS_BOOT_ERRORS = 11,
  DEPLOYMENT_STATUS_AWAITING_SOURCE = 12,
  DEPLOYMENT_STATUS_DEPLOYING = 13,
  UNRECOGNIZED = -1,
}

export function deploymentStatusFromJSON(object: any): DeploymentStatus {
  switch (object) {
    case 0:
    case "DEPLOYMENT_STATUS_UNSPECIFIED":
      return DeploymentStatus.DEPLOYMENT_STATUS_UNSPECIFIED;
    case 1:
    case "DEPLOYMENT_STATUS_UNKNOWN":
      return DeploymentStatus.DEPLOYMENT_STATUS_UNKNOWN;
    case 2:
    case "DEPLOYMENT_STATUS_PENDING":
      return DeploymentStatus.DEPLOYMENT_STATUS_PENDING;
    case 3:
    case "DEPLOYMENT_STATUS_QUEUED":
      return DeploymentStatus.DEPLOYMENT_STATUS_QUEUED;
    case 4:
    case "DEPLOYMENT_STATUS_WORKING":
      return DeploymentStatus.DEPLOYMENT_STATUS_WORKING;
    case 5:
    case "DEPLOYMENT_STATUS_SUCCESS":
      return DeploymentStatus.DEPLOYMENT_STATUS_SUCCESS;
    case 6:
    case "DEPLOYMENT_STATUS_FAILURE":
      return DeploymentStatus.DEPLOYMENT_STATUS_FAILURE;
    case 7:
    case "DEPLOYMENT_STATUS_INTERNAL_ERROR":
      return DeploymentStatus.DEPLOYMENT_STATUS_INTERNAL_ERROR;
    case 8:
    case "DEPLOYMENT_STATUS_TIMEOUT":
      return DeploymentStatus.DEPLOYMENT_STATUS_TIMEOUT;
    case 9:
    case "DEPLOYMENT_STATUS_CANCELLED":
      return DeploymentStatus.DEPLOYMENT_STATUS_CANCELLED;
    case 10:
    case "DEPLOYMENT_STATUS_EXPIRED":
      return DeploymentStatus.DEPLOYMENT_STATUS_EXPIRED;
    case 11:
    case "DEPLOYMENT_STATUS_BOOT_ERRORS":
      return DeploymentStatus.DEPLOYMENT_STATUS_BOOT_ERRORS;
    case 12:
    case "DEPLOYMENT_STATUS_AWAITING_SOURCE":
      return DeploymentStatus.DEPLOYMENT_STATUS_AWAITING_SOURCE;
    case 13:
    case "DEPLOYMENT_STATUS_DEPLOYING":
      return DeploymentStatus.DEPLOYMENT_STATUS_DEPLOYING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeploymentStatus.UNRECOGNIZED;
  }
}

export function deploymentStatusToJSON(object: DeploymentStatus): string {
  switch (object) {
    case DeploymentStatus.DEPLOYMENT_STATUS_UNSPECIFIED:
      return "DEPLOYMENT_STATUS_UNSPECIFIED";
    case DeploymentStatus.DEPLOYMENT_STATUS_UNKNOWN:
      return "DEPLOYMENT_STATUS_UNKNOWN";
    case DeploymentStatus.DEPLOYMENT_STATUS_PENDING:
      return "DEPLOYMENT_STATUS_PENDING";
    case DeploymentStatus.DEPLOYMENT_STATUS_QUEUED:
      return "DEPLOYMENT_STATUS_QUEUED";
    case DeploymentStatus.DEPLOYMENT_STATUS_WORKING:
      return "DEPLOYMENT_STATUS_WORKING";
    case DeploymentStatus.DEPLOYMENT_STATUS_SUCCESS:
      return "DEPLOYMENT_STATUS_SUCCESS";
    case DeploymentStatus.DEPLOYMENT_STATUS_FAILURE:
      return "DEPLOYMENT_STATUS_FAILURE";
    case DeploymentStatus.DEPLOYMENT_STATUS_INTERNAL_ERROR:
      return "DEPLOYMENT_STATUS_INTERNAL_ERROR";
    case DeploymentStatus.DEPLOYMENT_STATUS_TIMEOUT:
      return "DEPLOYMENT_STATUS_TIMEOUT";
    case DeploymentStatus.DEPLOYMENT_STATUS_CANCELLED:
      return "DEPLOYMENT_STATUS_CANCELLED";
    case DeploymentStatus.DEPLOYMENT_STATUS_EXPIRED:
      return "DEPLOYMENT_STATUS_EXPIRED";
    case DeploymentStatus.DEPLOYMENT_STATUS_BOOT_ERRORS:
      return "DEPLOYMENT_STATUS_BOOT_ERRORS";
    case DeploymentStatus.DEPLOYMENT_STATUS_AWAITING_SOURCE:
      return "DEPLOYMENT_STATUS_AWAITING_SOURCE";
    case DeploymentStatus.DEPLOYMENT_STATUS_DEPLOYING:
      return "DEPLOYMENT_STATUS_DEPLOYING";
    case DeploymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DeploymentProfilingMode {
  DEPLOYMENT_PROFILING_MODE_UNSPECIFIED = 0,
  DEPLOYMENT_PROFILING_MODE_NONE = 1,
  DEPLOYMENT_PROFILING_MODE_O2 = 2,
  UNRECOGNIZED = -1,
}

export function deploymentProfilingModeFromJSON(object: any): DeploymentProfilingMode {
  switch (object) {
    case 0:
    case "DEPLOYMENT_PROFILING_MODE_UNSPECIFIED":
      return DeploymentProfilingMode.DEPLOYMENT_PROFILING_MODE_UNSPECIFIED;
    case 1:
    case "DEPLOYMENT_PROFILING_MODE_NONE":
      return DeploymentProfilingMode.DEPLOYMENT_PROFILING_MODE_NONE;
    case 2:
    case "DEPLOYMENT_PROFILING_MODE_O2":
      return DeploymentProfilingMode.DEPLOYMENT_PROFILING_MODE_O2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeploymentProfilingMode.UNRECOGNIZED;
  }
}

export function deploymentProfilingModeToJSON(object: DeploymentProfilingMode): string {
  switch (object) {
    case DeploymentProfilingMode.DEPLOYMENT_PROFILING_MODE_UNSPECIFIED:
      return "DEPLOYMENT_PROFILING_MODE_UNSPECIFIED";
    case DeploymentProfilingMode.DEPLOYMENT_PROFILING_MODE_NONE:
      return "DEPLOYMENT_PROFILING_MODE_NONE";
    case DeploymentProfilingMode.DEPLOYMENT_PROFILING_MODE_O2:
      return "DEPLOYMENT_PROFILING_MODE_O2";
    case DeploymentProfilingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InstanceSizing {
  minInstances?: number | undefined;
  maxInstances?: number | undefined;
}

export interface Deployment {
  id: string;
  environmentId: string;
  status: DeploymentStatus;
  deploymentTags: string[];
  cloudBuildId: string;
  triggeredBy: string;
  requirementsFilepath?: string | undefined;
  dockerfileFilepath?: string | undefined;
  runtime?: string | undefined;
  chalkpyVersion: string;
  rawDependencyHash: string;
  finalDependencyHash?: string | undefined;
  isPreviewDeployment?: boolean | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  gitCommit: string;
  gitPr: string;
  gitBranch: string;
  gitAuthorEmail: string;
  branch: string;
  projectSettings: string;
  requirementsFiles?: string | undefined;
  gitTag: string;
  baseImageSha: string;
  statusChangedAt: Date | undefined;
  pinnedPlatformVersion?: string | undefined;
  previewDeploymentTag?: string | undefined;
  profilingMode?: DeploymentProfilingMode | undefined;
}

function createBaseInstanceSizing(): InstanceSizing {
  return { minInstances: undefined, maxInstances: undefined };
}

export const InstanceSizing: MessageFns<InstanceSizing> = {
  encode(message: InstanceSizing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minInstances !== undefined) {
      writer.uint32(8).uint32(message.minInstances);
    }
    if (message.maxInstances !== undefined) {
      writer.uint32(16).uint32(message.maxInstances);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceSizing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceSizing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minInstances = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxInstances = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceSizing {
    return {
      minInstances: isSet(object.minInstances) ? globalThis.Number(object.minInstances) : undefined,
      maxInstances: isSet(object.maxInstances) ? globalThis.Number(object.maxInstances) : undefined,
    };
  },

  toJSON(message: InstanceSizing): unknown {
    const obj: any = {};
    if (message.minInstances !== undefined) {
      obj.minInstances = Math.round(message.minInstances);
    }
    if (message.maxInstances !== undefined) {
      obj.maxInstances = Math.round(message.maxInstances);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceSizing>, I>>(base?: I): InstanceSizing {
    return InstanceSizing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceSizing>, I>>(object: I): InstanceSizing {
    const message = createBaseInstanceSizing();
    message.minInstances = object.minInstances ?? undefined;
    message.maxInstances = object.maxInstances ?? undefined;
    return message;
  },
};

function createBaseDeployment(): Deployment {
  return {
    id: "",
    environmentId: "",
    status: 0,
    deploymentTags: [],
    cloudBuildId: "",
    triggeredBy: "",
    requirementsFilepath: undefined,
    dockerfileFilepath: undefined,
    runtime: undefined,
    chalkpyVersion: "",
    rawDependencyHash: "",
    finalDependencyHash: undefined,
    isPreviewDeployment: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    gitCommit: "",
    gitPr: "",
    gitBranch: "",
    gitAuthorEmail: "",
    branch: "",
    projectSettings: "",
    requirementsFiles: undefined,
    gitTag: "",
    baseImageSha: "",
    statusChangedAt: undefined,
    pinnedPlatformVersion: undefined,
    previewDeploymentTag: undefined,
    profilingMode: undefined,
  };
}

export const Deployment: MessageFns<Deployment> = {
  encode(message: Deployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    for (const v of message.deploymentTags) {
      writer.uint32(34).string(v!);
    }
    if (message.cloudBuildId !== "") {
      writer.uint32(42).string(message.cloudBuildId);
    }
    if (message.triggeredBy !== "") {
      writer.uint32(50).string(message.triggeredBy);
    }
    if (message.requirementsFilepath !== undefined) {
      writer.uint32(58).string(message.requirementsFilepath);
    }
    if (message.dockerfileFilepath !== undefined) {
      writer.uint32(66).string(message.dockerfileFilepath);
    }
    if (message.runtime !== undefined) {
      writer.uint32(74).string(message.runtime);
    }
    if (message.chalkpyVersion !== "") {
      writer.uint32(82).string(message.chalkpyVersion);
    }
    if (message.rawDependencyHash !== "") {
      writer.uint32(90).string(message.rawDependencyHash);
    }
    if (message.finalDependencyHash !== undefined) {
      writer.uint32(98).string(message.finalDependencyHash);
    }
    if (message.isPreviewDeployment !== undefined) {
      writer.uint32(104).bool(message.isPreviewDeployment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(114).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(122).fork()).join();
    }
    if (message.gitCommit !== "") {
      writer.uint32(130).string(message.gitCommit);
    }
    if (message.gitPr !== "") {
      writer.uint32(138).string(message.gitPr);
    }
    if (message.gitBranch !== "") {
      writer.uint32(146).string(message.gitBranch);
    }
    if (message.gitAuthorEmail !== "") {
      writer.uint32(154).string(message.gitAuthorEmail);
    }
    if (message.branch !== "") {
      writer.uint32(162).string(message.branch);
    }
    if (message.projectSettings !== "") {
      writer.uint32(170).string(message.projectSettings);
    }
    if (message.requirementsFiles !== undefined) {
      writer.uint32(178).string(message.requirementsFiles);
    }
    if (message.gitTag !== "") {
      writer.uint32(186).string(message.gitTag);
    }
    if (message.baseImageSha !== "") {
      writer.uint32(194).string(message.baseImageSha);
    }
    if (message.statusChangedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.statusChangedAt), writer.uint32(202).fork()).join();
    }
    if (message.pinnedPlatformVersion !== undefined) {
      writer.uint32(210).string(message.pinnedPlatformVersion);
    }
    if (message.previewDeploymentTag !== undefined) {
      writer.uint32(218).string(message.previewDeploymentTag);
    }
    if (message.profilingMode !== undefined) {
      writer.uint32(224).int32(message.profilingMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deploymentTags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cloudBuildId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requirementsFilepath = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dockerfileFilepath = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.chalkpyVersion = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rawDependencyHash = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.finalDependencyHash = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isPreviewDeployment = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.gitCommit = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.gitPr = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.gitBranch = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.gitAuthorEmail = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.projectSettings = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.requirementsFiles = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.gitTag = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.baseImageSha = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.statusChangedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.pinnedPlatformVersion = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.previewDeploymentTag = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.profilingMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      status: isSet(object.status) ? deploymentStatusFromJSON(object.status) : 0,
      deploymentTags: globalThis.Array.isArray(object?.deploymentTags)
        ? object.deploymentTags.map((e: any) => globalThis.String(e))
        : [],
      cloudBuildId: isSet(object.cloudBuildId) ? globalThis.String(object.cloudBuildId) : "",
      triggeredBy: isSet(object.triggeredBy) ? globalThis.String(object.triggeredBy) : "",
      requirementsFilepath: isSet(object.requirementsFilepath)
        ? globalThis.String(object.requirementsFilepath)
        : undefined,
      dockerfileFilepath: isSet(object.dockerfileFilepath) ? globalThis.String(object.dockerfileFilepath) : undefined,
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : undefined,
      chalkpyVersion: isSet(object.chalkpyVersion) ? globalThis.String(object.chalkpyVersion) : "",
      rawDependencyHash: isSet(object.rawDependencyHash) ? globalThis.String(object.rawDependencyHash) : "",
      finalDependencyHash: isSet(object.finalDependencyHash)
        ? globalThis.String(object.finalDependencyHash)
        : undefined,
      isPreviewDeployment: isSet(object.isPreviewDeployment)
        ? globalThis.Boolean(object.isPreviewDeployment)
        : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      gitCommit: isSet(object.gitCommit) ? globalThis.String(object.gitCommit) : "",
      gitPr: isSet(object.gitPr) ? globalThis.String(object.gitPr) : "",
      gitBranch: isSet(object.gitBranch) ? globalThis.String(object.gitBranch) : "",
      gitAuthorEmail: isSet(object.gitAuthorEmail) ? globalThis.String(object.gitAuthorEmail) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      projectSettings: isSet(object.projectSettings) ? globalThis.String(object.projectSettings) : "",
      requirementsFiles: isSet(object.requirementsFiles) ? globalThis.String(object.requirementsFiles) : undefined,
      gitTag: isSet(object.gitTag) ? globalThis.String(object.gitTag) : "",
      baseImageSha: isSet(object.baseImageSha) ? globalThis.String(object.baseImageSha) : "",
      statusChangedAt: isSet(object.statusChangedAt) ? fromJsonTimestamp(object.statusChangedAt) : undefined,
      pinnedPlatformVersion: isSet(object.pinnedPlatformVersion)
        ? globalThis.String(object.pinnedPlatformVersion)
        : undefined,
      previewDeploymentTag: isSet(object.previewDeploymentTag)
        ? globalThis.String(object.previewDeploymentTag)
        : undefined,
      profilingMode: isSet(object.profilingMode) ? deploymentProfilingModeFromJSON(object.profilingMode) : undefined,
    };
  },

  toJSON(message: Deployment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.status !== 0) {
      obj.status = deploymentStatusToJSON(message.status);
    }
    if (message.deploymentTags?.length) {
      obj.deploymentTags = message.deploymentTags;
    }
    if (message.cloudBuildId !== "") {
      obj.cloudBuildId = message.cloudBuildId;
    }
    if (message.triggeredBy !== "") {
      obj.triggeredBy = message.triggeredBy;
    }
    if (message.requirementsFilepath !== undefined) {
      obj.requirementsFilepath = message.requirementsFilepath;
    }
    if (message.dockerfileFilepath !== undefined) {
      obj.dockerfileFilepath = message.dockerfileFilepath;
    }
    if (message.runtime !== undefined) {
      obj.runtime = message.runtime;
    }
    if (message.chalkpyVersion !== "") {
      obj.chalkpyVersion = message.chalkpyVersion;
    }
    if (message.rawDependencyHash !== "") {
      obj.rawDependencyHash = message.rawDependencyHash;
    }
    if (message.finalDependencyHash !== undefined) {
      obj.finalDependencyHash = message.finalDependencyHash;
    }
    if (message.isPreviewDeployment !== undefined) {
      obj.isPreviewDeployment = message.isPreviewDeployment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.gitCommit !== "") {
      obj.gitCommit = message.gitCommit;
    }
    if (message.gitPr !== "") {
      obj.gitPr = message.gitPr;
    }
    if (message.gitBranch !== "") {
      obj.gitBranch = message.gitBranch;
    }
    if (message.gitAuthorEmail !== "") {
      obj.gitAuthorEmail = message.gitAuthorEmail;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.projectSettings !== "") {
      obj.projectSettings = message.projectSettings;
    }
    if (message.requirementsFiles !== undefined) {
      obj.requirementsFiles = message.requirementsFiles;
    }
    if (message.gitTag !== "") {
      obj.gitTag = message.gitTag;
    }
    if (message.baseImageSha !== "") {
      obj.baseImageSha = message.baseImageSha;
    }
    if (message.statusChangedAt !== undefined) {
      obj.statusChangedAt = message.statusChangedAt.toISOString();
    }
    if (message.pinnedPlatformVersion !== undefined) {
      obj.pinnedPlatformVersion = message.pinnedPlatformVersion;
    }
    if (message.previewDeploymentTag !== undefined) {
      obj.previewDeploymentTag = message.previewDeploymentTag;
    }
    if (message.profilingMode !== undefined) {
      obj.profilingMode = deploymentProfilingModeToJSON(message.profilingMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deployment>, I>>(base?: I): Deployment {
    return Deployment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deployment>, I>>(object: I): Deployment {
    const message = createBaseDeployment();
    message.id = object.id ?? "";
    message.environmentId = object.environmentId ?? "";
    message.status = object.status ?? 0;
    message.deploymentTags = object.deploymentTags?.map((e) => e) || [];
    message.cloudBuildId = object.cloudBuildId ?? "";
    message.triggeredBy = object.triggeredBy ?? "";
    message.requirementsFilepath = object.requirementsFilepath ?? undefined;
    message.dockerfileFilepath = object.dockerfileFilepath ?? undefined;
    message.runtime = object.runtime ?? undefined;
    message.chalkpyVersion = object.chalkpyVersion ?? "";
    message.rawDependencyHash = object.rawDependencyHash ?? "";
    message.finalDependencyHash = object.finalDependencyHash ?? undefined;
    message.isPreviewDeployment = object.isPreviewDeployment ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.gitCommit = object.gitCommit ?? "";
    message.gitPr = object.gitPr ?? "";
    message.gitBranch = object.gitBranch ?? "";
    message.gitAuthorEmail = object.gitAuthorEmail ?? "";
    message.branch = object.branch ?? "";
    message.projectSettings = object.projectSettings ?? "";
    message.requirementsFiles = object.requirementsFiles ?? undefined;
    message.gitTag = object.gitTag ?? "";
    message.baseImageSha = object.baseImageSha ?? "";
    message.statusChangedAt = object.statusChangedAt ?? undefined;
    message.pinnedPlatformVersion = object.pinnedPlatformVersion ?? undefined;
    message.previewDeploymentTag = object.previewDeploymentTag ?? undefined;
    message.profilingMode = object.profilingMode ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
