// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/billing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { KubernetesNodeData } from "../../kubernetes/v1/nodes.pb";
import { KubernetesPodData } from "../../kubernetes/v1/pods.pb";
import { NodeStatusPubSub } from "../../pubsub/v1/node_status.pb";
import { PodStatusPubSub } from "../../pubsub/v1/pod_status.pb";
import { MachineRate } from "../../usage/v1/rate.pb";
import { Chart } from "./chart.pb";
import { GetPodRequestChartsRequest, GetPodRequestChartsResponse } from "./pod_request.pb";

export const protobufPackage = "chalk.server.v1";

export enum UsageChartPeriod {
  USAGE_CHART_PERIOD_UNSPECIFIED = 0,
  USAGE_CHART_PERIOD_DAILY = 1,
  USAGE_CHART_PERIOD_MONTHLY = 2,
  UNRECOGNIZED = -1,
}

export function usageChartPeriodFromJSON(object: any): UsageChartPeriod {
  switch (object) {
    case 0:
    case "USAGE_CHART_PERIOD_UNSPECIFIED":
      return UsageChartPeriod.USAGE_CHART_PERIOD_UNSPECIFIED;
    case 1:
    case "USAGE_CHART_PERIOD_DAILY":
      return UsageChartPeriod.USAGE_CHART_PERIOD_DAILY;
    case 2:
    case "USAGE_CHART_PERIOD_MONTHLY":
      return UsageChartPeriod.USAGE_CHART_PERIOD_MONTHLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UsageChartPeriod.UNRECOGNIZED;
  }
}

export function usageChartPeriodToJSON(object: UsageChartPeriod): string {
  switch (object) {
    case UsageChartPeriod.USAGE_CHART_PERIOD_UNSPECIFIED:
      return "USAGE_CHART_PERIOD_UNSPECIFIED";
    case UsageChartPeriod.USAGE_CHART_PERIOD_DAILY:
      return "USAGE_CHART_PERIOD_DAILY";
    case UsageChartPeriod.USAGE_CHART_PERIOD_MONTHLY:
      return "USAGE_CHART_PERIOD_MONTHLY";
    case UsageChartPeriod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UsageChartGrouping {
  USAGE_CHART_GROUPING_UNSPECIFIED = 0,
  USAGE_CHART_GROUPING_INSTANCE_TYPE = 1,
  USAGE_CHART_GROUPING_CLUSTER = 2,
  UNRECOGNIZED = -1,
}

export function usageChartGroupingFromJSON(object: any): UsageChartGrouping {
  switch (object) {
    case 0:
    case "USAGE_CHART_GROUPING_UNSPECIFIED":
      return UsageChartGrouping.USAGE_CHART_GROUPING_UNSPECIFIED;
    case 1:
    case "USAGE_CHART_GROUPING_INSTANCE_TYPE":
      return UsageChartGrouping.USAGE_CHART_GROUPING_INSTANCE_TYPE;
    case 2:
    case "USAGE_CHART_GROUPING_CLUSTER":
      return UsageChartGrouping.USAGE_CHART_GROUPING_CLUSTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UsageChartGrouping.UNRECOGNIZED;
  }
}

export function usageChartGroupingToJSON(object: UsageChartGrouping): string {
  switch (object) {
    case UsageChartGrouping.USAGE_CHART_GROUPING_UNSPECIFIED:
      return "USAGE_CHART_GROUPING_UNSPECIFIED";
    case UsageChartGrouping.USAGE_CHART_GROUPING_INSTANCE_TYPE:
      return "USAGE_CHART_GROUPING_INSTANCE_TYPE";
    case UsageChartGrouping.USAGE_CHART_GROUPING_CLUSTER:
      return "USAGE_CHART_GROUPING_CLUSTER";
    case UsageChartGrouping.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetUsageChartRequest {
  startMs?: number | undefined;
  endMs?: number | undefined;
  period?: UsageChartPeriod | undefined;
  grouping?: UsageChartGrouping | undefined;
}

export interface GetUsageChartResponse {
  chart: Chart | undefined;
}

export interface GetUtilizationRatesRequest {
}

export interface GetUtilizationRatesResponse {
  rates: MachineRate[];
}

export interface GetNodesAndPodsRequest {
  namespace?: string | undefined;
  podLabelSelector?: string | undefined;
  environmentId?: string | undefined;
}

export interface GetNodesAndPodsResponse {
  nodes: NodeStatusPubSub[];
  pods: PodStatusPubSub[];
}

export interface GetNodesAndPodsUIRequest {
  namespace?: string | undefined;
  podLabelSelector?: string | undefined;
  environmentId?: string | undefined;
}

export interface GetNodesAndPodsUIResponse {
  nodes: KubernetesNodeData[];
  pods: KubernetesPodData[];
}

export interface SyncUtilizationRequest {
}

export interface SyncUtilizationResponse {
}

function createBaseGetUsageChartRequest(): GetUsageChartRequest {
  return { startMs: undefined, endMs: undefined, period: undefined, grouping: undefined };
}

export const GetUsageChartRequest: MessageFns<GetUsageChartRequest> = {
  encode(message: GetUsageChartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startMs !== undefined) {
      writer.uint32(8).int64(message.startMs);
    }
    if (message.endMs !== undefined) {
      writer.uint32(16).int64(message.endMs);
    }
    if (message.period !== undefined) {
      writer.uint32(24).int32(message.period);
    }
    if (message.grouping !== undefined) {
      writer.uint32(32).int32(message.grouping);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageChartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageChartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startMs = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endMs = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.period = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.grouping = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageChartRequest {
    return {
      startMs: isSet(object.startMs) ? globalThis.Number(object.startMs) : undefined,
      endMs: isSet(object.endMs) ? globalThis.Number(object.endMs) : undefined,
      period: isSet(object.period) ? usageChartPeriodFromJSON(object.period) : undefined,
      grouping: isSet(object.grouping) ? usageChartGroupingFromJSON(object.grouping) : undefined,
    };
  },

  toJSON(message: GetUsageChartRequest): unknown {
    const obj: any = {};
    if (message.startMs !== undefined) {
      obj.startMs = Math.round(message.startMs);
    }
    if (message.endMs !== undefined) {
      obj.endMs = Math.round(message.endMs);
    }
    if (message.period !== undefined) {
      obj.period = usageChartPeriodToJSON(message.period);
    }
    if (message.grouping !== undefined) {
      obj.grouping = usageChartGroupingToJSON(message.grouping);
    }
    return obj;
  },
};

function createBaseGetUsageChartResponse(): GetUsageChartResponse {
  return { chart: undefined };
}

export const GetUsageChartResponse: MessageFns<GetUsageChartResponse> = {
  encode(message: GetUsageChartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chart !== undefined) {
      Chart.encode(message.chart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageChartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageChartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chart = Chart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageChartResponse {
    return { chart: isSet(object.chart) ? Chart.fromJSON(object.chart) : undefined };
  },

  toJSON(message: GetUsageChartResponse): unknown {
    const obj: any = {};
    if (message.chart !== undefined) {
      obj.chart = Chart.toJSON(message.chart);
    }
    return obj;
  },
};

function createBaseGetUtilizationRatesRequest(): GetUtilizationRatesRequest {
  return {};
}

export const GetUtilizationRatesRequest: MessageFns<GetUtilizationRatesRequest> = {
  encode(_: GetUtilizationRatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtilizationRatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtilizationRatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetUtilizationRatesRequest {
    return {};
  },

  toJSON(_: GetUtilizationRatesRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetUtilizationRatesResponse(): GetUtilizationRatesResponse {
  return { rates: [] };
}

export const GetUtilizationRatesResponse: MessageFns<GetUtilizationRatesResponse> = {
  encode(message: GetUtilizationRatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rates) {
      MachineRate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtilizationRatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtilizationRatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rates.push(MachineRate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUtilizationRatesResponse {
    return {
      rates: globalThis.Array.isArray(object?.rates) ? object.rates.map((e: any) => MachineRate.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetUtilizationRatesResponse): unknown {
    const obj: any = {};
    if (message.rates?.length) {
      obj.rates = message.rates.map((e) => MachineRate.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetNodesAndPodsRequest(): GetNodesAndPodsRequest {
  return { namespace: undefined, podLabelSelector: undefined, environmentId: undefined };
}

export const GetNodesAndPodsRequest: MessageFns<GetNodesAndPodsRequest> = {
  encode(message: GetNodesAndPodsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== undefined) {
      writer.uint32(10).string(message.namespace);
    }
    if (message.podLabelSelector !== undefined) {
      writer.uint32(18).string(message.podLabelSelector);
    }
    if (message.environmentId !== undefined) {
      writer.uint32(26).string(message.environmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodesAndPodsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodesAndPodsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.podLabelSelector = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodesAndPodsRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      podLabelSelector: isSet(object.podLabelSelector) ? globalThis.String(object.podLabelSelector) : undefined,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : undefined,
    };
  },

  toJSON(message: GetNodesAndPodsRequest): unknown {
    const obj: any = {};
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.podLabelSelector !== undefined) {
      obj.podLabelSelector = message.podLabelSelector;
    }
    if (message.environmentId !== undefined) {
      obj.environmentId = message.environmentId;
    }
    return obj;
  },
};

function createBaseGetNodesAndPodsResponse(): GetNodesAndPodsResponse {
  return { nodes: [], pods: [] };
}

export const GetNodesAndPodsResponse: MessageFns<GetNodesAndPodsResponse> = {
  encode(message: GetNodesAndPodsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      NodeStatusPubSub.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.pods) {
      PodStatusPubSub.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodesAndPodsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodesAndPodsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(NodeStatusPubSub.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pods.push(PodStatusPubSub.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodesAndPodsResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => NodeStatusPubSub.fromJSON(e)) : [],
      pods: globalThis.Array.isArray(object?.pods) ? object.pods.map((e: any) => PodStatusPubSub.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetNodesAndPodsResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => NodeStatusPubSub.toJSON(e));
    }
    if (message.pods?.length) {
      obj.pods = message.pods.map((e) => PodStatusPubSub.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetNodesAndPodsUIRequest(): GetNodesAndPodsUIRequest {
  return { namespace: undefined, podLabelSelector: undefined, environmentId: undefined };
}

export const GetNodesAndPodsUIRequest: MessageFns<GetNodesAndPodsUIRequest> = {
  encode(message: GetNodesAndPodsUIRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== undefined) {
      writer.uint32(10).string(message.namespace);
    }
    if (message.podLabelSelector !== undefined) {
      writer.uint32(18).string(message.podLabelSelector);
    }
    if (message.environmentId !== undefined) {
      writer.uint32(26).string(message.environmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodesAndPodsUIRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodesAndPodsUIRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.podLabelSelector = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodesAndPodsUIRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      podLabelSelector: isSet(object.podLabelSelector) ? globalThis.String(object.podLabelSelector) : undefined,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : undefined,
    };
  },

  toJSON(message: GetNodesAndPodsUIRequest): unknown {
    const obj: any = {};
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.podLabelSelector !== undefined) {
      obj.podLabelSelector = message.podLabelSelector;
    }
    if (message.environmentId !== undefined) {
      obj.environmentId = message.environmentId;
    }
    return obj;
  },
};

function createBaseGetNodesAndPodsUIResponse(): GetNodesAndPodsUIResponse {
  return { nodes: [], pods: [] };
}

export const GetNodesAndPodsUIResponse: MessageFns<GetNodesAndPodsUIResponse> = {
  encode(message: GetNodesAndPodsUIResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      KubernetesNodeData.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.pods) {
      KubernetesPodData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodesAndPodsUIResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodesAndPodsUIResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(KubernetesNodeData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pods.push(KubernetesPodData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodesAndPodsUIResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes)
        ? object.nodes.map((e: any) => KubernetesNodeData.fromJSON(e))
        : [],
      pods: globalThis.Array.isArray(object?.pods) ? object.pods.map((e: any) => KubernetesPodData.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetNodesAndPodsUIResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => KubernetesNodeData.toJSON(e));
    }
    if (message.pods?.length) {
      obj.pods = message.pods.map((e) => KubernetesPodData.toJSON(e));
    }
    return obj;
  },
};

function createBaseSyncUtilizationRequest(): SyncUtilizationRequest {
  return {};
}

export const SyncUtilizationRequest: MessageFns<SyncUtilizationRequest> = {
  encode(_: SyncUtilizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncUtilizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncUtilizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SyncUtilizationRequest {
    return {};
  },

  toJSON(_: SyncUtilizationRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseSyncUtilizationResponse(): SyncUtilizationResponse {
  return {};
}

export const SyncUtilizationResponse: MessageFns<SyncUtilizationResponse> = {
  encode(_: SyncUtilizationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncUtilizationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncUtilizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SyncUtilizationResponse {
    return {};
  },

  toJSON(_: SyncUtilizationResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

export type BillingServiceService = typeof BillingServiceService;
export const BillingServiceService = {
  /**
   * GetNodesAndPodsUI returns the nodes and pods for the team by default,
   * not just a single environment. To limit the scope, add filters to
   * the request object.
   * Use this endpoint going forward; GetNodesAndPods should be deprecated because
   * it reuses PubSub types that are dangerous to update and are not intended for UI use.
   */
  getNodesAndPodsUi: {
    path: "/chalk.server.v1.BillingService/GetNodesAndPodsUI",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNodesAndPodsUIRequest) => Buffer.from(GetNodesAndPodsUIRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNodesAndPodsUIRequest.decode(value),
    responseSerialize: (value: GetNodesAndPodsUIResponse) =>
      Buffer.from(GetNodesAndPodsUIResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNodesAndPodsUIResponse.decode(value),
  },
  /**
   * GetNodesAndPods returns the nodes and pods for the team by default,
   * not just a single environment. To limit the scope, add filters to
   * the request object.
   */
  getNodesAndPods: {
    path: "/chalk.server.v1.BillingService/GetNodesAndPods",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNodesAndPodsRequest) => Buffer.from(GetNodesAndPodsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNodesAndPodsRequest.decode(value),
    responseSerialize: (value: GetNodesAndPodsResponse) => Buffer.from(GetNodesAndPodsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNodesAndPodsResponse.decode(value),
  },
  /**
   * GetUsageChart shows the Chalk credit usage between a provided start and
   * end period. The usage can be grouped by UsageChartPeriod for daily or
   * monthly usage, and by UsageChartGrouping for instance type or cluster usage.
   */
  getUsageChart: {
    path: "/chalk.server.v1.BillingService/GetUsageChart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUsageChartRequest) => Buffer.from(GetUsageChartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUsageChartRequest.decode(value),
    responseSerialize: (value: GetUsageChartResponse) => Buffer.from(GetUsageChartResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUsageChartResponse.decode(value),
  },
  /**
   * GetUtilizationRates returns the current utilization rates for all
   * instance types.
   */
  getUtilizationRates: {
    path: "/chalk.server.v1.BillingService/GetUtilizationRates",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUtilizationRatesRequest) =>
      Buffer.from(GetUtilizationRatesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUtilizationRatesRequest.decode(value),
    responseSerialize: (value: GetUtilizationRatesResponse) =>
      Buffer.from(GetUtilizationRatesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUtilizationRatesResponse.decode(value),
  },
  getPodRequestCharts: {
    path: "/chalk.server.v1.BillingService/GetPodRequestCharts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPodRequestChartsRequest) =>
      Buffer.from(GetPodRequestChartsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPodRequestChartsRequest.decode(value),
    responseSerialize: (value: GetPodRequestChartsResponse) =>
      Buffer.from(GetPodRequestChartsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPodRequestChartsResponse.decode(value),
  },
  syncUtilization: {
    path: "/chalk.server.v1.BillingService/SyncUtilization",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SyncUtilizationRequest) => Buffer.from(SyncUtilizationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SyncUtilizationRequest.decode(value),
    responseSerialize: (value: SyncUtilizationResponse) => Buffer.from(SyncUtilizationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SyncUtilizationResponse.decode(value),
  },
} as const;

export interface BillingServiceServer extends UntypedServiceImplementation {
  /**
   * GetNodesAndPodsUI returns the nodes and pods for the team by default,
   * not just a single environment. To limit the scope, add filters to
   * the request object.
   * Use this endpoint going forward; GetNodesAndPods should be deprecated because
   * it reuses PubSub types that are dangerous to update and are not intended for UI use.
   */
  getNodesAndPodsUi: handleUnaryCall<GetNodesAndPodsUIRequest, GetNodesAndPodsUIResponse>;
  /**
   * GetNodesAndPods returns the nodes and pods for the team by default,
   * not just a single environment. To limit the scope, add filters to
   * the request object.
   */
  getNodesAndPods: handleUnaryCall<GetNodesAndPodsRequest, GetNodesAndPodsResponse>;
  /**
   * GetUsageChart shows the Chalk credit usage between a provided start and
   * end period. The usage can be grouped by UsageChartPeriod for daily or
   * monthly usage, and by UsageChartGrouping for instance type or cluster usage.
   */
  getUsageChart: handleUnaryCall<GetUsageChartRequest, GetUsageChartResponse>;
  /**
   * GetUtilizationRates returns the current utilization rates for all
   * instance types.
   */
  getUtilizationRates: handleUnaryCall<GetUtilizationRatesRequest, GetUtilizationRatesResponse>;
  getPodRequestCharts: handleUnaryCall<GetPodRequestChartsRequest, GetPodRequestChartsResponse>;
  syncUtilization: handleUnaryCall<SyncUtilizationRequest, SyncUtilizationResponse>;
}

export interface BillingServiceClient extends Client {
  /**
   * GetNodesAndPodsUI returns the nodes and pods for the team by default,
   * not just a single environment. To limit the scope, add filters to
   * the request object.
   * Use this endpoint going forward; GetNodesAndPods should be deprecated because
   * it reuses PubSub types that are dangerous to update and are not intended for UI use.
   */
  getNodesAndPodsUi(
    request: GetNodesAndPodsUIRequest,
    callback: (error: ServiceError | null, response: GetNodesAndPodsUIResponse) => void,
  ): ClientUnaryCall;
  getNodesAndPodsUi(
    request: GetNodesAndPodsUIRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNodesAndPodsUIResponse) => void,
  ): ClientUnaryCall;
  getNodesAndPodsUi(
    request: GetNodesAndPodsUIRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNodesAndPodsUIResponse) => void,
  ): ClientUnaryCall;
  /**
   * GetNodesAndPods returns the nodes and pods for the team by default,
   * not just a single environment. To limit the scope, add filters to
   * the request object.
   */
  getNodesAndPods(
    request: GetNodesAndPodsRequest,
    callback: (error: ServiceError | null, response: GetNodesAndPodsResponse) => void,
  ): ClientUnaryCall;
  getNodesAndPods(
    request: GetNodesAndPodsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNodesAndPodsResponse) => void,
  ): ClientUnaryCall;
  getNodesAndPods(
    request: GetNodesAndPodsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNodesAndPodsResponse) => void,
  ): ClientUnaryCall;
  /**
   * GetUsageChart shows the Chalk credit usage between a provided start and
   * end period. The usage can be grouped by UsageChartPeriod for daily or
   * monthly usage, and by UsageChartGrouping for instance type or cluster usage.
   */
  getUsageChart(
    request: GetUsageChartRequest,
    callback: (error: ServiceError | null, response: GetUsageChartResponse) => void,
  ): ClientUnaryCall;
  getUsageChart(
    request: GetUsageChartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUsageChartResponse) => void,
  ): ClientUnaryCall;
  getUsageChart(
    request: GetUsageChartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUsageChartResponse) => void,
  ): ClientUnaryCall;
  /**
   * GetUtilizationRates returns the current utilization rates for all
   * instance types.
   */
  getUtilizationRates(
    request: GetUtilizationRatesRequest,
    callback: (error: ServiceError | null, response: GetUtilizationRatesResponse) => void,
  ): ClientUnaryCall;
  getUtilizationRates(
    request: GetUtilizationRatesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUtilizationRatesResponse) => void,
  ): ClientUnaryCall;
  getUtilizationRates(
    request: GetUtilizationRatesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUtilizationRatesResponse) => void,
  ): ClientUnaryCall;
  getPodRequestCharts(
    request: GetPodRequestChartsRequest,
    callback: (error: ServiceError | null, response: GetPodRequestChartsResponse) => void,
  ): ClientUnaryCall;
  getPodRequestCharts(
    request: GetPodRequestChartsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPodRequestChartsResponse) => void,
  ): ClientUnaryCall;
  getPodRequestCharts(
    request: GetPodRequestChartsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPodRequestChartsResponse) => void,
  ): ClientUnaryCall;
  syncUtilization(
    request: SyncUtilizationRequest,
    callback: (error: ServiceError | null, response: SyncUtilizationResponse) => void,
  ): ClientUnaryCall;
  syncUtilization(
    request: SyncUtilizationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SyncUtilizationResponse) => void,
  ): ClientUnaryCall;
  syncUtilization(
    request: SyncUtilizationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SyncUtilizationResponse) => void,
  ): ClientUnaryCall;
}

export const BillingServiceClient = makeGenericClientConstructor(
  BillingServiceService,
  "chalk.server.v1.BillingService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): BillingServiceClient;
  service: typeof BillingServiceService;
  serviceName: string;
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
