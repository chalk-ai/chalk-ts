// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/graph.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { ArrowType } from "../../arrow/v1/arrow.pb";
import { Export } from "../../artifacts/v1/export.pb";
import { ChalkError } from "../../common/v1/chalk_error.pb";
import { Graph } from "../../graph/v1/graph.pb";

export const protobufPackage = "chalk.server.v1";

export interface FeatureSQL {
  id: number;
  environmentId: string;
  deploymentId?: string | undefined;
  fqn: string;
  name: string;
  namespace: string;
  maxStaleness?: string | undefined;
  etlOfflineToOnline: boolean;
  description?: string | undefined;
  owner?: string | undefined;
  tags: string[];
  kindEnum: string;
  kind: string;
  wasReset: boolean;
  internalVersion?:
    | number
    | undefined;
  /**
   * string created_at = 14;
   *  string updated_at = 15;
   */
  isSingleton: boolean;
}

export interface GetFeatureSQLResponse {
  features: FeatureSQL[];
}

export interface GetFeatureSQLRequest {
  deploymentId: string;
}

export interface FeatureMetadata {
  fqn: string;
  name: string;
  namespace: string;
  description?: string | undefined;
  owner?: string | undefined;
  tags: string[];
  maxStaleness?: string | undefined;
  etlOfflineToOnline: boolean;
  paDtype: ArrowType | undefined;
  nullable: boolean;
}

export interface GetFeaturesMetadataResponse {
  features: FeatureMetadata[];
  environmentId: string;
  deploymentId: string;
}

export interface GetFeaturesMetadataRequest {
  /**
   * Return one metadata for each feature matching the FQNs in this list.
   * If a feature is not found, an error will be returned.
   */
  fqnsFilter: string[];
}

export interface UpdateGraphRequest {
  deploymentId: string;
  /**
   * Use Export instead, which includes a graph + additional metadata
   *
   * @deprecated
   */
  graph: Graph | undefined;
  chalkpyVersion: string;
  tag?: string | undefined;
  export: Export | undefined;
}

export interface UpdateGraphResponse {
}

export interface GetGraphRequest {
  deploymentId: string;
}

export interface GetGraphResponse {
  /**
   * Use Export instead, which includes a graph + additional metadata
   *
   * @deprecated
   */
  graph: Graph | undefined;
  chalkpyVersion: string;
  tag?: string | undefined;
  export: Export | undefined;
  deploymentId: string;
}

export interface PythonVersion {
  major: number;
  minor: number;
  patch: number;
}

export interface GetCodegenFeaturesFromGraphRequest {
  deploymentId?: string | undefined;
  branch?: string | undefined;
  pythonVersion?: PythonVersion | undefined;
}

export interface GetCodegenFeaturesFromGraphResponse {
  codegen: string;
  errors: ChalkError[];
}

function createBaseFeatureSQL(): FeatureSQL {
  return {
    id: 0,
    environmentId: "",
    deploymentId: undefined,
    fqn: "",
    name: "",
    namespace: "",
    maxStaleness: undefined,
    etlOfflineToOnline: false,
    description: undefined,
    owner: undefined,
    tags: [],
    kindEnum: "",
    kind: "",
    wasReset: false,
    internalVersion: undefined,
    isSingleton: false,
  };
}

export const FeatureSQL: MessageFns<FeatureSQL> = {
  encode(message: FeatureSQL, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== undefined) {
      writer.uint32(26).string(message.deploymentId);
    }
    if (message.fqn !== "") {
      writer.uint32(34).string(message.fqn);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(50).string(message.namespace);
    }
    if (message.maxStaleness !== undefined) {
      writer.uint32(58).string(message.maxStaleness);
    }
    if (message.etlOfflineToOnline !== false) {
      writer.uint32(64).bool(message.etlOfflineToOnline);
    }
    if (message.description !== undefined) {
      writer.uint32(74).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(82).string(message.owner);
    }
    for (const v of message.tags) {
      writer.uint32(90).string(v!);
    }
    if (message.kindEnum !== "") {
      writer.uint32(98).string(message.kindEnum);
    }
    if (message.kind !== "") {
      writer.uint32(106).string(message.kind);
    }
    if (message.wasReset !== false) {
      writer.uint32(112).bool(message.wasReset);
    }
    if (message.internalVersion !== undefined) {
      writer.uint32(120).int64(message.internalVersion);
    }
    if (message.isSingleton !== false) {
      writer.uint32(128).bool(message.isSingleton);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureSQL {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureSQL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxStaleness = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kindEnum = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.wasReset = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.internalVersion = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isSingleton = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureSQL {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      maxStaleness: isSet(object.maxStaleness) ? globalThis.String(object.maxStaleness) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      kindEnum: isSet(object.kindEnum) ? globalThis.String(object.kindEnum) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      wasReset: isSet(object.wasReset) ? globalThis.Boolean(object.wasReset) : false,
      internalVersion: isSet(object.internalVersion) ? globalThis.Number(object.internalVersion) : undefined,
      isSingleton: isSet(object.isSingleton) ? globalThis.Boolean(object.isSingleton) : false,
    };
  },

  toJSON(message: FeatureSQL): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.maxStaleness !== undefined) {
      obj.maxStaleness = message.maxStaleness;
    }
    if (message.etlOfflineToOnline !== false) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.kindEnum !== "") {
      obj.kindEnum = message.kindEnum;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.wasReset !== false) {
      obj.wasReset = message.wasReset;
    }
    if (message.internalVersion !== undefined) {
      obj.internalVersion = Math.round(message.internalVersion);
    }
    if (message.isSingleton !== false) {
      obj.isSingleton = message.isSingleton;
    }
    return obj;
  },
};

function createBaseGetFeatureSQLResponse(): GetFeatureSQLResponse {
  return { features: [] };
}

export const GetFeatureSQLResponse: MessageFns<GetFeatureSQLResponse> = {
  encode(message: GetFeatureSQLResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.features) {
      FeatureSQL.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureSQLResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureSQLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features.push(FeatureSQL.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureSQLResponse {
    return {
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => FeatureSQL.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetFeatureSQLResponse): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features.map((e) => FeatureSQL.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetFeatureSQLRequest(): GetFeatureSQLRequest {
  return { deploymentId: "" };
}

export const GetFeatureSQLRequest: MessageFns<GetFeatureSQLRequest> = {
  encode(message: GetFeatureSQLRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureSQLRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureSQLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureSQLRequest {
    return { deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "" };
  },

  toJSON(message: GetFeatureSQLRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },
};

function createBaseFeatureMetadata(): FeatureMetadata {
  return {
    fqn: "",
    name: "",
    namespace: "",
    description: undefined,
    owner: undefined,
    tags: [],
    maxStaleness: undefined,
    etlOfflineToOnline: false,
    paDtype: undefined,
    nullable: false,
  };
}

export const FeatureMetadata: MessageFns<FeatureMetadata> = {
  encode(message: FeatureMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(42).string(message.owner);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.maxStaleness !== undefined) {
      writer.uint32(58).string(message.maxStaleness);
    }
    if (message.etlOfflineToOnline !== false) {
      writer.uint32(64).bool(message.etlOfflineToOnline);
    }
    if (message.paDtype !== undefined) {
      ArrowType.encode(message.paDtype, writer.uint32(74).fork()).join();
    }
    if (message.nullable !== false) {
      writer.uint32(80).bool(message.nullable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxStaleness = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.paDtype = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureMetadata {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      maxStaleness: isSet(object.maxStaleness) ? globalThis.String(object.maxStaleness) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : false,
      paDtype: isSet(object.paDtype) ? ArrowType.fromJSON(object.paDtype) : undefined,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
    };
  },

  toJSON(message: FeatureMetadata): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.maxStaleness !== undefined) {
      obj.maxStaleness = message.maxStaleness;
    }
    if (message.etlOfflineToOnline !== false) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.paDtype !== undefined) {
      obj.paDtype = ArrowType.toJSON(message.paDtype);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    return obj;
  },
};

function createBaseGetFeaturesMetadataResponse(): GetFeaturesMetadataResponse {
  return { features: [], environmentId: "", deploymentId: "" };
}

export const GetFeaturesMetadataResponse: MessageFns<GetFeaturesMetadataResponse> = {
  encode(message: GetFeaturesMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.features) {
      FeatureMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== "") {
      writer.uint32(26).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeaturesMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeaturesMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features.push(FeatureMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeaturesMetadataResponse {
    return {
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => FeatureMetadata.fromJSON(e))
        : [],
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
    };
  },

  toJSON(message: GetFeaturesMetadataResponse): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features.map((e) => FeatureMetadata.toJSON(e));
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },
};

function createBaseGetFeaturesMetadataRequest(): GetFeaturesMetadataRequest {
  return { fqnsFilter: [] };
}

export const GetFeaturesMetadataRequest: MessageFns<GetFeaturesMetadataRequest> = {
  encode(message: GetFeaturesMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fqnsFilter) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeaturesMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeaturesMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqnsFilter.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeaturesMetadataRequest {
    return {
      fqnsFilter: globalThis.Array.isArray(object?.fqnsFilter)
        ? object.fqnsFilter.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetFeaturesMetadataRequest): unknown {
    const obj: any = {};
    if (message.fqnsFilter?.length) {
      obj.fqnsFilter = message.fqnsFilter;
    }
    return obj;
  },
};

function createBaseUpdateGraphRequest(): UpdateGraphRequest {
  return { deploymentId: "", graph: undefined, chalkpyVersion: "", tag: undefined, export: undefined };
}

export const UpdateGraphRequest: MessageFns<UpdateGraphRequest> = {
  encode(message: UpdateGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.graph !== undefined) {
      Graph.encode(message.graph, writer.uint32(18).fork()).join();
    }
    if (message.chalkpyVersion !== "") {
      writer.uint32(26).string(message.chalkpyVersion);
    }
    if (message.tag !== undefined) {
      writer.uint32(34).string(message.tag);
    }
    if (message.export !== undefined) {
      Export.encode(message.export, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.graph = Graph.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chalkpyVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.export = Export.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGraphRequest {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      graph: isSet(object.graph) ? Graph.fromJSON(object.graph) : undefined,
      chalkpyVersion: isSet(object.chalkpyVersion) ? globalThis.String(object.chalkpyVersion) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      export: isSet(object.export) ? Export.fromJSON(object.export) : undefined,
    };
  },

  toJSON(message: UpdateGraphRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.graph !== undefined) {
      obj.graph = Graph.toJSON(message.graph);
    }
    if (message.chalkpyVersion !== "") {
      obj.chalkpyVersion = message.chalkpyVersion;
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.export !== undefined) {
      obj.export = Export.toJSON(message.export);
    }
    return obj;
  },
};

function createBaseUpdateGraphResponse(): UpdateGraphResponse {
  return {};
}

export const UpdateGraphResponse: MessageFns<UpdateGraphResponse> = {
  encode(_: UpdateGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateGraphResponse {
    return {};
  },

  toJSON(_: UpdateGraphResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetGraphRequest(): GetGraphRequest {
  return { deploymentId: "" };
}

export const GetGraphRequest: MessageFns<GetGraphRequest> = {
  encode(message: GetGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGraphRequest {
    return { deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "" };
  },

  toJSON(message: GetGraphRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },
};

function createBaseGetGraphResponse(): GetGraphResponse {
  return { graph: undefined, chalkpyVersion: "", tag: undefined, export: undefined, deploymentId: "" };
}

export const GetGraphResponse: MessageFns<GetGraphResponse> = {
  encode(message: GetGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.graph !== undefined) {
      Graph.encode(message.graph, writer.uint32(10).fork()).join();
    }
    if (message.chalkpyVersion !== "") {
      writer.uint32(18).string(message.chalkpyVersion);
    }
    if (message.tag !== undefined) {
      writer.uint32(26).string(message.tag);
    }
    if (message.export !== undefined) {
      Export.encode(message.export, writer.uint32(34).fork()).join();
    }
    if (message.deploymentId !== "") {
      writer.uint32(42).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.graph = Graph.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chalkpyVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.export = Export.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGraphResponse {
    return {
      graph: isSet(object.graph) ? Graph.fromJSON(object.graph) : undefined,
      chalkpyVersion: isSet(object.chalkpyVersion) ? globalThis.String(object.chalkpyVersion) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      export: isSet(object.export) ? Export.fromJSON(object.export) : undefined,
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
    };
  },

  toJSON(message: GetGraphResponse): unknown {
    const obj: any = {};
    if (message.graph !== undefined) {
      obj.graph = Graph.toJSON(message.graph);
    }
    if (message.chalkpyVersion !== "") {
      obj.chalkpyVersion = message.chalkpyVersion;
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.export !== undefined) {
      obj.export = Export.toJSON(message.export);
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },
};

function createBasePythonVersion(): PythonVersion {
  return { major: 0, minor: 0, patch: 0 };
}

export const PythonVersion: MessageFns<PythonVersion> = {
  encode(message: PythonVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.major !== 0) {
      writer.uint32(8).int64(message.major);
    }
    if (message.minor !== 0) {
      writer.uint32(16).int64(message.minor);
    }
    if (message.patch !== 0) {
      writer.uint32(24).int64(message.patch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PythonVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePythonVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.major = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minor = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.patch = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PythonVersion {
    return {
      major: isSet(object.major) ? globalThis.Number(object.major) : 0,
      minor: isSet(object.minor) ? globalThis.Number(object.minor) : 0,
      patch: isSet(object.patch) ? globalThis.Number(object.patch) : 0,
    };
  },

  toJSON(message: PythonVersion): unknown {
    const obj: any = {};
    if (message.major !== 0) {
      obj.major = Math.round(message.major);
    }
    if (message.minor !== 0) {
      obj.minor = Math.round(message.minor);
    }
    if (message.patch !== 0) {
      obj.patch = Math.round(message.patch);
    }
    return obj;
  },
};

function createBaseGetCodegenFeaturesFromGraphRequest(): GetCodegenFeaturesFromGraphRequest {
  return { deploymentId: undefined, branch: undefined, pythonVersion: undefined };
}

export const GetCodegenFeaturesFromGraphRequest: MessageFns<GetCodegenFeaturesFromGraphRequest> = {
  encode(message: GetCodegenFeaturesFromGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== undefined) {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.branch !== undefined) {
      writer.uint32(18).string(message.branch);
    }
    if (message.pythonVersion !== undefined) {
      PythonVersion.encode(message.pythonVersion, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCodegenFeaturesFromGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCodegenFeaturesFromGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pythonVersion = PythonVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCodegenFeaturesFromGraphRequest {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
      pythonVersion: isSet(object.pythonVersion) ? PythonVersion.fromJSON(object.pythonVersion) : undefined,
    };
  },

  toJSON(message: GetCodegenFeaturesFromGraphRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    if (message.pythonVersion !== undefined) {
      obj.pythonVersion = PythonVersion.toJSON(message.pythonVersion);
    }
    return obj;
  },
};

function createBaseGetCodegenFeaturesFromGraphResponse(): GetCodegenFeaturesFromGraphResponse {
  return { codegen: "", errors: [] };
}

export const GetCodegenFeaturesFromGraphResponse: MessageFns<GetCodegenFeaturesFromGraphResponse> = {
  encode(message: GetCodegenFeaturesFromGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codegen !== "") {
      writer.uint32(10).string(message.codegen);
    }
    for (const v of message.errors) {
      ChalkError.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCodegenFeaturesFromGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCodegenFeaturesFromGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.codegen = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errors.push(ChalkError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCodegenFeaturesFromGraphResponse {
    return {
      codegen: isSet(object.codegen) ? globalThis.String(object.codegen) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ChalkError.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCodegenFeaturesFromGraphResponse): unknown {
    const obj: any = {};
    if (message.codegen !== "") {
      obj.codegen = message.codegen;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ChalkError.toJSON(e));
    }
    return obj;
  },
};

export type GraphServiceService = typeof GraphServiceService;
export const GraphServiceService = {
  /** GetFeatureSQL returns the feature SQLs for a given deployment. */
  getFeatureSql: {
    path: "/chalk.server.v1.GraphService/GetFeatureSQL",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFeatureSQLRequest) => Buffer.from(GetFeatureSQLRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFeatureSQLRequest.decode(value),
    responseSerialize: (value: GetFeatureSQLResponse) => Buffer.from(GetFeatureSQLResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFeatureSQLResponse.decode(value),
  },
  getFeaturesMetadata: {
    path: "/chalk.server.v1.GraphService/GetFeaturesMetadata",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFeaturesMetadataRequest) =>
      Buffer.from(GetFeaturesMetadataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFeaturesMetadataRequest.decode(value),
    responseSerialize: (value: GetFeaturesMetadataResponse) =>
      Buffer.from(GetFeaturesMetadataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFeaturesMetadataResponse.decode(value),
  },
  getGraph: {
    path: "/chalk.server.v1.GraphService/GetGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGraphRequest) => Buffer.from(GetGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetGraphRequest.decode(value),
    responseSerialize: (value: GetGraphResponse) => Buffer.from(GetGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetGraphResponse.decode(value),
  },
  /** UpdateGraph uploads the protobuf graph for a given deployment. */
  updateGraph: {
    path: "/chalk.server.v1.GraphService/UpdateGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateGraphRequest) => Buffer.from(UpdateGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateGraphRequest.decode(value),
    responseSerialize: (value: UpdateGraphResponse) => Buffer.from(UpdateGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateGraphResponse.decode(value),
  },
  /** GetCodegenFeaturesFromGraph returns Chalk features generated from the protograph */
  getCodegenFeaturesFromGraph: {
    path: "/chalk.server.v1.GraphService/GetCodegenFeaturesFromGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCodegenFeaturesFromGraphRequest) =>
      Buffer.from(GetCodegenFeaturesFromGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCodegenFeaturesFromGraphRequest.decode(value),
    responseSerialize: (value: GetCodegenFeaturesFromGraphResponse) =>
      Buffer.from(GetCodegenFeaturesFromGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCodegenFeaturesFromGraphResponse.decode(value),
  },
} as const;

export interface GraphServiceServer extends UntypedServiceImplementation {
  /** GetFeatureSQL returns the feature SQLs for a given deployment. */
  getFeatureSql: handleUnaryCall<GetFeatureSQLRequest, GetFeatureSQLResponse>;
  getFeaturesMetadata: handleUnaryCall<GetFeaturesMetadataRequest, GetFeaturesMetadataResponse>;
  getGraph: handleUnaryCall<GetGraphRequest, GetGraphResponse>;
  /** UpdateGraph uploads the protobuf graph for a given deployment. */
  updateGraph: handleUnaryCall<UpdateGraphRequest, UpdateGraphResponse>;
  /** GetCodegenFeaturesFromGraph returns Chalk features generated from the protograph */
  getCodegenFeaturesFromGraph: handleUnaryCall<GetCodegenFeaturesFromGraphRequest, GetCodegenFeaturesFromGraphResponse>;
}

export interface GraphServiceClient extends Client {
  /** GetFeatureSQL returns the feature SQLs for a given deployment. */
  getFeatureSql(
    request: GetFeatureSQLRequest,
    callback: (error: ServiceError | null, response: GetFeatureSQLResponse) => void,
  ): ClientUnaryCall;
  getFeatureSql(
    request: GetFeatureSQLRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFeatureSQLResponse) => void,
  ): ClientUnaryCall;
  getFeatureSql(
    request: GetFeatureSQLRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFeatureSQLResponse) => void,
  ): ClientUnaryCall;
  getFeaturesMetadata(
    request: GetFeaturesMetadataRequest,
    callback: (error: ServiceError | null, response: GetFeaturesMetadataResponse) => void,
  ): ClientUnaryCall;
  getFeaturesMetadata(
    request: GetFeaturesMetadataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFeaturesMetadataResponse) => void,
  ): ClientUnaryCall;
  getFeaturesMetadata(
    request: GetFeaturesMetadataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFeaturesMetadataResponse) => void,
  ): ClientUnaryCall;
  getGraph(
    request: GetGraphRequest,
    callback: (error: ServiceError | null, response: GetGraphResponse) => void,
  ): ClientUnaryCall;
  getGraph(
    request: GetGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetGraphResponse) => void,
  ): ClientUnaryCall;
  getGraph(
    request: GetGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetGraphResponse) => void,
  ): ClientUnaryCall;
  /** UpdateGraph uploads the protobuf graph for a given deployment. */
  updateGraph(
    request: UpdateGraphRequest,
    callback: (error: ServiceError | null, response: UpdateGraphResponse) => void,
  ): ClientUnaryCall;
  updateGraph(
    request: UpdateGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateGraphResponse) => void,
  ): ClientUnaryCall;
  updateGraph(
    request: UpdateGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateGraphResponse) => void,
  ): ClientUnaryCall;
  /** GetCodegenFeaturesFromGraph returns Chalk features generated from the protograph */
  getCodegenFeaturesFromGraph(
    request: GetCodegenFeaturesFromGraphRequest,
    callback: (error: ServiceError | null, response: GetCodegenFeaturesFromGraphResponse) => void,
  ): ClientUnaryCall;
  getCodegenFeaturesFromGraph(
    request: GetCodegenFeaturesFromGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCodegenFeaturesFromGraphResponse) => void,
  ): ClientUnaryCall;
  getCodegenFeaturesFromGraph(
    request: GetCodegenFeaturesFromGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCodegenFeaturesFromGraphResponse) => void,
  ): ClientUnaryCall;
}

export const GraphServiceClient = makeGenericClientConstructor(
  GraphServiceService,
  "chalk.server.v1.GraphService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GraphServiceClient;
  service: typeof GraphServiceService;
  serviceName: string;
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
