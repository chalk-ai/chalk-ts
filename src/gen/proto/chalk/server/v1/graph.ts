// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/graph.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Export } from "../../artifacts/v1/export";
import { ChalkError } from "../../common/v1/chalk_error";
import { Graph } from "../../graph/v1/graph";

export const protobufPackage = "chalk.server.v1";

export interface FeatureSQL {
  id: number;
  environmentId: string;
  deploymentId?: string | undefined;
  fqn: string;
  name: string;
  namespace: string;
  maxStaleness?: string | undefined;
  etlOfflineToOnline: boolean;
  description?: string | undefined;
  owner?: string | undefined;
  tags: string[];
  kindEnum: string;
  kind: string;
  wasReset: boolean;
  internalVersion?:
    | number
    | undefined;
  /**
   * string created_at = 14;
   *  string updated_at = 15;
   */
  isSingleton: boolean;
}

export interface GetFeatureSQLResponse {
  features: FeatureSQL[];
}

export interface GetFeatureSQLRequest {
  deploymentId: string;
}

export interface FeatureMetadata {
  fqn: string;
  name: string;
  namespace: string;
  description?: string | undefined;
  owner?: string | undefined;
  tags: string[];
  maxStaleness?: string | undefined;
  etlOfflineToOnline: boolean;
}

export interface GetFeaturesMetadataResponse {
  features: FeatureMetadata[];
  environmentId: string;
  deploymentId: string;
}

export interface GetFeaturesMetadataRequest {
}

export interface UpdateGraphRequest {
  deploymentId: string;
  /**
   * Use Export instead, which includes a graph + additional metadata
   *
   * @deprecated
   */
  graph: Graph | undefined;
  chalkpyVersion: string;
  tag?: string | undefined;
  export: Export | undefined;
}

export interface UpdateGraphResponse {
}

export interface GetGraphRequest {
  deploymentId: string;
}

export interface GetGraphResponse {
  /**
   * Use Export instead, which includes a graph + additional metadata
   *
   * @deprecated
   */
  graph: Graph | undefined;
  chalkpyVersion: string;
  tag?: string | undefined;
  export: Export | undefined;
}

export interface PythonVersion {
  major: number;
  minor: number;
  patch: number;
}

export interface GetCodegenFeaturesFromGraphRequest {
  deploymentId?: string | undefined;
  branch?: string | undefined;
  pythonVersion?: PythonVersion | undefined;
}

export interface GetCodegenFeaturesFromGraphResponse {
  codegen: string;
  errors: ChalkError[];
}

function createBaseFeatureSQL(): FeatureSQL {
  return {
    id: 0,
    environmentId: "",
    deploymentId: undefined,
    fqn: "",
    name: "",
    namespace: "",
    maxStaleness: undefined,
    etlOfflineToOnline: false,
    description: undefined,
    owner: undefined,
    tags: [],
    kindEnum: "",
    kind: "",
    wasReset: false,
    internalVersion: undefined,
    isSingleton: false,
  };
}

export const FeatureSQL: MessageFns<FeatureSQL> = {
  encode(message: FeatureSQL, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== undefined) {
      writer.uint32(26).string(message.deploymentId);
    }
    if (message.fqn !== "") {
      writer.uint32(34).string(message.fqn);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(50).string(message.namespace);
    }
    if (message.maxStaleness !== undefined) {
      writer.uint32(58).string(message.maxStaleness);
    }
    if (message.etlOfflineToOnline !== false) {
      writer.uint32(64).bool(message.etlOfflineToOnline);
    }
    if (message.description !== undefined) {
      writer.uint32(74).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(82).string(message.owner);
    }
    for (const v of message.tags) {
      writer.uint32(90).string(v!);
    }
    if (message.kindEnum !== "") {
      writer.uint32(98).string(message.kindEnum);
    }
    if (message.kind !== "") {
      writer.uint32(106).string(message.kind);
    }
    if (message.wasReset !== false) {
      writer.uint32(112).bool(message.wasReset);
    }
    if (message.internalVersion !== undefined) {
      writer.uint32(120).int64(message.internalVersion);
    }
    if (message.isSingleton !== false) {
      writer.uint32(128).bool(message.isSingleton);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureSQL {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureSQL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxStaleness = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kindEnum = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.wasReset = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.internalVersion = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isSingleton = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureSQL {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      maxStaleness: isSet(object.maxStaleness) ? globalThis.String(object.maxStaleness) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      kindEnum: isSet(object.kindEnum) ? globalThis.String(object.kindEnum) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      wasReset: isSet(object.wasReset) ? globalThis.Boolean(object.wasReset) : false,
      internalVersion: isSet(object.internalVersion) ? globalThis.Number(object.internalVersion) : undefined,
      isSingleton: isSet(object.isSingleton) ? globalThis.Boolean(object.isSingleton) : false,
    };
  },

  toJSON(message: FeatureSQL): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.maxStaleness !== undefined) {
      obj.maxStaleness = message.maxStaleness;
    }
    if (message.etlOfflineToOnline !== false) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.kindEnum !== "") {
      obj.kindEnum = message.kindEnum;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.wasReset !== false) {
      obj.wasReset = message.wasReset;
    }
    if (message.internalVersion !== undefined) {
      obj.internalVersion = Math.round(message.internalVersion);
    }
    if (message.isSingleton !== false) {
      obj.isSingleton = message.isSingleton;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureSQL>, I>>(base?: I): FeatureSQL {
    return FeatureSQL.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureSQL>, I>>(object: I): FeatureSQL {
    const message = createBaseFeatureSQL();
    message.id = object.id ?? 0;
    message.environmentId = object.environmentId ?? "";
    message.deploymentId = object.deploymentId ?? undefined;
    message.fqn = object.fqn ?? "";
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.maxStaleness = object.maxStaleness ?? undefined;
    message.etlOfflineToOnline = object.etlOfflineToOnline ?? false;
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.kindEnum = object.kindEnum ?? "";
    message.kind = object.kind ?? "";
    message.wasReset = object.wasReset ?? false;
    message.internalVersion = object.internalVersion ?? undefined;
    message.isSingleton = object.isSingleton ?? false;
    return message;
  },
};

function createBaseGetFeatureSQLResponse(): GetFeatureSQLResponse {
  return { features: [] };
}

export const GetFeatureSQLResponse: MessageFns<GetFeatureSQLResponse> = {
  encode(message: GetFeatureSQLResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.features) {
      FeatureSQL.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureSQLResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureSQLResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features.push(FeatureSQL.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureSQLResponse {
    return {
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => FeatureSQL.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetFeatureSQLResponse): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features.map((e) => FeatureSQL.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeatureSQLResponse>, I>>(base?: I): GetFeatureSQLResponse {
    return GetFeatureSQLResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeatureSQLResponse>, I>>(object: I): GetFeatureSQLResponse {
    const message = createBaseGetFeatureSQLResponse();
    message.features = object.features?.map((e) => FeatureSQL.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetFeatureSQLRequest(): GetFeatureSQLRequest {
  return { deploymentId: "" };
}

export const GetFeatureSQLRequest: MessageFns<GetFeatureSQLRequest> = {
  encode(message: GetFeatureSQLRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeatureSQLRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeatureSQLRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeatureSQLRequest {
    return { deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "" };
  },

  toJSON(message: GetFeatureSQLRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeatureSQLRequest>, I>>(base?: I): GetFeatureSQLRequest {
    return GetFeatureSQLRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeatureSQLRequest>, I>>(object: I): GetFeatureSQLRequest {
    const message = createBaseGetFeatureSQLRequest();
    message.deploymentId = object.deploymentId ?? "";
    return message;
  },
};

function createBaseFeatureMetadata(): FeatureMetadata {
  return {
    fqn: "",
    name: "",
    namespace: "",
    description: undefined,
    owner: undefined,
    tags: [],
    maxStaleness: undefined,
    etlOfflineToOnline: false,
  };
}

export const FeatureMetadata: MessageFns<FeatureMetadata> = {
  encode(message: FeatureMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(42).string(message.owner);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.maxStaleness !== undefined) {
      writer.uint32(58).string(message.maxStaleness);
    }
    if (message.etlOfflineToOnline !== false) {
      writer.uint32(64).bool(message.etlOfflineToOnline);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxStaleness = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureMetadata {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      maxStaleness: isSet(object.maxStaleness) ? globalThis.String(object.maxStaleness) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : false,
    };
  },

  toJSON(message: FeatureMetadata): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.maxStaleness !== undefined) {
      obj.maxStaleness = message.maxStaleness;
    }
    if (message.etlOfflineToOnline !== false) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureMetadata>, I>>(base?: I): FeatureMetadata {
    return FeatureMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureMetadata>, I>>(object: I): FeatureMetadata {
    const message = createBaseFeatureMetadata();
    message.fqn = object.fqn ?? "";
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.maxStaleness = object.maxStaleness ?? undefined;
    message.etlOfflineToOnline = object.etlOfflineToOnline ?? false;
    return message;
  },
};

function createBaseGetFeaturesMetadataResponse(): GetFeaturesMetadataResponse {
  return { features: [], environmentId: "", deploymentId: "" };
}

export const GetFeaturesMetadataResponse: MessageFns<GetFeaturesMetadataResponse> = {
  encode(message: GetFeaturesMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.features) {
      FeatureMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== "") {
      writer.uint32(26).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeaturesMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeaturesMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features.push(FeatureMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFeaturesMetadataResponse {
    return {
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => FeatureMetadata.fromJSON(e))
        : [],
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
    };
  },

  toJSON(message: GetFeaturesMetadataResponse): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features.map((e) => FeatureMetadata.toJSON(e));
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeaturesMetadataResponse>, I>>(base?: I): GetFeaturesMetadataResponse {
    return GetFeaturesMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeaturesMetadataResponse>, I>>(object: I): GetFeaturesMetadataResponse {
    const message = createBaseGetFeaturesMetadataResponse();
    message.features = object.features?.map((e) => FeatureMetadata.fromPartial(e)) || [];
    message.environmentId = object.environmentId ?? "";
    message.deploymentId = object.deploymentId ?? "";
    return message;
  },
};

function createBaseGetFeaturesMetadataRequest(): GetFeaturesMetadataRequest {
  return {};
}

export const GetFeaturesMetadataRequest: MessageFns<GetFeaturesMetadataRequest> = {
  encode(_: GetFeaturesMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFeaturesMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeaturesMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetFeaturesMetadataRequest {
    return {};
  },

  toJSON(_: GetFeaturesMetadataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFeaturesMetadataRequest>, I>>(base?: I): GetFeaturesMetadataRequest {
    return GetFeaturesMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFeaturesMetadataRequest>, I>>(_: I): GetFeaturesMetadataRequest {
    const message = createBaseGetFeaturesMetadataRequest();
    return message;
  },
};

function createBaseUpdateGraphRequest(): UpdateGraphRequest {
  return { deploymentId: "", graph: undefined, chalkpyVersion: "", tag: undefined, export: undefined };
}

export const UpdateGraphRequest: MessageFns<UpdateGraphRequest> = {
  encode(message: UpdateGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.graph !== undefined) {
      Graph.encode(message.graph, writer.uint32(18).fork()).join();
    }
    if (message.chalkpyVersion !== "") {
      writer.uint32(26).string(message.chalkpyVersion);
    }
    if (message.tag !== undefined) {
      writer.uint32(34).string(message.tag);
    }
    if (message.export !== undefined) {
      Export.encode(message.export, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.graph = Graph.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chalkpyVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.export = Export.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGraphRequest {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      graph: isSet(object.graph) ? Graph.fromJSON(object.graph) : undefined,
      chalkpyVersion: isSet(object.chalkpyVersion) ? globalThis.String(object.chalkpyVersion) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      export: isSet(object.export) ? Export.fromJSON(object.export) : undefined,
    };
  },

  toJSON(message: UpdateGraphRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.graph !== undefined) {
      obj.graph = Graph.toJSON(message.graph);
    }
    if (message.chalkpyVersion !== "") {
      obj.chalkpyVersion = message.chalkpyVersion;
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.export !== undefined) {
      obj.export = Export.toJSON(message.export);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateGraphRequest>, I>>(base?: I): UpdateGraphRequest {
    return UpdateGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateGraphRequest>, I>>(object: I): UpdateGraphRequest {
    const message = createBaseUpdateGraphRequest();
    message.deploymentId = object.deploymentId ?? "";
    message.graph = (object.graph !== undefined && object.graph !== null) ? Graph.fromPartial(object.graph) : undefined;
    message.chalkpyVersion = object.chalkpyVersion ?? "";
    message.tag = object.tag ?? undefined;
    message.export = (object.export !== undefined && object.export !== null)
      ? Export.fromPartial(object.export)
      : undefined;
    return message;
  },
};

function createBaseUpdateGraphResponse(): UpdateGraphResponse {
  return {};
}

export const UpdateGraphResponse: MessageFns<UpdateGraphResponse> = {
  encode(_: UpdateGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateGraphResponse {
    return {};
  },

  toJSON(_: UpdateGraphResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateGraphResponse>, I>>(base?: I): UpdateGraphResponse {
    return UpdateGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateGraphResponse>, I>>(_: I): UpdateGraphResponse {
    const message = createBaseUpdateGraphResponse();
    return message;
  },
};

function createBaseGetGraphRequest(): GetGraphRequest {
  return { deploymentId: "" };
}

export const GetGraphRequest: MessageFns<GetGraphRequest> = {
  encode(message: GetGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGraphRequest {
    return { deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "" };
  },

  toJSON(message: GetGraphRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGraphRequest>, I>>(base?: I): GetGraphRequest {
    return GetGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGraphRequest>, I>>(object: I): GetGraphRequest {
    const message = createBaseGetGraphRequest();
    message.deploymentId = object.deploymentId ?? "";
    return message;
  },
};

function createBaseGetGraphResponse(): GetGraphResponse {
  return { graph: undefined, chalkpyVersion: "", tag: undefined, export: undefined };
}

export const GetGraphResponse: MessageFns<GetGraphResponse> = {
  encode(message: GetGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.graph !== undefined) {
      Graph.encode(message.graph, writer.uint32(10).fork()).join();
    }
    if (message.chalkpyVersion !== "") {
      writer.uint32(18).string(message.chalkpyVersion);
    }
    if (message.tag !== undefined) {
      writer.uint32(26).string(message.tag);
    }
    if (message.export !== undefined) {
      Export.encode(message.export, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.graph = Graph.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chalkpyVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.export = Export.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGraphResponse {
    return {
      graph: isSet(object.graph) ? Graph.fromJSON(object.graph) : undefined,
      chalkpyVersion: isSet(object.chalkpyVersion) ? globalThis.String(object.chalkpyVersion) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      export: isSet(object.export) ? Export.fromJSON(object.export) : undefined,
    };
  },

  toJSON(message: GetGraphResponse): unknown {
    const obj: any = {};
    if (message.graph !== undefined) {
      obj.graph = Graph.toJSON(message.graph);
    }
    if (message.chalkpyVersion !== "") {
      obj.chalkpyVersion = message.chalkpyVersion;
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.export !== undefined) {
      obj.export = Export.toJSON(message.export);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGraphResponse>, I>>(base?: I): GetGraphResponse {
    return GetGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGraphResponse>, I>>(object: I): GetGraphResponse {
    const message = createBaseGetGraphResponse();
    message.graph = (object.graph !== undefined && object.graph !== null) ? Graph.fromPartial(object.graph) : undefined;
    message.chalkpyVersion = object.chalkpyVersion ?? "";
    message.tag = object.tag ?? undefined;
    message.export = (object.export !== undefined && object.export !== null)
      ? Export.fromPartial(object.export)
      : undefined;
    return message;
  },
};

function createBasePythonVersion(): PythonVersion {
  return { major: 0, minor: 0, patch: 0 };
}

export const PythonVersion: MessageFns<PythonVersion> = {
  encode(message: PythonVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.major !== 0) {
      writer.uint32(8).int64(message.major);
    }
    if (message.minor !== 0) {
      writer.uint32(16).int64(message.minor);
    }
    if (message.patch !== 0) {
      writer.uint32(24).int64(message.patch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PythonVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePythonVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.major = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minor = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.patch = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PythonVersion {
    return {
      major: isSet(object.major) ? globalThis.Number(object.major) : 0,
      minor: isSet(object.minor) ? globalThis.Number(object.minor) : 0,
      patch: isSet(object.patch) ? globalThis.Number(object.patch) : 0,
    };
  },

  toJSON(message: PythonVersion): unknown {
    const obj: any = {};
    if (message.major !== 0) {
      obj.major = Math.round(message.major);
    }
    if (message.minor !== 0) {
      obj.minor = Math.round(message.minor);
    }
    if (message.patch !== 0) {
      obj.patch = Math.round(message.patch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PythonVersion>, I>>(base?: I): PythonVersion {
    return PythonVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PythonVersion>, I>>(object: I): PythonVersion {
    const message = createBasePythonVersion();
    message.major = object.major ?? 0;
    message.minor = object.minor ?? 0;
    message.patch = object.patch ?? 0;
    return message;
  },
};

function createBaseGetCodegenFeaturesFromGraphRequest(): GetCodegenFeaturesFromGraphRequest {
  return { deploymentId: undefined, branch: undefined, pythonVersion: undefined };
}

export const GetCodegenFeaturesFromGraphRequest: MessageFns<GetCodegenFeaturesFromGraphRequest> = {
  encode(message: GetCodegenFeaturesFromGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== undefined) {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.branch !== undefined) {
      writer.uint32(18).string(message.branch);
    }
    if (message.pythonVersion !== undefined) {
      PythonVersion.encode(message.pythonVersion, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCodegenFeaturesFromGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCodegenFeaturesFromGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pythonVersion = PythonVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCodegenFeaturesFromGraphRequest {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
      pythonVersion: isSet(object.pythonVersion) ? PythonVersion.fromJSON(object.pythonVersion) : undefined,
    };
  },

  toJSON(message: GetCodegenFeaturesFromGraphRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    if (message.pythonVersion !== undefined) {
      obj.pythonVersion = PythonVersion.toJSON(message.pythonVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCodegenFeaturesFromGraphRequest>, I>>(
    base?: I,
  ): GetCodegenFeaturesFromGraphRequest {
    return GetCodegenFeaturesFromGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCodegenFeaturesFromGraphRequest>, I>>(
    object: I,
  ): GetCodegenFeaturesFromGraphRequest {
    const message = createBaseGetCodegenFeaturesFromGraphRequest();
    message.deploymentId = object.deploymentId ?? undefined;
    message.branch = object.branch ?? undefined;
    message.pythonVersion = (object.pythonVersion !== undefined && object.pythonVersion !== null)
      ? PythonVersion.fromPartial(object.pythonVersion)
      : undefined;
    return message;
  },
};

function createBaseGetCodegenFeaturesFromGraphResponse(): GetCodegenFeaturesFromGraphResponse {
  return { codegen: "", errors: [] };
}

export const GetCodegenFeaturesFromGraphResponse: MessageFns<GetCodegenFeaturesFromGraphResponse> = {
  encode(message: GetCodegenFeaturesFromGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codegen !== "") {
      writer.uint32(10).string(message.codegen);
    }
    for (const v of message.errors) {
      ChalkError.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCodegenFeaturesFromGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCodegenFeaturesFromGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.codegen = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errors.push(ChalkError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCodegenFeaturesFromGraphResponse {
    return {
      codegen: isSet(object.codegen) ? globalThis.String(object.codegen) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ChalkError.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCodegenFeaturesFromGraphResponse): unknown {
    const obj: any = {};
    if (message.codegen !== "") {
      obj.codegen = message.codegen;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ChalkError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCodegenFeaturesFromGraphResponse>, I>>(
    base?: I,
  ): GetCodegenFeaturesFromGraphResponse {
    return GetCodegenFeaturesFromGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCodegenFeaturesFromGraphResponse>, I>>(
    object: I,
  ): GetCodegenFeaturesFromGraphResponse {
    const message = createBaseGetCodegenFeaturesFromGraphResponse();
    message.codegen = object.codegen ?? "";
    message.errors = object.errors?.map((e) => ChalkError.fromPartial(e)) || [];
    return message;
  },
};

export type GraphServiceService = typeof GraphServiceService;
export const GraphServiceService = {
  /** GetFeatureSQL returns the feature SQLs for a given deployment. */
  getFeatureSql: {
    path: "/chalk.server.v1.GraphService/GetFeatureSQL",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFeatureSQLRequest) => Buffer.from(GetFeatureSQLRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFeatureSQLRequest.decode(value),
    responseSerialize: (value: GetFeatureSQLResponse) => Buffer.from(GetFeatureSQLResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFeatureSQLResponse.decode(value),
  },
  getFeaturesMetadata: {
    path: "/chalk.server.v1.GraphService/GetFeaturesMetadata",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFeaturesMetadataRequest) =>
      Buffer.from(GetFeaturesMetadataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFeaturesMetadataRequest.decode(value),
    responseSerialize: (value: GetFeaturesMetadataResponse) =>
      Buffer.from(GetFeaturesMetadataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFeaturesMetadataResponse.decode(value),
  },
  getGraph: {
    path: "/chalk.server.v1.GraphService/GetGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGraphRequest) => Buffer.from(GetGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetGraphRequest.decode(value),
    responseSerialize: (value: GetGraphResponse) => Buffer.from(GetGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetGraphResponse.decode(value),
  },
  /** UpdateGraph uploads the protobuf graph for a given deployment. */
  updateGraph: {
    path: "/chalk.server.v1.GraphService/UpdateGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateGraphRequest) => Buffer.from(UpdateGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateGraphRequest.decode(value),
    responseSerialize: (value: UpdateGraphResponse) => Buffer.from(UpdateGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateGraphResponse.decode(value),
  },
  /** GetCodegenFeaturesFromGraph returns Chalk features generated from the protograph */
  getCodegenFeaturesFromGraph: {
    path: "/chalk.server.v1.GraphService/GetCodegenFeaturesFromGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCodegenFeaturesFromGraphRequest) =>
      Buffer.from(GetCodegenFeaturesFromGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCodegenFeaturesFromGraphRequest.decode(value),
    responseSerialize: (value: GetCodegenFeaturesFromGraphResponse) =>
      Buffer.from(GetCodegenFeaturesFromGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCodegenFeaturesFromGraphResponse.decode(value),
  },
} as const;

export interface GraphServiceServer extends UntypedServiceImplementation {
  /** GetFeatureSQL returns the feature SQLs for a given deployment. */
  getFeatureSql: handleUnaryCall<GetFeatureSQLRequest, GetFeatureSQLResponse>;
  getFeaturesMetadata: handleUnaryCall<GetFeaturesMetadataRequest, GetFeaturesMetadataResponse>;
  getGraph: handleUnaryCall<GetGraphRequest, GetGraphResponse>;
  /** UpdateGraph uploads the protobuf graph for a given deployment. */
  updateGraph: handleUnaryCall<UpdateGraphRequest, UpdateGraphResponse>;
  /** GetCodegenFeaturesFromGraph returns Chalk features generated from the protograph */
  getCodegenFeaturesFromGraph: handleUnaryCall<GetCodegenFeaturesFromGraphRequest, GetCodegenFeaturesFromGraphResponse>;
}

export interface GraphServiceClient extends Client {
  /** GetFeatureSQL returns the feature SQLs for a given deployment. */
  getFeatureSql(
    request: GetFeatureSQLRequest,
    callback: (error: ServiceError | null, response: GetFeatureSQLResponse) => void,
  ): ClientUnaryCall;
  getFeatureSql(
    request: GetFeatureSQLRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFeatureSQLResponse) => void,
  ): ClientUnaryCall;
  getFeatureSql(
    request: GetFeatureSQLRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFeatureSQLResponse) => void,
  ): ClientUnaryCall;
  getFeaturesMetadata(
    request: GetFeaturesMetadataRequest,
    callback: (error: ServiceError | null, response: GetFeaturesMetadataResponse) => void,
  ): ClientUnaryCall;
  getFeaturesMetadata(
    request: GetFeaturesMetadataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFeaturesMetadataResponse) => void,
  ): ClientUnaryCall;
  getFeaturesMetadata(
    request: GetFeaturesMetadataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFeaturesMetadataResponse) => void,
  ): ClientUnaryCall;
  getGraph(
    request: GetGraphRequest,
    callback: (error: ServiceError | null, response: GetGraphResponse) => void,
  ): ClientUnaryCall;
  getGraph(
    request: GetGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetGraphResponse) => void,
  ): ClientUnaryCall;
  getGraph(
    request: GetGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetGraphResponse) => void,
  ): ClientUnaryCall;
  /** UpdateGraph uploads the protobuf graph for a given deployment. */
  updateGraph(
    request: UpdateGraphRequest,
    callback: (error: ServiceError | null, response: UpdateGraphResponse) => void,
  ): ClientUnaryCall;
  updateGraph(
    request: UpdateGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateGraphResponse) => void,
  ): ClientUnaryCall;
  updateGraph(
    request: UpdateGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateGraphResponse) => void,
  ): ClientUnaryCall;
  /** GetCodegenFeaturesFromGraph returns Chalk features generated from the protograph */
  getCodegenFeaturesFromGraph(
    request: GetCodegenFeaturesFromGraphRequest,
    callback: (error: ServiceError | null, response: GetCodegenFeaturesFromGraphResponse) => void,
  ): ClientUnaryCall;
  getCodegenFeaturesFromGraph(
    request: GetCodegenFeaturesFromGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCodegenFeaturesFromGraphResponse) => void,
  ): ClientUnaryCall;
  getCodegenFeaturesFromGraph(
    request: GetCodegenFeaturesFromGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCodegenFeaturesFromGraphResponse) => void,
  ): ClientUnaryCall;
}

export const GraphServiceClient = makeGenericClientConstructor(
  GraphServiceService,
  "chalk.server.v1.GraphService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GraphServiceClient;
  service: typeof GraphServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
