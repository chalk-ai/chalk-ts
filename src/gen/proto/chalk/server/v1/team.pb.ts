// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/team.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { FieldMask } from "../../../google/protobuf/field_mask.pb";
import { Value } from "../../../google/protobuf/struct.pb";
import { Timestamp } from "../../../google/protobuf/timestamp.pb";
import { Agent, CustomClaim, ServiceTokenAgent } from "../../auth/v1/agent.pb";
import { DisplayAgent, DisplayServiceTokenAgent } from "../../auth/v1/displayagent.pb";
import {
  FeaturePermission,
  featurePermissionFromJSON,
  FeaturePermissions,
  featurePermissionToJSON,
} from "../../auth/v1/featurepermission.pb";
import { Permission, permissionFromJSON, permissionToJSON } from "../../auth/v1/permissions.pb";
import { Environment } from "./environment.pb";

export const protobufPackage = "chalk.server.v1";

export interface GetEnvRequest {
}

export interface GetEnvResponse {
  environment: Environment | undefined;
}

export interface GetEnvironmentsRequest {
  project: string;
}

export interface GetEnvironmentsResponse {
  environments: Environment[];
}

export interface GetAgentRequest {
}

export interface GetAgentResponse {
  agent: Agent | undefined;
}

export interface GetDisplayAgentRequest {
}

export interface GetDisplayAgentResponse {
  agent: DisplayAgent | undefined;
}

export interface Team {
  id: string;
  name: string;
  slug: string;
  logo?: string | undefined;
  projects: Project[];
  scimProvider?:
    | string
    | undefined;
  /** TODO: really a structured object. */
  specConfigJson: { [key: string]: any | undefined };
}

export interface Team_SpecConfigJsonEntry {
  key: string;
  value: any | undefined;
}

export interface Project {
  id: string;
  teamId: string;
  name: string;
  environments: Environment[];
  gitRepo?: string | undefined;
}

export interface CreateTeamRequest {
  name: string;
  slug: string;
  logo?: string | undefined;
}

export interface CreateTeamResponse {
  team: Team | undefined;
}

export interface CreateProjectRequest {
  name: string;
}

export interface CreateProjectResponse {
  project: Project | undefined;
}

export interface CreateEnvironmentRequest {
  projectId: string;
  name: string;
  /**
   * service_url,
   *  worker_url,
   *  branch_url,
   *  source_bundle_bucket,
   *  offline_store_secret
   */
  isDefault: boolean;
}

export interface CreateEnvironmentResponse {
  environment: Environment | undefined;
}

export interface UpdateEnvironmentOperation {
  specsConfigJson?: string | undefined;
  additionalEnvVars: { [key: string]: string };
  privatePipRepositories?: string | undefined;
}

export interface UpdateEnvironmentOperation_AdditionalEnvVarsEntry {
  key: string;
  value: string;
}

export interface UpdateEnvironmentRequest {
  id: string;
  update: UpdateEnvironmentOperation | undefined;
  updateMask: string[] | undefined;
}

export interface UpdateEnvironmentResponse {
  environment: Environment | undefined;
}

export interface GetTeamRequest {
}

export interface GetTeamResponse {
  team: Team | undefined;
}

export interface CreateServiceTokenRequest {
  name: string;
  permissions: Permission[];
  /** @deprecated */
  customClaims: string[];
  customerClaims: CustomClaim[];
  featureTagToPermission: { [key: string]: FeaturePermission };
}

export interface CreateServiceTokenRequest_FeatureTagToPermissionEntry {
  key: string;
  value: FeaturePermission;
}

export interface CreateServiceTokenResponse {
  agent: ServiceTokenAgent | undefined;
  clientSecret: string;
}

export interface DeleteServiceTokenRequest {
  id: string;
}

export interface DeleteServiceTokenResponse {
}

export interface PermissionDescription {
  id: Permission;
  slug: string;
  namespace: string;
  name: string;
  description: string;
  groupDescription: string;
}

export interface RoleDescription {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  featurePermissions: FeaturePermissions | undefined;
  isDefault: boolean;
}

export interface GetAvailablePermissionsRequest {
}

export interface GetAvailablePermissionsResponse {
  permissions: PermissionDescription[];
  roles: RoleDescription[];
  availableServiceTokenPermissions: Permission[];
}

export interface UpsertFeaturePermissionsRequest {
  role: string;
  permissions: FeaturePermissions | undefined;
}

export interface UpsertFeaturePermissionsResponse {
  role: string;
  permissions: FeaturePermissions | undefined;
}

export interface ListServiceTokensRequest {
}

export interface ListServiceTokensResponse {
  agents: DisplayServiceTokenAgent[];
}

export interface UpdateServiceTokenRequest {
  clientId: string;
  name: string;
  permissions: Permission[];
  customerClaims: CustomClaim[];
  featureTagToPermission: { [key: string]: FeaturePermission };
}

export interface UpdateServiceTokenRequest_FeatureTagToPermissionEntry {
  key: string;
  value: FeaturePermission;
}

export interface UpdateServiceTokenResponse {
  agent: DisplayServiceTokenAgent | undefined;
}

export interface UpdateScimGroupSettingsRequest {
  queryTags: string[];
  group: string;
}

export interface UpdateScimGroupSettingsResponse {
  queryTags: string[];
}

export interface InviteTeamMemberRequest {
  email: string;
  roleId?: string | undefined;
}

export interface InviteTeamMemberResponse {
}

export interface ExpireTeamInviteRequest {
  id: string;
}

export interface ExpireTeamInviteResponse {
}

export interface TeamInvite {
  id: string;
  email: string;
  team: string;
  role?: string | undefined;
  createdAt: Date | undefined;
}

export interface ListTeamInvitesRequest {
}

export interface ListTeamInvitesResponse {
  invites: TeamInvite[];
}

export interface ScimGroup {
  id: string;
  display: string;
  teamId: string;
  members: string[];
}

export interface ScimGroupRoleAssignment {
  groupId: string;
  environmentId: string;
  roleId: string;
  queryTags: string[];
}

export interface UserRoleAssignment {
  roleId: string;
  type: string;
}

export interface UserPermissions {
  userId: string;
  environmentId: string;
  userRoles: UserRoleAssignment[];
  userPermissions: Permission[];
}

export interface User {
  id: string;
  name?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  teamId?: string | undefined;
  deactivatedAt?: Date | undefined;
}

export interface EnvironmentPermissions {
  environmentId: string;
  scimRoles: ScimGroupRoleAssignment[];
  userPermissions: UserPermissions[];
}

export interface GetTeamPermissionsRequest {
}

export interface GetTeamPermissionsResponse {
  roles: RoleDescription[];
  scimGroups: ScimGroup[];
  environmentPermissions: EnvironmentPermissions[];
  teamMembers: User[];
}

function createBaseGetEnvRequest(): GetEnvRequest {
  return {};
}

export const GetEnvRequest: MessageFns<GetEnvRequest> = {
  encode(_: GetEnvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetEnvRequest {
    return {};
  },

  toJSON(_: GetEnvRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetEnvResponse(): GetEnvResponse {
  return { environment: undefined };
}

export const GetEnvResponse: MessageFns<GetEnvResponse> = {
  encode(message: GetEnvResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvResponse {
    return { environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined };
  },

  toJSON(message: GetEnvResponse): unknown {
    const obj: any = {};
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    return obj;
  },
};

function createBaseGetEnvironmentsRequest(): GetEnvironmentsRequest {
  return { project: "" };
}

export const GetEnvironmentsRequest: MessageFns<GetEnvironmentsRequest> = {
  encode(message: GetEnvironmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvironmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvironmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvironmentsRequest {
    return { project: isSet(object.project) ? globalThis.String(object.project) : "" };
  },

  toJSON(message: GetEnvironmentsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    return obj;
  },
};

function createBaseGetEnvironmentsResponse(): GetEnvironmentsResponse {
  return { environments: [] };
}

export const GetEnvironmentsResponse: MessageFns<GetEnvironmentsResponse> = {
  encode(message: GetEnvironmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.environments) {
      Environment.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvironmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvironmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environments.push(Environment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvironmentsResponse {
    return {
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => Environment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetEnvironmentsResponse): unknown {
    const obj: any = {};
    if (message.environments?.length) {
      obj.environments = message.environments.map((e) => Environment.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetAgentRequest(): GetAgentRequest {
  return {};
}

export const GetAgentRequest: MessageFns<GetAgentRequest> = {
  encode(_: GetAgentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAgentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAgentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAgentRequest {
    return {};
  },

  toJSON(_: GetAgentRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetAgentResponse(): GetAgentResponse {
  return { agent: undefined };
}

export const GetAgentResponse: MessageFns<GetAgentResponse> = {
  encode(message: GetAgentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== undefined) {
      Agent.encode(message.agent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAgentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agent = Agent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAgentResponse {
    return { agent: isSet(object.agent) ? Agent.fromJSON(object.agent) : undefined };
  },

  toJSON(message: GetAgentResponse): unknown {
    const obj: any = {};
    if (message.agent !== undefined) {
      obj.agent = Agent.toJSON(message.agent);
    }
    return obj;
  },
};

function createBaseGetDisplayAgentRequest(): GetDisplayAgentRequest {
  return {};
}

export const GetDisplayAgentRequest: MessageFns<GetDisplayAgentRequest> = {
  encode(_: GetDisplayAgentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplayAgentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplayAgentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetDisplayAgentRequest {
    return {};
  },

  toJSON(_: GetDisplayAgentRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetDisplayAgentResponse(): GetDisplayAgentResponse {
  return { agent: undefined };
}

export const GetDisplayAgentResponse: MessageFns<GetDisplayAgentResponse> = {
  encode(message: GetDisplayAgentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== undefined) {
      DisplayAgent.encode(message.agent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDisplayAgentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDisplayAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agent = DisplayAgent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDisplayAgentResponse {
    return { agent: isSet(object.agent) ? DisplayAgent.fromJSON(object.agent) : undefined };
  },

  toJSON(message: GetDisplayAgentResponse): unknown {
    const obj: any = {};
    if (message.agent !== undefined) {
      obj.agent = DisplayAgent.toJSON(message.agent);
    }
    return obj;
  },
};

function createBaseTeam(): Team {
  return { id: "", name: "", slug: "", logo: undefined, projects: [], scimProvider: undefined, specConfigJson: {} };
}

export const Team: MessageFns<Team> = {
  encode(message: Team, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.logo !== undefined) {
      writer.uint32(34).string(message.logo);
    }
    for (const v of message.projects) {
      Project.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.scimProvider !== undefined) {
      writer.uint32(50).string(message.scimProvider);
    }
    Object.entries(message.specConfigJson).forEach(([key, value]) => {
      if (value !== undefined) {
        Team_SpecConfigJsonEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Team {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.projects.push(Project.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scimProvider = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Team_SpecConfigJsonEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.specConfigJson[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Team {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : undefined,
      projects: globalThis.Array.isArray(object?.projects) ? object.projects.map((e: any) => Project.fromJSON(e)) : [],
      scimProvider: isSet(object.scimProvider) ? globalThis.String(object.scimProvider) : undefined,
      specConfigJson: isObject(object.specConfigJson)
        ? Object.entries(object.specConfigJson).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Team): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.logo !== undefined) {
      obj.logo = message.logo;
    }
    if (message.projects?.length) {
      obj.projects = message.projects.map((e) => Project.toJSON(e));
    }
    if (message.scimProvider !== undefined) {
      obj.scimProvider = message.scimProvider;
    }
    if (message.specConfigJson) {
      const entries = Object.entries(message.specConfigJson);
      if (entries.length > 0) {
        obj.specConfigJson = {};
        entries.forEach(([k, v]) => {
          obj.specConfigJson[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseTeam_SpecConfigJsonEntry(): Team_SpecConfigJsonEntry {
  return { key: "", value: undefined };
}

export const Team_SpecConfigJsonEntry: MessageFns<Team_SpecConfigJsonEntry> = {
  encode(message: Team_SpecConfigJsonEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Team_SpecConfigJsonEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeam_SpecConfigJsonEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Team_SpecConfigJsonEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Team_SpecConfigJsonEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseProject(): Project {
  return { id: "", teamId: "", name: "", environments: [], gitRepo: undefined };
}

export const Project: MessageFns<Project> = {
  encode(message: Project, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.teamId !== "") {
      writer.uint32(18).string(message.teamId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.environments) {
      Environment.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.gitRepo !== undefined) {
      writer.uint32(42).string(message.gitRepo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Project {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.environments.push(Environment.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gitRepo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Project {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => Environment.fromJSON(e))
        : [],
      gitRepo: isSet(object.gitRepo) ? globalThis.String(object.gitRepo) : undefined,
    };
  },

  toJSON(message: Project): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environments?.length) {
      obj.environments = message.environments.map((e) => Environment.toJSON(e));
    }
    if (message.gitRepo !== undefined) {
      obj.gitRepo = message.gitRepo;
    }
    return obj;
  },
};

function createBaseCreateTeamRequest(): CreateTeamRequest {
  return { name: "", slug: "", logo: undefined };
}

export const CreateTeamRequest: MessageFns<CreateTeamRequest> = {
  encode(message: CreateTeamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.logo !== undefined) {
      writer.uint32(26).string(message.logo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTeamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTeamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTeamRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : undefined,
    };
  },

  toJSON(message: CreateTeamRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.logo !== undefined) {
      obj.logo = message.logo;
    }
    return obj;
  },
};

function createBaseCreateTeamResponse(): CreateTeamResponse {
  return { team: undefined };
}

export const CreateTeamResponse: MessageFns<CreateTeamResponse> = {
  encode(message: CreateTeamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.team !== undefined) {
      Team.encode(message.team, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTeamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTeamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.team = Team.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTeamResponse {
    return { team: isSet(object.team) ? Team.fromJSON(object.team) : undefined };
  },

  toJSON(message: CreateTeamResponse): unknown {
    const obj: any = {};
    if (message.team !== undefined) {
      obj.team = Team.toJSON(message.team);
    }
    return obj;
  },
};

function createBaseCreateProjectRequest(): CreateProjectRequest {
  return { name: "" };
}

export const CreateProjectRequest: MessageFns<CreateProjectRequest> = {
  encode(message: CreateProjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProjectRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreateProjectRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

function createBaseCreateProjectResponse(): CreateProjectResponse {
  return { project: undefined };
}

export const CreateProjectResponse: MessageFns<CreateProjectResponse> = {
  encode(message: CreateProjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = Project.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProjectResponse {
    return { project: isSet(object.project) ? Project.fromJSON(object.project) : undefined };
  },

  toJSON(message: CreateProjectResponse): unknown {
    const obj: any = {};
    if (message.project !== undefined) {
      obj.project = Project.toJSON(message.project);
    }
    return obj;
  },
};

function createBaseCreateEnvironmentRequest(): CreateEnvironmentRequest {
  return { projectId: "", name: "", isDefault: false };
}

export const CreateEnvironmentRequest: MessageFns<CreateEnvironmentRequest> = {
  encode(message: CreateEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isDefault !== false) {
      writer.uint32(24).bool(message.isDefault);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEnvironmentRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
    };
  },

  toJSON(message: CreateEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    return obj;
  },
};

function createBaseCreateEnvironmentResponse(): CreateEnvironmentResponse {
  return { environment: undefined };
}

export const CreateEnvironmentResponse: MessageFns<CreateEnvironmentResponse> = {
  encode(message: CreateEnvironmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEnvironmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEnvironmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEnvironmentResponse {
    return { environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined };
  },

  toJSON(message: CreateEnvironmentResponse): unknown {
    const obj: any = {};
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    return obj;
  },
};

function createBaseUpdateEnvironmentOperation(): UpdateEnvironmentOperation {
  return { specsConfigJson: undefined, additionalEnvVars: {}, privatePipRepositories: undefined };
}

export const UpdateEnvironmentOperation: MessageFns<UpdateEnvironmentOperation> = {
  encode(message: UpdateEnvironmentOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.specsConfigJson !== undefined) {
      writer.uint32(10).string(message.specsConfigJson);
    }
    Object.entries(message.additionalEnvVars).forEach(([key, value]) => {
      UpdateEnvironmentOperation_AdditionalEnvVarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    if (message.privatePipRepositories !== undefined) {
      writer.uint32(26).string(message.privatePipRepositories);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvironmentOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvironmentOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.specsConfigJson = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = UpdateEnvironmentOperation_AdditionalEnvVarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.additionalEnvVars[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.privatePipRepositories = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvironmentOperation {
    return {
      specsConfigJson: isSet(object.specsConfigJson) ? globalThis.String(object.specsConfigJson) : undefined,
      additionalEnvVars: isObject(object.additionalEnvVars)
        ? Object.entries(object.additionalEnvVars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      privatePipRepositories: isSet(object.privatePipRepositories)
        ? globalThis.String(object.privatePipRepositories)
        : undefined,
    };
  },

  toJSON(message: UpdateEnvironmentOperation): unknown {
    const obj: any = {};
    if (message.specsConfigJson !== undefined) {
      obj.specsConfigJson = message.specsConfigJson;
    }
    if (message.additionalEnvVars) {
      const entries = Object.entries(message.additionalEnvVars);
      if (entries.length > 0) {
        obj.additionalEnvVars = {};
        entries.forEach(([k, v]) => {
          obj.additionalEnvVars[k] = v;
        });
      }
    }
    if (message.privatePipRepositories !== undefined) {
      obj.privatePipRepositories = message.privatePipRepositories;
    }
    return obj;
  },
};

function createBaseUpdateEnvironmentOperation_AdditionalEnvVarsEntry(): UpdateEnvironmentOperation_AdditionalEnvVarsEntry {
  return { key: "", value: "" };
}

export const UpdateEnvironmentOperation_AdditionalEnvVarsEntry: MessageFns<
  UpdateEnvironmentOperation_AdditionalEnvVarsEntry
> = {
  encode(
    message: UpdateEnvironmentOperation_AdditionalEnvVarsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvironmentOperation_AdditionalEnvVarsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvironmentOperation_AdditionalEnvVarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvironmentOperation_AdditionalEnvVarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateEnvironmentOperation_AdditionalEnvVarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseUpdateEnvironmentRequest(): UpdateEnvironmentRequest {
  return { id: "", update: undefined, updateMask: undefined };
}

export const UpdateEnvironmentRequest: MessageFns<UpdateEnvironmentRequest> = {
  encode(message: UpdateEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.update !== undefined) {
      UpdateEnvironmentOperation.encode(message.update, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.update = UpdateEnvironmentOperation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvironmentRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      update: isSet(object.update) ? UpdateEnvironmentOperation.fromJSON(object.update) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.update !== undefined) {
      obj.update = UpdateEnvironmentOperation.toJSON(message.update);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },
};

function createBaseUpdateEnvironmentResponse(): UpdateEnvironmentResponse {
  return { environment: undefined };
}

export const UpdateEnvironmentResponse: MessageFns<UpdateEnvironmentResponse> = {
  encode(message: UpdateEnvironmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvironmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvironmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvironmentResponse {
    return { environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined };
  },

  toJSON(message: UpdateEnvironmentResponse): unknown {
    const obj: any = {};
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    return obj;
  },
};

function createBaseGetTeamRequest(): GetTeamRequest {
  return {};
}

export const GetTeamRequest: MessageFns<GetTeamRequest> = {
  encode(_: GetTeamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTeamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTeamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTeamRequest {
    return {};
  },

  toJSON(_: GetTeamRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetTeamResponse(): GetTeamResponse {
  return { team: undefined };
}

export const GetTeamResponse: MessageFns<GetTeamResponse> = {
  encode(message: GetTeamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.team !== undefined) {
      Team.encode(message.team, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTeamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTeamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.team = Team.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTeamResponse {
    return { team: isSet(object.team) ? Team.fromJSON(object.team) : undefined };
  },

  toJSON(message: GetTeamResponse): unknown {
    const obj: any = {};
    if (message.team !== undefined) {
      obj.team = Team.toJSON(message.team);
    }
    return obj;
  },
};

function createBaseCreateServiceTokenRequest(): CreateServiceTokenRequest {
  return { name: "", permissions: [], customClaims: [], customerClaims: [], featureTagToPermission: {} };
}

export const CreateServiceTokenRequest: MessageFns<CreateServiceTokenRequest> = {
  encode(message: CreateServiceTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(18).fork();
    for (const v of message.permissions) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.customClaims) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.customerClaims) {
      CustomClaim.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.featureTagToPermission).forEach(([key, value]) => {
      CreateServiceTokenRequest_FeatureTagToPermissionEntry.encode({ key: key as any, value }, writer.uint32(42).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.permissions.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.permissions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customClaims.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerClaims.push(CustomClaim.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = CreateServiceTokenRequest_FeatureTagToPermissionEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.featureTagToPermission[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceTokenRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => permissionFromJSON(e))
        : [],
      customClaims: globalThis.Array.isArray(object?.customClaims)
        ? object.customClaims.map((e: any) => globalThis.String(e))
        : [],
      customerClaims: globalThis.Array.isArray(object?.customerClaims)
        ? object.customerClaims.map((e: any) => CustomClaim.fromJSON(e))
        : [],
      featureTagToPermission: isObject(object.featureTagToPermission)
        ? Object.entries(object.featureTagToPermission).reduce<{ [key: string]: FeaturePermission }>(
          (acc, [key, value]) => {
            acc[key] = featurePermissionFromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateServiceTokenRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => permissionToJSON(e));
    }
    if (message.customClaims?.length) {
      obj.customClaims = message.customClaims;
    }
    if (message.customerClaims?.length) {
      obj.customerClaims = message.customerClaims.map((e) => CustomClaim.toJSON(e));
    }
    if (message.featureTagToPermission) {
      const entries = Object.entries(message.featureTagToPermission);
      if (entries.length > 0) {
        obj.featureTagToPermission = {};
        entries.forEach(([k, v]) => {
          obj.featureTagToPermission[k] = featurePermissionToJSON(v);
        });
      }
    }
    return obj;
  },
};

function createBaseCreateServiceTokenRequest_FeatureTagToPermissionEntry(): CreateServiceTokenRequest_FeatureTagToPermissionEntry {
  return { key: "", value: 0 };
}

export const CreateServiceTokenRequest_FeatureTagToPermissionEntry: MessageFns<
  CreateServiceTokenRequest_FeatureTagToPermissionEntry
> = {
  encode(
    message: CreateServiceTokenRequest_FeatureTagToPermissionEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceTokenRequest_FeatureTagToPermissionEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceTokenRequest_FeatureTagToPermissionEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceTokenRequest_FeatureTagToPermissionEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? featurePermissionFromJSON(object.value) : 0,
    };
  },

  toJSON(message: CreateServiceTokenRequest_FeatureTagToPermissionEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = featurePermissionToJSON(message.value);
    }
    return obj;
  },
};

function createBaseCreateServiceTokenResponse(): CreateServiceTokenResponse {
  return { agent: undefined, clientSecret: "" };
}

export const CreateServiceTokenResponse: MessageFns<CreateServiceTokenResponse> = {
  encode(message: CreateServiceTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== undefined) {
      ServiceTokenAgent.encode(message.agent, writer.uint32(10).fork()).join();
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agent = ServiceTokenAgent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceTokenResponse {
    return {
      agent: isSet(object.agent) ? ServiceTokenAgent.fromJSON(object.agent) : undefined,
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
    };
  },

  toJSON(message: CreateServiceTokenResponse): unknown {
    const obj: any = {};
    if (message.agent !== undefined) {
      obj.agent = ServiceTokenAgent.toJSON(message.agent);
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },
};

function createBaseDeleteServiceTokenRequest(): DeleteServiceTokenRequest {
  return { id: "" };
}

export const DeleteServiceTokenRequest: MessageFns<DeleteServiceTokenRequest> = {
  encode(message: DeleteServiceTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteServiceTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteServiceTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteServiceTokenRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteServiceTokenRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
};

function createBaseDeleteServiceTokenResponse(): DeleteServiceTokenResponse {
  return {};
}

export const DeleteServiceTokenResponse: MessageFns<DeleteServiceTokenResponse> = {
  encode(_: DeleteServiceTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteServiceTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteServiceTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteServiceTokenResponse {
    return {};
  },

  toJSON(_: DeleteServiceTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBasePermissionDescription(): PermissionDescription {
  return { id: 0, slug: "", namespace: "", name: "", description: "", groupDescription: "" };
}

export const PermissionDescription: MessageFns<PermissionDescription> = {
  encode(message: PermissionDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.groupDescription !== "") {
      writer.uint32(50).string(message.groupDescription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.groupDescription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionDescription {
    return {
      id: isSet(object.id) ? permissionFromJSON(object.id) : 0,
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      groupDescription: isSet(object.groupDescription) ? globalThis.String(object.groupDescription) : "",
    };
  },

  toJSON(message: PermissionDescription): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = permissionToJSON(message.id);
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.groupDescription !== "") {
      obj.groupDescription = message.groupDescription;
    }
    return obj;
  },
};

function createBaseRoleDescription(): RoleDescription {
  return { id: "", name: "", description: "", permissions: [], featurePermissions: undefined, isDefault: false };
}

export const RoleDescription: MessageFns<RoleDescription> = {
  encode(message: RoleDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    writer.uint32(34).fork();
    for (const v of message.permissions) {
      writer.int32(v);
    }
    writer.join();
    if (message.featurePermissions !== undefined) {
      FeaturePermissions.encode(message.featurePermissions, writer.uint32(42).fork()).join();
    }
    if (message.isDefault !== false) {
      writer.uint32(48).bool(message.isDefault);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.permissions.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.permissions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.featurePermissions = FeaturePermissions.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleDescription {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => permissionFromJSON(e))
        : [],
      featurePermissions: isSet(object.featurePermissions)
        ? FeaturePermissions.fromJSON(object.featurePermissions)
        : undefined,
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
    };
  },

  toJSON(message: RoleDescription): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => permissionToJSON(e));
    }
    if (message.featurePermissions !== undefined) {
      obj.featurePermissions = FeaturePermissions.toJSON(message.featurePermissions);
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    return obj;
  },
};

function createBaseGetAvailablePermissionsRequest(): GetAvailablePermissionsRequest {
  return {};
}

export const GetAvailablePermissionsRequest: MessageFns<GetAvailablePermissionsRequest> = {
  encode(_: GetAvailablePermissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailablePermissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailablePermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAvailablePermissionsRequest {
    return {};
  },

  toJSON(_: GetAvailablePermissionsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetAvailablePermissionsResponse(): GetAvailablePermissionsResponse {
  return { permissions: [], roles: [], availableServiceTokenPermissions: [] };
}

export const GetAvailablePermissionsResponse: MessageFns<GetAvailablePermissionsResponse> = {
  encode(message: GetAvailablePermissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.permissions) {
      PermissionDescription.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.roles) {
      RoleDescription.encode(v!, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.availableServiceTokenPermissions) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailablePermissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailablePermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.permissions.push(PermissionDescription.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roles.push(RoleDescription.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.availableServiceTokenPermissions.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableServiceTokenPermissions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailablePermissionsResponse {
    return {
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => PermissionDescription.fromJSON(e))
        : [],
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => RoleDescription.fromJSON(e)) : [],
      availableServiceTokenPermissions: globalThis.Array.isArray(object?.availableServiceTokenPermissions)
        ? object.availableServiceTokenPermissions.map((e: any) => permissionFromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAvailablePermissionsResponse): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => PermissionDescription.toJSON(e));
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => RoleDescription.toJSON(e));
    }
    if (message.availableServiceTokenPermissions?.length) {
      obj.availableServiceTokenPermissions = message.availableServiceTokenPermissions.map((e) => permissionToJSON(e));
    }
    return obj;
  },
};

function createBaseUpsertFeaturePermissionsRequest(): UpsertFeaturePermissionsRequest {
  return { role: "", permissions: undefined };
}

export const UpsertFeaturePermissionsRequest: MessageFns<UpsertFeaturePermissionsRequest> = {
  encode(message: UpsertFeaturePermissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.permissions !== undefined) {
      FeaturePermissions.encode(message.permissions, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertFeaturePermissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertFeaturePermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permissions = FeaturePermissions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertFeaturePermissionsRequest {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      permissions: isSet(object.permissions) ? FeaturePermissions.fromJSON(object.permissions) : undefined,
    };
  },

  toJSON(message: UpsertFeaturePermissionsRequest): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.permissions !== undefined) {
      obj.permissions = FeaturePermissions.toJSON(message.permissions);
    }
    return obj;
  },
};

function createBaseUpsertFeaturePermissionsResponse(): UpsertFeaturePermissionsResponse {
  return { role: "", permissions: undefined };
}

export const UpsertFeaturePermissionsResponse: MessageFns<UpsertFeaturePermissionsResponse> = {
  encode(message: UpsertFeaturePermissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.permissions !== undefined) {
      FeaturePermissions.encode(message.permissions, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertFeaturePermissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertFeaturePermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permissions = FeaturePermissions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertFeaturePermissionsResponse {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      permissions: isSet(object.permissions) ? FeaturePermissions.fromJSON(object.permissions) : undefined,
    };
  },

  toJSON(message: UpsertFeaturePermissionsResponse): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.permissions !== undefined) {
      obj.permissions = FeaturePermissions.toJSON(message.permissions);
    }
    return obj;
  },
};

function createBaseListServiceTokensRequest(): ListServiceTokensRequest {
  return {};
}

export const ListServiceTokensRequest: MessageFns<ListServiceTokensRequest> = {
  encode(_: ListServiceTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListServiceTokensRequest {
    return {};
  },

  toJSON(_: ListServiceTokensRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseListServiceTokensResponse(): ListServiceTokensResponse {
  return { agents: [] };
}

export const ListServiceTokensResponse: MessageFns<ListServiceTokensResponse> = {
  encode(message: ListServiceTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.agents) {
      DisplayServiceTokenAgent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agents.push(DisplayServiceTokenAgent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceTokensResponse {
    return {
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => DisplayServiceTokenAgent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListServiceTokensResponse): unknown {
    const obj: any = {};
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => DisplayServiceTokenAgent.toJSON(e));
    }
    return obj;
  },
};

function createBaseUpdateServiceTokenRequest(): UpdateServiceTokenRequest {
  return { clientId: "", name: "", permissions: [], customerClaims: [], featureTagToPermission: {} };
}

export const UpdateServiceTokenRequest: MessageFns<UpdateServiceTokenRequest> = {
  encode(message: UpdateServiceTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    writer.uint32(26).fork();
    for (const v of message.permissions) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.customerClaims) {
      CustomClaim.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.featureTagToPermission).forEach(([key, value]) => {
      UpdateServiceTokenRequest_FeatureTagToPermissionEntry.encode({ key: key as any, value }, writer.uint32(42).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateServiceTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateServiceTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.permissions.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.permissions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerClaims.push(CustomClaim.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = UpdateServiceTokenRequest_FeatureTagToPermissionEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.featureTagToPermission[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateServiceTokenRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => permissionFromJSON(e))
        : [],
      customerClaims: globalThis.Array.isArray(object?.customerClaims)
        ? object.customerClaims.map((e: any) => CustomClaim.fromJSON(e))
        : [],
      featureTagToPermission: isObject(object.featureTagToPermission)
        ? Object.entries(object.featureTagToPermission).reduce<{ [key: string]: FeaturePermission }>(
          (acc, [key, value]) => {
            acc[key] = featurePermissionFromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: UpdateServiceTokenRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => permissionToJSON(e));
    }
    if (message.customerClaims?.length) {
      obj.customerClaims = message.customerClaims.map((e) => CustomClaim.toJSON(e));
    }
    if (message.featureTagToPermission) {
      const entries = Object.entries(message.featureTagToPermission);
      if (entries.length > 0) {
        obj.featureTagToPermission = {};
        entries.forEach(([k, v]) => {
          obj.featureTagToPermission[k] = featurePermissionToJSON(v);
        });
      }
    }
    return obj;
  },
};

function createBaseUpdateServiceTokenRequest_FeatureTagToPermissionEntry(): UpdateServiceTokenRequest_FeatureTagToPermissionEntry {
  return { key: "", value: 0 };
}

export const UpdateServiceTokenRequest_FeatureTagToPermissionEntry: MessageFns<
  UpdateServiceTokenRequest_FeatureTagToPermissionEntry
> = {
  encode(
    message: UpdateServiceTokenRequest_FeatureTagToPermissionEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateServiceTokenRequest_FeatureTagToPermissionEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateServiceTokenRequest_FeatureTagToPermissionEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateServiceTokenRequest_FeatureTagToPermissionEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? featurePermissionFromJSON(object.value) : 0,
    };
  },

  toJSON(message: UpdateServiceTokenRequest_FeatureTagToPermissionEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = featurePermissionToJSON(message.value);
    }
    return obj;
  },
};

function createBaseUpdateServiceTokenResponse(): UpdateServiceTokenResponse {
  return { agent: undefined };
}

export const UpdateServiceTokenResponse: MessageFns<UpdateServiceTokenResponse> = {
  encode(message: UpdateServiceTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== undefined) {
      DisplayServiceTokenAgent.encode(message.agent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateServiceTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateServiceTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agent = DisplayServiceTokenAgent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateServiceTokenResponse {
    return { agent: isSet(object.agent) ? DisplayServiceTokenAgent.fromJSON(object.agent) : undefined };
  },

  toJSON(message: UpdateServiceTokenResponse): unknown {
    const obj: any = {};
    if (message.agent !== undefined) {
      obj.agent = DisplayServiceTokenAgent.toJSON(message.agent);
    }
    return obj;
  },
};

function createBaseUpdateScimGroupSettingsRequest(): UpdateScimGroupSettingsRequest {
  return { queryTags: [], group: "" };
}

export const UpdateScimGroupSettingsRequest: MessageFns<UpdateScimGroupSettingsRequest> = {
  encode(message: UpdateScimGroupSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryTags) {
      writer.uint32(10).string(v!);
    }
    if (message.group !== "") {
      writer.uint32(18).string(message.group);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateScimGroupSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateScimGroupSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryTags.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.group = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateScimGroupSettingsRequest {
    return {
      queryTags: globalThis.Array.isArray(object?.queryTags)
        ? object.queryTags.map((e: any) => globalThis.String(e))
        : [],
      group: isSet(object.group) ? globalThis.String(object.group) : "",
    };
  },

  toJSON(message: UpdateScimGroupSettingsRequest): unknown {
    const obj: any = {};
    if (message.queryTags?.length) {
      obj.queryTags = message.queryTags;
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    return obj;
  },
};

function createBaseUpdateScimGroupSettingsResponse(): UpdateScimGroupSettingsResponse {
  return { queryTags: [] };
}

export const UpdateScimGroupSettingsResponse: MessageFns<UpdateScimGroupSettingsResponse> = {
  encode(message: UpdateScimGroupSettingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryTags) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateScimGroupSettingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateScimGroupSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryTags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateScimGroupSettingsResponse {
    return {
      queryTags: globalThis.Array.isArray(object?.queryTags)
        ? object.queryTags.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateScimGroupSettingsResponse): unknown {
    const obj: any = {};
    if (message.queryTags?.length) {
      obj.queryTags = message.queryTags;
    }
    return obj;
  },
};

function createBaseInviteTeamMemberRequest(): InviteTeamMemberRequest {
  return { email: "", roleId: undefined };
}

export const InviteTeamMemberRequest: MessageFns<InviteTeamMemberRequest> = {
  encode(message: InviteTeamMemberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.roleId !== undefined) {
      writer.uint32(18).string(message.roleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteTeamMemberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteTeamMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InviteTeamMemberRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : undefined,
    };
  },

  toJSON(message: InviteTeamMemberRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.roleId !== undefined) {
      obj.roleId = message.roleId;
    }
    return obj;
  },
};

function createBaseInviteTeamMemberResponse(): InviteTeamMemberResponse {
  return {};
}

export const InviteTeamMemberResponse: MessageFns<InviteTeamMemberResponse> = {
  encode(_: InviteTeamMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteTeamMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteTeamMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InviteTeamMemberResponse {
    return {};
  },

  toJSON(_: InviteTeamMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseExpireTeamInviteRequest(): ExpireTeamInviteRequest {
  return { id: "" };
}

export const ExpireTeamInviteRequest: MessageFns<ExpireTeamInviteRequest> = {
  encode(message: ExpireTeamInviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpireTeamInviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpireTeamInviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExpireTeamInviteRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: ExpireTeamInviteRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
};

function createBaseExpireTeamInviteResponse(): ExpireTeamInviteResponse {
  return {};
}

export const ExpireTeamInviteResponse: MessageFns<ExpireTeamInviteResponse> = {
  encode(_: ExpireTeamInviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpireTeamInviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpireTeamInviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExpireTeamInviteResponse {
    return {};
  },

  toJSON(_: ExpireTeamInviteResponse): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseTeamInvite(): TeamInvite {
  return { id: "", email: "", team: "", role: undefined, createdAt: undefined };
}

export const TeamInvite: MessageFns<TeamInvite> = {
  encode(message: TeamInvite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.team !== "") {
      writer.uint32(26).string(message.team);
    }
    if (message.role !== undefined) {
      writer.uint32(34).string(message.role);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamInvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.team = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamInvite {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      team: isSet(object.team) ? globalThis.String(object.team) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TeamInvite): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.team !== "") {
      obj.team = message.team;
    }
    if (message.role !== undefined) {
      obj.role = message.role;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },
};

function createBaseListTeamInvitesRequest(): ListTeamInvitesRequest {
  return {};
}

export const ListTeamInvitesRequest: MessageFns<ListTeamInvitesRequest> = {
  encode(_: ListTeamInvitesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTeamInvitesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTeamInvitesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListTeamInvitesRequest {
    return {};
  },

  toJSON(_: ListTeamInvitesRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseListTeamInvitesResponse(): ListTeamInvitesResponse {
  return { invites: [] };
}

export const ListTeamInvitesResponse: MessageFns<ListTeamInvitesResponse> = {
  encode(message: ListTeamInvitesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invites) {
      TeamInvite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTeamInvitesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTeamInvitesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invites.push(TeamInvite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTeamInvitesResponse {
    return {
      invites: globalThis.Array.isArray(object?.invites) ? object.invites.map((e: any) => TeamInvite.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListTeamInvitesResponse): unknown {
    const obj: any = {};
    if (message.invites?.length) {
      obj.invites = message.invites.map((e) => TeamInvite.toJSON(e));
    }
    return obj;
  },
};

function createBaseScimGroup(): ScimGroup {
  return { id: "", display: "", teamId: "", members: [] };
}

export const ScimGroup: MessageFns<ScimGroup> = {
  encode(message: ScimGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.display !== "") {
      writer.uint32(18).string(message.display);
    }
    if (message.teamId !== "") {
      writer.uint32(26).string(message.teamId);
    }
    for (const v of message.members) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScimGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScimGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.display = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teamId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.members.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScimGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      display: isSet(object.display) ? globalThis.String(object.display) : "",
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ScimGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.display !== "") {
      obj.display = message.display;
    }
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    if (message.members?.length) {
      obj.members = message.members;
    }
    return obj;
  },
};

function createBaseScimGroupRoleAssignment(): ScimGroupRoleAssignment {
  return { groupId: "", environmentId: "", roleId: "", queryTags: [] };
}

export const ScimGroupRoleAssignment: MessageFns<ScimGroupRoleAssignment> = {
  encode(message: ScimGroupRoleAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.environmentId !== "") {
      writer.uint32(26).string(message.environmentId);
    }
    if (message.roleId !== "") {
      writer.uint32(34).string(message.roleId);
    }
    for (const v of message.queryTags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScimGroupRoleAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScimGroupRoleAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queryTags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScimGroupRoleAssignment {
    return {
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
      queryTags: globalThis.Array.isArray(object?.queryTags)
        ? object.queryTags.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ScimGroupRoleAssignment): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    if (message.queryTags?.length) {
      obj.queryTags = message.queryTags;
    }
    return obj;
  },
};

function createBaseUserRoleAssignment(): UserRoleAssignment {
  return { roleId: "", type: "" };
}

export const UserRoleAssignment: MessageFns<UserRoleAssignment> = {
  encode(message: UserRoleAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== "") {
      writer.uint32(10).string(message.roleId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRoleAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRoleAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserRoleAssignment {
    return {
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: UserRoleAssignment): unknown {
    const obj: any = {};
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },
};

function createBaseUserPermissions(): UserPermissions {
  return { userId: "", environmentId: "", userRoles: [], userPermissions: [] };
}

export const UserPermissions: MessageFns<UserPermissions> = {
  encode(message: UserPermissions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    for (const v of message.userRoles) {
      UserRoleAssignment.encode(v!, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.userPermissions) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserPermissions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPermissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userRoles.push(UserRoleAssignment.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.userPermissions.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userPermissions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPermissions {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      userRoles: globalThis.Array.isArray(object?.userRoles)
        ? object.userRoles.map((e: any) => UserRoleAssignment.fromJSON(e))
        : [],
      userPermissions: globalThis.Array.isArray(object?.userPermissions)
        ? object.userPermissions.map((e: any) => permissionFromJSON(e))
        : [],
    };
  },

  toJSON(message: UserPermissions): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.userRoles?.length) {
      obj.userRoles = message.userRoles.map((e) => UserRoleAssignment.toJSON(e));
    }
    if (message.userPermissions?.length) {
      obj.userPermissions = message.userPermissions.map((e) => permissionToJSON(e));
    }
    return obj;
  },
};

function createBaseUser(): User {
  return { id: "", name: undefined, email: undefined, image: undefined, teamId: undefined, deactivatedAt: undefined };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== undefined) {
      writer.uint32(26).string(message.email);
    }
    if (message.image !== undefined) {
      writer.uint32(34).string(message.image);
    }
    if (message.teamId !== undefined) {
      writer.uint32(42).string(message.teamId);
    }
    if (message.deactivatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deactivatedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.teamId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deactivatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      image: isSet(object.image) ? globalThis.String(object.image) : undefined,
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : undefined,
      deactivatedAt: isSet(object.deactivatedAt) ? fromJsonTimestamp(object.deactivatedAt) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.image !== undefined) {
      obj.image = message.image;
    }
    if (message.teamId !== undefined) {
      obj.teamId = message.teamId;
    }
    if (message.deactivatedAt !== undefined) {
      obj.deactivatedAt = message.deactivatedAt.toISOString();
    }
    return obj;
  },
};

function createBaseEnvironmentPermissions(): EnvironmentPermissions {
  return { environmentId: "", scimRoles: [], userPermissions: [] };
}

export const EnvironmentPermissions: MessageFns<EnvironmentPermissions> = {
  encode(message: EnvironmentPermissions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environmentId !== "") {
      writer.uint32(10).string(message.environmentId);
    }
    for (const v of message.scimRoles) {
      ScimGroupRoleAssignment.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.userPermissions) {
      UserPermissions.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentPermissions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentPermissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scimRoles.push(ScimGroupRoleAssignment.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userPermissions.push(UserPermissions.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentPermissions {
    return {
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      scimRoles: globalThis.Array.isArray(object?.scimRoles)
        ? object.scimRoles.map((e: any) => ScimGroupRoleAssignment.fromJSON(e))
        : [],
      userPermissions: globalThis.Array.isArray(object?.userPermissions)
        ? object.userPermissions.map((e: any) => UserPermissions.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EnvironmentPermissions): unknown {
    const obj: any = {};
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.scimRoles?.length) {
      obj.scimRoles = message.scimRoles.map((e) => ScimGroupRoleAssignment.toJSON(e));
    }
    if (message.userPermissions?.length) {
      obj.userPermissions = message.userPermissions.map((e) => UserPermissions.toJSON(e));
    }
    return obj;
  },
};

function createBaseGetTeamPermissionsRequest(): GetTeamPermissionsRequest {
  return {};
}

export const GetTeamPermissionsRequest: MessageFns<GetTeamPermissionsRequest> = {
  encode(_: GetTeamPermissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTeamPermissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTeamPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTeamPermissionsRequest {
    return {};
  },

  toJSON(_: GetTeamPermissionsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetTeamPermissionsResponse(): GetTeamPermissionsResponse {
  return { roles: [], scimGroups: [], environmentPermissions: [], teamMembers: [] };
}

export const GetTeamPermissionsResponse: MessageFns<GetTeamPermissionsResponse> = {
  encode(message: GetTeamPermissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      RoleDescription.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.scimGroups) {
      ScimGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.environmentPermissions) {
      EnvironmentPermissions.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.teamMembers) {
      User.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTeamPermissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTeamPermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roles.push(RoleDescription.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scimGroups.push(ScimGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentPermissions.push(EnvironmentPermissions.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.teamMembers.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTeamPermissionsResponse {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => RoleDescription.fromJSON(e)) : [],
      scimGroups: globalThis.Array.isArray(object?.scimGroups)
        ? object.scimGroups.map((e: any) => ScimGroup.fromJSON(e))
        : [],
      environmentPermissions: globalThis.Array.isArray(object?.environmentPermissions)
        ? object.environmentPermissions.map((e: any) => EnvironmentPermissions.fromJSON(e))
        : [],
      teamMembers: globalThis.Array.isArray(object?.teamMembers)
        ? object.teamMembers.map((e: any) => User.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTeamPermissionsResponse): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => RoleDescription.toJSON(e));
    }
    if (message.scimGroups?.length) {
      obj.scimGroups = message.scimGroups.map((e) => ScimGroup.toJSON(e));
    }
    if (message.environmentPermissions?.length) {
      obj.environmentPermissions = message.environmentPermissions.map((e) => EnvironmentPermissions.toJSON(e));
    }
    if (message.teamMembers?.length) {
      obj.teamMembers = message.teamMembers.map((e) => User.toJSON(e));
    }
    return obj;
  },
};

export type TeamServiceService = typeof TeamServiceService;
export const TeamServiceService = {
  getEnv: {
    path: "/chalk.server.v1.TeamService/GetEnv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEnvRequest) => Buffer.from(GetEnvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEnvRequest.decode(value),
    responseSerialize: (value: GetEnvResponse) => Buffer.from(GetEnvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetEnvResponse.decode(value),
  },
  getEnvironments: {
    path: "/chalk.server.v1.TeamService/GetEnvironments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEnvironmentsRequest) => Buffer.from(GetEnvironmentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEnvironmentsRequest.decode(value),
    responseSerialize: (value: GetEnvironmentsResponse) => Buffer.from(GetEnvironmentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetEnvironmentsResponse.decode(value),
  },
  getAgent: {
    path: "/chalk.server.v1.TeamService/GetAgent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAgentRequest) => Buffer.from(GetAgentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAgentRequest.decode(value),
    responseSerialize: (value: GetAgentResponse) => Buffer.from(GetAgentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAgentResponse.decode(value),
  },
  getDisplayAgent: {
    path: "/chalk.server.v1.TeamService/GetDisplayAgent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDisplayAgentRequest) => Buffer.from(GetDisplayAgentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDisplayAgentRequest.decode(value),
    responseSerialize: (value: GetDisplayAgentResponse) => Buffer.from(GetDisplayAgentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDisplayAgentResponse.decode(value),
  },
  getTeam: {
    path: "/chalk.server.v1.TeamService/GetTeam",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTeamRequest) => Buffer.from(GetTeamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTeamRequest.decode(value),
    responseSerialize: (value: GetTeamResponse) => Buffer.from(GetTeamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTeamResponse.decode(value),
  },
  createTeam: {
    path: "/chalk.server.v1.TeamService/CreateTeam",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTeamRequest) => Buffer.from(CreateTeamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateTeamRequest.decode(value),
    responseSerialize: (value: CreateTeamResponse) => Buffer.from(CreateTeamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateTeamResponse.decode(value),
  },
  createProject: {
    path: "/chalk.server.v1.TeamService/CreateProject",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProjectRequest) => Buffer.from(CreateProjectRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProjectRequest.decode(value),
    responseSerialize: (value: CreateProjectResponse) => Buffer.from(CreateProjectResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProjectResponse.decode(value),
  },
  createEnvironment: {
    path: "/chalk.server.v1.TeamService/CreateEnvironment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEnvironmentRequest) => Buffer.from(CreateEnvironmentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateEnvironmentRequest.decode(value),
    responseSerialize: (value: CreateEnvironmentResponse) =>
      Buffer.from(CreateEnvironmentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateEnvironmentResponse.decode(value),
  },
  updateEnvironment: {
    path: "/chalk.server.v1.TeamService/UpdateEnvironment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEnvironmentRequest) => Buffer.from(UpdateEnvironmentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateEnvironmentRequest.decode(value),
    responseSerialize: (value: UpdateEnvironmentResponse) =>
      Buffer.from(UpdateEnvironmentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateEnvironmentResponse.decode(value),
  },
  getAvailablePermissions: {
    path: "/chalk.server.v1.TeamService/GetAvailablePermissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAvailablePermissionsRequest) =>
      Buffer.from(GetAvailablePermissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAvailablePermissionsRequest.decode(value),
    responseSerialize: (value: GetAvailablePermissionsResponse) =>
      Buffer.from(GetAvailablePermissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAvailablePermissionsResponse.decode(value),
  },
  createServiceToken: {
    path: "/chalk.server.v1.TeamService/CreateServiceToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateServiceTokenRequest) =>
      Buffer.from(CreateServiceTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateServiceTokenRequest.decode(value),
    responseSerialize: (value: CreateServiceTokenResponse) =>
      Buffer.from(CreateServiceTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateServiceTokenResponse.decode(value),
  },
  deleteServiceToken: {
    path: "/chalk.server.v1.TeamService/DeleteServiceToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteServiceTokenRequest) =>
      Buffer.from(DeleteServiceTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteServiceTokenRequest.decode(value),
    responseSerialize: (value: DeleteServiceTokenResponse) =>
      Buffer.from(DeleteServiceTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteServiceTokenResponse.decode(value),
  },
  listServiceTokens: {
    path: "/chalk.server.v1.TeamService/ListServiceTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListServiceTokensRequest) => Buffer.from(ListServiceTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListServiceTokensRequest.decode(value),
    responseSerialize: (value: ListServiceTokensResponse) =>
      Buffer.from(ListServiceTokensResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListServiceTokensResponse.decode(value),
  },
  updateServiceToken: {
    path: "/chalk.server.v1.TeamService/UpdateServiceToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateServiceTokenRequest) =>
      Buffer.from(UpdateServiceTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateServiceTokenRequest.decode(value),
    responseSerialize: (value: UpdateServiceTokenResponse) =>
      Buffer.from(UpdateServiceTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateServiceTokenResponse.decode(value),
  },
  inviteTeamMember: {
    path: "/chalk.server.v1.TeamService/InviteTeamMember",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InviteTeamMemberRequest) => Buffer.from(InviteTeamMemberRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InviteTeamMemberRequest.decode(value),
    responseSerialize: (value: InviteTeamMemberResponse) =>
      Buffer.from(InviteTeamMemberResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InviteTeamMemberResponse.decode(value),
  },
  expireTeamInvite: {
    path: "/chalk.server.v1.TeamService/ExpireTeamInvite",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExpireTeamInviteRequest) => Buffer.from(ExpireTeamInviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExpireTeamInviteRequest.decode(value),
    responseSerialize: (value: ExpireTeamInviteResponse) =>
      Buffer.from(ExpireTeamInviteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExpireTeamInviteResponse.decode(value),
  },
  listTeamInvites: {
    path: "/chalk.server.v1.TeamService/ListTeamInvites",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTeamInvitesRequest) => Buffer.from(ListTeamInvitesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListTeamInvitesRequest.decode(value),
    responseSerialize: (value: ListTeamInvitesResponse) => Buffer.from(ListTeamInvitesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListTeamInvitesResponse.decode(value),
  },
  upsertFeaturePermissions: {
    path: "/chalk.server.v1.TeamService/UpsertFeaturePermissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpsertFeaturePermissionsRequest) =>
      Buffer.from(UpsertFeaturePermissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpsertFeaturePermissionsRequest.decode(value),
    responseSerialize: (value: UpsertFeaturePermissionsResponse) =>
      Buffer.from(UpsertFeaturePermissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpsertFeaturePermissionsResponse.decode(value),
  },
  updateScimGroupSettings: {
    path: "/chalk.server.v1.TeamService/UpdateScimGroupSettings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateScimGroupSettingsRequest) =>
      Buffer.from(UpdateScimGroupSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateScimGroupSettingsRequest.decode(value),
    responseSerialize: (value: UpdateScimGroupSettingsResponse) =>
      Buffer.from(UpdateScimGroupSettingsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateScimGroupSettingsResponse.decode(value),
  },
  getTeamPermissions: {
    path: "/chalk.server.v1.TeamService/GetTeamPermissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTeamPermissionsRequest) =>
      Buffer.from(GetTeamPermissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTeamPermissionsRequest.decode(value),
    responseSerialize: (value: GetTeamPermissionsResponse) =>
      Buffer.from(GetTeamPermissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTeamPermissionsResponse.decode(value),
  },
} as const;

export interface TeamServiceServer extends UntypedServiceImplementation {
  getEnv: handleUnaryCall<GetEnvRequest, GetEnvResponse>;
  getEnvironments: handleUnaryCall<GetEnvironmentsRequest, GetEnvironmentsResponse>;
  getAgent: handleUnaryCall<GetAgentRequest, GetAgentResponse>;
  getDisplayAgent: handleUnaryCall<GetDisplayAgentRequest, GetDisplayAgentResponse>;
  getTeam: handleUnaryCall<GetTeamRequest, GetTeamResponse>;
  createTeam: handleUnaryCall<CreateTeamRequest, CreateTeamResponse>;
  createProject: handleUnaryCall<CreateProjectRequest, CreateProjectResponse>;
  createEnvironment: handleUnaryCall<CreateEnvironmentRequest, CreateEnvironmentResponse>;
  updateEnvironment: handleUnaryCall<UpdateEnvironmentRequest, UpdateEnvironmentResponse>;
  getAvailablePermissions: handleUnaryCall<GetAvailablePermissionsRequest, GetAvailablePermissionsResponse>;
  createServiceToken: handleUnaryCall<CreateServiceTokenRequest, CreateServiceTokenResponse>;
  deleteServiceToken: handleUnaryCall<DeleteServiceTokenRequest, DeleteServiceTokenResponse>;
  listServiceTokens: handleUnaryCall<ListServiceTokensRequest, ListServiceTokensResponse>;
  updateServiceToken: handleUnaryCall<UpdateServiceTokenRequest, UpdateServiceTokenResponse>;
  inviteTeamMember: handleUnaryCall<InviteTeamMemberRequest, InviteTeamMemberResponse>;
  expireTeamInvite: handleUnaryCall<ExpireTeamInviteRequest, ExpireTeamInviteResponse>;
  listTeamInvites: handleUnaryCall<ListTeamInvitesRequest, ListTeamInvitesResponse>;
  upsertFeaturePermissions: handleUnaryCall<UpsertFeaturePermissionsRequest, UpsertFeaturePermissionsResponse>;
  updateScimGroupSettings: handleUnaryCall<UpdateScimGroupSettingsRequest, UpdateScimGroupSettingsResponse>;
  getTeamPermissions: handleUnaryCall<GetTeamPermissionsRequest, GetTeamPermissionsResponse>;
}

export interface TeamServiceClient extends Client {
  getEnv(
    request: GetEnvRequest,
    callback: (error: ServiceError | null, response: GetEnvResponse) => void,
  ): ClientUnaryCall;
  getEnv(
    request: GetEnvRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetEnvResponse) => void,
  ): ClientUnaryCall;
  getEnv(
    request: GetEnvRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetEnvResponse) => void,
  ): ClientUnaryCall;
  getEnvironments(
    request: GetEnvironmentsRequest,
    callback: (error: ServiceError | null, response: GetEnvironmentsResponse) => void,
  ): ClientUnaryCall;
  getEnvironments(
    request: GetEnvironmentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetEnvironmentsResponse) => void,
  ): ClientUnaryCall;
  getEnvironments(
    request: GetEnvironmentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetEnvironmentsResponse) => void,
  ): ClientUnaryCall;
  getAgent(
    request: GetAgentRequest,
    callback: (error: ServiceError | null, response: GetAgentResponse) => void,
  ): ClientUnaryCall;
  getAgent(
    request: GetAgentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAgentResponse) => void,
  ): ClientUnaryCall;
  getAgent(
    request: GetAgentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAgentResponse) => void,
  ): ClientUnaryCall;
  getDisplayAgent(
    request: GetDisplayAgentRequest,
    callback: (error: ServiceError | null, response: GetDisplayAgentResponse) => void,
  ): ClientUnaryCall;
  getDisplayAgent(
    request: GetDisplayAgentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDisplayAgentResponse) => void,
  ): ClientUnaryCall;
  getDisplayAgent(
    request: GetDisplayAgentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDisplayAgentResponse) => void,
  ): ClientUnaryCall;
  getTeam(
    request: GetTeamRequest,
    callback: (error: ServiceError | null, response: GetTeamResponse) => void,
  ): ClientUnaryCall;
  getTeam(
    request: GetTeamRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTeamResponse) => void,
  ): ClientUnaryCall;
  getTeam(
    request: GetTeamRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTeamResponse) => void,
  ): ClientUnaryCall;
  createTeam(
    request: CreateTeamRequest,
    callback: (error: ServiceError | null, response: CreateTeamResponse) => void,
  ): ClientUnaryCall;
  createTeam(
    request: CreateTeamRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateTeamResponse) => void,
  ): ClientUnaryCall;
  createTeam(
    request: CreateTeamRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateTeamResponse) => void,
  ): ClientUnaryCall;
  createProject(
    request: CreateProjectRequest,
    callback: (error: ServiceError | null, response: CreateProjectResponse) => void,
  ): ClientUnaryCall;
  createProject(
    request: CreateProjectRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateProjectResponse) => void,
  ): ClientUnaryCall;
  createProject(
    request: CreateProjectRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateProjectResponse) => void,
  ): ClientUnaryCall;
  createEnvironment(
    request: CreateEnvironmentRequest,
    callback: (error: ServiceError | null, response: CreateEnvironmentResponse) => void,
  ): ClientUnaryCall;
  createEnvironment(
    request: CreateEnvironmentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateEnvironmentResponse) => void,
  ): ClientUnaryCall;
  createEnvironment(
    request: CreateEnvironmentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateEnvironmentResponse) => void,
  ): ClientUnaryCall;
  updateEnvironment(
    request: UpdateEnvironmentRequest,
    callback: (error: ServiceError | null, response: UpdateEnvironmentResponse) => void,
  ): ClientUnaryCall;
  updateEnvironment(
    request: UpdateEnvironmentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateEnvironmentResponse) => void,
  ): ClientUnaryCall;
  updateEnvironment(
    request: UpdateEnvironmentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateEnvironmentResponse) => void,
  ): ClientUnaryCall;
  getAvailablePermissions(
    request: GetAvailablePermissionsRequest,
    callback: (error: ServiceError | null, response: GetAvailablePermissionsResponse) => void,
  ): ClientUnaryCall;
  getAvailablePermissions(
    request: GetAvailablePermissionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAvailablePermissionsResponse) => void,
  ): ClientUnaryCall;
  getAvailablePermissions(
    request: GetAvailablePermissionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAvailablePermissionsResponse) => void,
  ): ClientUnaryCall;
  createServiceToken(
    request: CreateServiceTokenRequest,
    callback: (error: ServiceError | null, response: CreateServiceTokenResponse) => void,
  ): ClientUnaryCall;
  createServiceToken(
    request: CreateServiceTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateServiceTokenResponse) => void,
  ): ClientUnaryCall;
  createServiceToken(
    request: CreateServiceTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateServiceTokenResponse) => void,
  ): ClientUnaryCall;
  deleteServiceToken(
    request: DeleteServiceTokenRequest,
    callback: (error: ServiceError | null, response: DeleteServiceTokenResponse) => void,
  ): ClientUnaryCall;
  deleteServiceToken(
    request: DeleteServiceTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteServiceTokenResponse) => void,
  ): ClientUnaryCall;
  deleteServiceToken(
    request: DeleteServiceTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteServiceTokenResponse) => void,
  ): ClientUnaryCall;
  listServiceTokens(
    request: ListServiceTokensRequest,
    callback: (error: ServiceError | null, response: ListServiceTokensResponse) => void,
  ): ClientUnaryCall;
  listServiceTokens(
    request: ListServiceTokensRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListServiceTokensResponse) => void,
  ): ClientUnaryCall;
  listServiceTokens(
    request: ListServiceTokensRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListServiceTokensResponse) => void,
  ): ClientUnaryCall;
  updateServiceToken(
    request: UpdateServiceTokenRequest,
    callback: (error: ServiceError | null, response: UpdateServiceTokenResponse) => void,
  ): ClientUnaryCall;
  updateServiceToken(
    request: UpdateServiceTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateServiceTokenResponse) => void,
  ): ClientUnaryCall;
  updateServiceToken(
    request: UpdateServiceTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateServiceTokenResponse) => void,
  ): ClientUnaryCall;
  inviteTeamMember(
    request: InviteTeamMemberRequest,
    callback: (error: ServiceError | null, response: InviteTeamMemberResponse) => void,
  ): ClientUnaryCall;
  inviteTeamMember(
    request: InviteTeamMemberRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InviteTeamMemberResponse) => void,
  ): ClientUnaryCall;
  inviteTeamMember(
    request: InviteTeamMemberRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InviteTeamMemberResponse) => void,
  ): ClientUnaryCall;
  expireTeamInvite(
    request: ExpireTeamInviteRequest,
    callback: (error: ServiceError | null, response: ExpireTeamInviteResponse) => void,
  ): ClientUnaryCall;
  expireTeamInvite(
    request: ExpireTeamInviteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExpireTeamInviteResponse) => void,
  ): ClientUnaryCall;
  expireTeamInvite(
    request: ExpireTeamInviteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExpireTeamInviteResponse) => void,
  ): ClientUnaryCall;
  listTeamInvites(
    request: ListTeamInvitesRequest,
    callback: (error: ServiceError | null, response: ListTeamInvitesResponse) => void,
  ): ClientUnaryCall;
  listTeamInvites(
    request: ListTeamInvitesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListTeamInvitesResponse) => void,
  ): ClientUnaryCall;
  listTeamInvites(
    request: ListTeamInvitesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListTeamInvitesResponse) => void,
  ): ClientUnaryCall;
  upsertFeaturePermissions(
    request: UpsertFeaturePermissionsRequest,
    callback: (error: ServiceError | null, response: UpsertFeaturePermissionsResponse) => void,
  ): ClientUnaryCall;
  upsertFeaturePermissions(
    request: UpsertFeaturePermissionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpsertFeaturePermissionsResponse) => void,
  ): ClientUnaryCall;
  upsertFeaturePermissions(
    request: UpsertFeaturePermissionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpsertFeaturePermissionsResponse) => void,
  ): ClientUnaryCall;
  updateScimGroupSettings(
    request: UpdateScimGroupSettingsRequest,
    callback: (error: ServiceError | null, response: UpdateScimGroupSettingsResponse) => void,
  ): ClientUnaryCall;
  updateScimGroupSettings(
    request: UpdateScimGroupSettingsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateScimGroupSettingsResponse) => void,
  ): ClientUnaryCall;
  updateScimGroupSettings(
    request: UpdateScimGroupSettingsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateScimGroupSettingsResponse) => void,
  ): ClientUnaryCall;
  getTeamPermissions(
    request: GetTeamPermissionsRequest,
    callback: (error: ServiceError | null, response: GetTeamPermissionsResponse) => void,
  ): ClientUnaryCall;
  getTeamPermissions(
    request: GetTeamPermissionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTeamPermissionsResponse) => void,
  ): ClientUnaryCall;
  getTeamPermissions(
    request: GetTeamPermissionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTeamPermissionsResponse) => void,
  ): ClientUnaryCall;
}

export const TeamServiceClient = makeGenericClientConstructor(
  TeamServiceService,
  "chalk.server.v1.TeamService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TeamServiceClient;
  service: typeof TeamServiceService;
  serviceName: string;
};

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
