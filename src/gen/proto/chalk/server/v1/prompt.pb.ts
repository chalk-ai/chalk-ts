// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/prompt.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { FieldMask } from "../../../google/protobuf/field_mask.pb";
import { Value } from "../../../google/protobuf/struct.pb";
import { Timestamp } from "../../../google/protobuf/timestamp.pb";

export const protobufPackage = "chalk.server.v1";

export interface PromptTemplate {
  type: string;
  message: string;
}

export interface ProviderConfig {
  provider: string;
  modelName: string;
  parameters: { [key: string]: any | undefined };
  structuredOutput?: string | undefined;
}

export interface ProviderConfig_ParametersEntry {
  key: string;
  value: any | undefined;
}

export interface PromptVariant {
  id: number;
  environmentId: string;
  deploymentId: string;
  namedPromptId?: string | undefined;
  evaluationRunId?: string | undefined;
  commitHash?: string | undefined;
  templates: PromptTemplate[];
  variables: string[];
  providerConfig: ProviderConfig | undefined;
  variantHash?: string | undefined;
  createdBy?: string | undefined;
  createdAt: Date | undefined;
}

export interface NamedPrompt {
  id: string;
  environmentId: string;
  deploymentId: string;
  name: string;
  description: string;
  tags: string[];
  createdBy?: string | undefined;
  createdAt: Date | undefined;
  updatedAt?: Date | undefined;
  archivedAt?: Date | undefined;
  latestPromptVariant?: PromptVariant | undefined;
}

export interface PromptEvaluationRun {
  id: string;
  environmentId: string;
  deploymentId: string;
  branchName: string;
  datasetId: string;
  datasetRevisionId: string;
  referenceOutput?: string | undefined;
  evaluators: string[];
  offlineQueryIds: string[];
  relatedNamedPromptIds: string[];
  relatedEvaluationIds: string[];
  aggregateMetrics: { [key: string]: any | undefined };
  metaData: { [key: string]: any | undefined };
  createdBy?: string | undefined;
  createdAt: Date | undefined;
  datasetName?: string | undefined;
  relatedNamedPromptNames: string[];
  promptVariants: PromptVariant[];
}

export interface PromptEvaluationRun_AggregateMetricsEntry {
  key: string;
  value: any | undefined;
}

export interface PromptEvaluationRun_MetaDataEntry {
  key: string;
  value: any | undefined;
}

export interface ListNamedPromptsRequest {
  cursor?: string | undefined;
  limit?: number | undefined;
}

export interface ListNamedPromptsResponse {
  namedPrompts: NamedPrompt[];
  nextCursor?: string | undefined;
}

export interface GetNamedPromptRequest {
  namedPromptId: string;
}

export interface GetNamedPromptResponse {
  namedPrompt?: NamedPrompt | undefined;
}

export interface PromptVariantOperation {
  templates: PromptTemplate[];
  providerConfig: ProviderConfig | undefined;
}

export interface CreateNamedPromptRequest {
  name: string;
  description: string;
  tags: string[];
  promptVariant: PromptVariantOperation | undefined;
}

export interface CreateNamedPromptResponse {
  namedPrompt: NamedPrompt | undefined;
}

export interface UpdateNamedPromptOperation {
  name?: string | undefined;
  description?: string | undefined;
  tags: string[];
  promptVariant?: PromptVariantOperation | undefined;
  archivedAt?: Date | undefined;
}

export interface UpdateNamedPromptRequest {
  namedPromptId: string;
  update: UpdateNamedPromptOperation | undefined;
  updateMask: string[] | undefined;
}

export interface UpdateNamedPromptResponse {
  namedPrompt: NamedPrompt | undefined;
}

export interface ListPromptVariantsRequest {
  namedPromptId?: string | undefined;
  evaluationRunId?: string | undefined;
  cursor?: string | undefined;
  limit?: number | undefined;
}

export interface ListPromptVariantsResponse {
  promptVariants: PromptVariant[];
  nextCursor?: string | undefined;
}

export interface ListPromptEvaluationRunsRequest {
  cursor?: string | undefined;
  limit?: number | undefined;
  namedPromptId?: string | undefined;
}

export interface ListPromptEvaluationRunsResponse {
  evaluationRuns: PromptEvaluationRun[];
  nextCursor?: string | undefined;
}

export interface GetPromptEvaluationRunRequest {
  evaluationRunId?: string | undefined;
  prefillOptions?: GetPromptEvaluationRunRequest_PrefillOptions | undefined;
}

export interface GetPromptEvaluationRunRequest_PrefillOptions {
  namedPromptId?: string | undefined;
  evaluationRunId?: string | undefined;
}

export interface GetPromptEvaluationRunResponse {
  evaluationRun?: PromptEvaluationRun | undefined;
}

export interface CreatePromptEvaluationRunRequest {
  branchName: string;
  datasetId: string;
  datasetRevisionId: string;
  referenceOutput?: string | undefined;
  evaluators: string[];
  relatedNamedPromptIds: string[];
  relatedEvaluationIds: string[];
  metaData: { [key: string]: any | undefined };
  promptVariants: PromptVariantOperation[];
}

export interface CreatePromptEvaluationRunRequest_MetaDataEntry {
  key: string;
  value: any | undefined;
}

export interface CreatePromptEvaluationRunResponse {
  evaluationRun: PromptEvaluationRun | undefined;
}

function createBasePromptTemplate(): PromptTemplate {
  return { type: "", message: "" };
}

export const PromptTemplate: MessageFns<PromptTemplate> = {
  encode(message: PromptTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptTemplate {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: PromptTemplate): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
};

function createBaseProviderConfig(): ProviderConfig {
  return { provider: "", modelName: "", parameters: {}, structuredOutput: undefined };
}

export const ProviderConfig: MessageFns<ProviderConfig> = {
  encode(message: ProviderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.modelName !== "") {
      writer.uint32(18).string(message.modelName);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      if (value !== undefined) {
        ProviderConfig_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
      }
    });
    if (message.structuredOutput !== undefined) {
      writer.uint32(34).string(message.structuredOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ProviderConfig_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.structuredOutput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderConfig {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      structuredOutput: isSet(object.structuredOutput) ? globalThis.String(object.structuredOutput) : undefined,
    };
  },

  toJSON(message: ProviderConfig): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.structuredOutput !== undefined) {
      obj.structuredOutput = message.structuredOutput;
    }
    return obj;
  },
};

function createBaseProviderConfig_ParametersEntry(): ProviderConfig_ParametersEntry {
  return { key: "", value: undefined };
}

export const ProviderConfig_ParametersEntry: MessageFns<ProviderConfig_ParametersEntry> = {
  encode(message: ProviderConfig_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderConfig_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderConfig_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderConfig_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: ProviderConfig_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBasePromptVariant(): PromptVariant {
  return {
    id: 0,
    environmentId: "",
    deploymentId: "",
    namedPromptId: undefined,
    evaluationRunId: undefined,
    commitHash: undefined,
    templates: [],
    variables: [],
    providerConfig: undefined,
    variantHash: undefined,
    createdBy: undefined,
    createdAt: undefined,
  };
}

export const PromptVariant: MessageFns<PromptVariant> = {
  encode(message: PromptVariant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== "") {
      writer.uint32(26).string(message.deploymentId);
    }
    if (message.namedPromptId !== undefined) {
      writer.uint32(34).string(message.namedPromptId);
    }
    if (message.evaluationRunId !== undefined) {
      writer.uint32(42).string(message.evaluationRunId);
    }
    if (message.commitHash !== undefined) {
      writer.uint32(50).string(message.commitHash);
    }
    for (const v of message.templates) {
      PromptTemplate.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.variables) {
      writer.uint32(66).string(v!);
    }
    if (message.providerConfig !== undefined) {
      ProviderConfig.encode(message.providerConfig, writer.uint32(74).fork()).join();
    }
    if (message.variantHash !== undefined) {
      writer.uint32(82).string(message.variantHash);
    }
    if (message.createdBy !== undefined) {
      writer.uint32(90).string(message.createdBy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptVariant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.namedPromptId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evaluationRunId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.commitHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.templates.push(PromptTemplate.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.variables.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.providerConfig = ProviderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.variantHash = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptVariant {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      namedPromptId: isSet(object.namedPromptId) ? globalThis.String(object.namedPromptId) : undefined,
      evaluationRunId: isSet(object.evaluationRunId) ? globalThis.String(object.evaluationRunId) : undefined,
      commitHash: isSet(object.commitHash) ? globalThis.String(object.commitHash) : undefined,
      templates: globalThis.Array.isArray(object?.templates)
        ? object.templates.map((e: any) => PromptTemplate.fromJSON(e))
        : [],
      variables: globalThis.Array.isArray(object?.variables)
        ? object.variables.map((e: any) => globalThis.String(e))
        : [],
      providerConfig: isSet(object.providerConfig) ? ProviderConfig.fromJSON(object.providerConfig) : undefined,
      variantHash: isSet(object.variantHash) ? globalThis.String(object.variantHash) : undefined,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: PromptVariant): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.namedPromptId !== undefined) {
      obj.namedPromptId = message.namedPromptId;
    }
    if (message.evaluationRunId !== undefined) {
      obj.evaluationRunId = message.evaluationRunId;
    }
    if (message.commitHash !== undefined) {
      obj.commitHash = message.commitHash;
    }
    if (message.templates?.length) {
      obj.templates = message.templates.map((e) => PromptTemplate.toJSON(e));
    }
    if (message.variables?.length) {
      obj.variables = message.variables;
    }
    if (message.providerConfig !== undefined) {
      obj.providerConfig = ProviderConfig.toJSON(message.providerConfig);
    }
    if (message.variantHash !== undefined) {
      obj.variantHash = message.variantHash;
    }
    if (message.createdBy !== undefined) {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },
};

function createBaseNamedPrompt(): NamedPrompt {
  return {
    id: "",
    environmentId: "",
    deploymentId: "",
    name: "",
    description: "",
    tags: [],
    createdBy: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    archivedAt: undefined,
    latestPromptVariant: undefined,
  };
}

export const NamedPrompt: MessageFns<NamedPrompt> = {
  encode(message: NamedPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== "") {
      writer.uint32(26).string(message.deploymentId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.createdBy !== undefined) {
      writer.uint32(58).string(message.createdBy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).join();
    }
    if (message.archivedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.archivedAt), writer.uint32(82).fork()).join();
    }
    if (message.latestPromptVariant !== undefined) {
      PromptVariant.encode(message.latestPromptVariant, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.archivedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.latestPromptVariant = PromptVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedPrompt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      archivedAt: isSet(object.archivedAt) ? fromJsonTimestamp(object.archivedAt) : undefined,
      latestPromptVariant: isSet(object.latestPromptVariant)
        ? PromptVariant.fromJSON(object.latestPromptVariant)
        : undefined,
    };
  },

  toJSON(message: NamedPrompt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.createdBy !== undefined) {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.archivedAt !== undefined) {
      obj.archivedAt = message.archivedAt.toISOString();
    }
    if (message.latestPromptVariant !== undefined) {
      obj.latestPromptVariant = PromptVariant.toJSON(message.latestPromptVariant);
    }
    return obj;
  },
};

function createBasePromptEvaluationRun(): PromptEvaluationRun {
  return {
    id: "",
    environmentId: "",
    deploymentId: "",
    branchName: "",
    datasetId: "",
    datasetRevisionId: "",
    referenceOutput: undefined,
    evaluators: [],
    offlineQueryIds: [],
    relatedNamedPromptIds: [],
    relatedEvaluationIds: [],
    aggregateMetrics: {},
    metaData: {},
    createdBy: undefined,
    createdAt: undefined,
    datasetName: undefined,
    relatedNamedPromptNames: [],
    promptVariants: [],
  };
}

export const PromptEvaluationRun: MessageFns<PromptEvaluationRun> = {
  encode(message: PromptEvaluationRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.environmentId !== "") {
      writer.uint32(18).string(message.environmentId);
    }
    if (message.deploymentId !== "") {
      writer.uint32(26).string(message.deploymentId);
    }
    if (message.branchName !== "") {
      writer.uint32(34).string(message.branchName);
    }
    if (message.datasetId !== "") {
      writer.uint32(42).string(message.datasetId);
    }
    if (message.datasetRevisionId !== "") {
      writer.uint32(50).string(message.datasetRevisionId);
    }
    if (message.referenceOutput !== undefined) {
      writer.uint32(58).string(message.referenceOutput);
    }
    for (const v of message.evaluators) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.offlineQueryIds) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.relatedNamedPromptIds) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.relatedEvaluationIds) {
      writer.uint32(90).string(v!);
    }
    Object.entries(message.aggregateMetrics).forEach(([key, value]) => {
      if (value !== undefined) {
        PromptEvaluationRun_AggregateMetricsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
      }
    });
    Object.entries(message.metaData).forEach(([key, value]) => {
      if (value !== undefined) {
        PromptEvaluationRun_MetaDataEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
      }
    });
    if (message.createdBy !== undefined) {
      writer.uint32(114).string(message.createdBy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(122).fork()).join();
    }
    if (message.datasetName !== undefined) {
      writer.uint32(130).string(message.datasetName);
    }
    for (const v of message.relatedNamedPromptNames) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.promptVariants) {
      PromptVariant.encode(v!, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptEvaluationRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptEvaluationRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.branchName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.datasetRevisionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.referenceOutput = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.evaluators.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.offlineQueryIds.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.relatedNamedPromptIds.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.relatedEvaluationIds.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = PromptEvaluationRun_AggregateMetricsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.aggregateMetrics[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = PromptEvaluationRun_MetaDataEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.metaData[entry13.key] = entry13.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.datasetName = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.relatedNamedPromptNames.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.promptVariants.push(PromptVariant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptEvaluationRun {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      branchName: isSet(object.branchName) ? globalThis.String(object.branchName) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetRevisionId: isSet(object.datasetRevisionId) ? globalThis.String(object.datasetRevisionId) : "",
      referenceOutput: isSet(object.referenceOutput) ? globalThis.String(object.referenceOutput) : undefined,
      evaluators: globalThis.Array.isArray(object?.evaluators)
        ? object.evaluators.map((e: any) => globalThis.String(e))
        : [],
      offlineQueryIds: globalThis.Array.isArray(object?.offlineQueryIds)
        ? object.offlineQueryIds.map((e: any) => globalThis.String(e))
        : [],
      relatedNamedPromptIds: globalThis.Array.isArray(object?.relatedNamedPromptIds)
        ? object.relatedNamedPromptIds.map((e: any) => globalThis.String(e))
        : [],
      relatedEvaluationIds: globalThis.Array.isArray(object?.relatedEvaluationIds)
        ? object.relatedEvaluationIds.map((e: any) => globalThis.String(e))
        : [],
      aggregateMetrics: isObject(object.aggregateMetrics)
        ? Object.entries(object.aggregateMetrics).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      metaData: isObject(object.metaData)
        ? Object.entries(object.metaData).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      datasetName: isSet(object.datasetName) ? globalThis.String(object.datasetName) : undefined,
      relatedNamedPromptNames: globalThis.Array.isArray(object?.relatedNamedPromptNames)
        ? object.relatedNamedPromptNames.map((e: any) => globalThis.String(e))
        : [],
      promptVariants: globalThis.Array.isArray(object?.promptVariants)
        ? object.promptVariants.map((e: any) => PromptVariant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PromptEvaluationRun): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.branchName !== "") {
      obj.branchName = message.branchName;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetRevisionId !== "") {
      obj.datasetRevisionId = message.datasetRevisionId;
    }
    if (message.referenceOutput !== undefined) {
      obj.referenceOutput = message.referenceOutput;
    }
    if (message.evaluators?.length) {
      obj.evaluators = message.evaluators;
    }
    if (message.offlineQueryIds?.length) {
      obj.offlineQueryIds = message.offlineQueryIds;
    }
    if (message.relatedNamedPromptIds?.length) {
      obj.relatedNamedPromptIds = message.relatedNamedPromptIds;
    }
    if (message.relatedEvaluationIds?.length) {
      obj.relatedEvaluationIds = message.relatedEvaluationIds;
    }
    if (message.aggregateMetrics) {
      const entries = Object.entries(message.aggregateMetrics);
      if (entries.length > 0) {
        obj.aggregateMetrics = {};
        entries.forEach(([k, v]) => {
          obj.aggregateMetrics[k] = v;
        });
      }
    }
    if (message.metaData) {
      const entries = Object.entries(message.metaData);
      if (entries.length > 0) {
        obj.metaData = {};
        entries.forEach(([k, v]) => {
          obj.metaData[k] = v;
        });
      }
    }
    if (message.createdBy !== undefined) {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.datasetName !== undefined) {
      obj.datasetName = message.datasetName;
    }
    if (message.relatedNamedPromptNames?.length) {
      obj.relatedNamedPromptNames = message.relatedNamedPromptNames;
    }
    if (message.promptVariants?.length) {
      obj.promptVariants = message.promptVariants.map((e) => PromptVariant.toJSON(e));
    }
    return obj;
  },
};

function createBasePromptEvaluationRun_AggregateMetricsEntry(): PromptEvaluationRun_AggregateMetricsEntry {
  return { key: "", value: undefined };
}

export const PromptEvaluationRun_AggregateMetricsEntry: MessageFns<PromptEvaluationRun_AggregateMetricsEntry> = {
  encode(message: PromptEvaluationRun_AggregateMetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptEvaluationRun_AggregateMetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptEvaluationRun_AggregateMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptEvaluationRun_AggregateMetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: PromptEvaluationRun_AggregateMetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBasePromptEvaluationRun_MetaDataEntry(): PromptEvaluationRun_MetaDataEntry {
  return { key: "", value: undefined };
}

export const PromptEvaluationRun_MetaDataEntry: MessageFns<PromptEvaluationRun_MetaDataEntry> = {
  encode(message: PromptEvaluationRun_MetaDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptEvaluationRun_MetaDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptEvaluationRun_MetaDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptEvaluationRun_MetaDataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: PromptEvaluationRun_MetaDataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseListNamedPromptsRequest(): ListNamedPromptsRequest {
  return { cursor: undefined, limit: undefined };
}

export const ListNamedPromptsRequest: MessageFns<ListNamedPromptsRequest> = {
  encode(message: ListNamedPromptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      writer.uint32(10).string(message.cursor);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNamedPromptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamedPromptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamedPromptsRequest {
    return {
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: ListNamedPromptsRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = message.cursor;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },
};

function createBaseListNamedPromptsResponse(): ListNamedPromptsResponse {
  return { namedPrompts: [], nextCursor: undefined };
}

export const ListNamedPromptsResponse: MessageFns<ListNamedPromptsResponse> = {
  encode(message: ListNamedPromptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.namedPrompts) {
      NamedPrompt.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextCursor !== undefined) {
      writer.uint32(18).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNamedPromptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamedPromptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPrompts.push(NamedPrompt.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamedPromptsResponse {
    return {
      namedPrompts: globalThis.Array.isArray(object?.namedPrompts)
        ? object.namedPrompts.map((e: any) => NamedPrompt.fromJSON(e))
        : [],
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : undefined,
    };
  },

  toJSON(message: ListNamedPromptsResponse): unknown {
    const obj: any = {};
    if (message.namedPrompts?.length) {
      obj.namedPrompts = message.namedPrompts.map((e) => NamedPrompt.toJSON(e));
    }
    if (message.nextCursor !== undefined) {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },
};

function createBaseGetNamedPromptRequest(): GetNamedPromptRequest {
  return { namedPromptId: "" };
}

export const GetNamedPromptRequest: MessageFns<GetNamedPromptRequest> = {
  encode(message: GetNamedPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedPromptId !== "") {
      writer.uint32(10).string(message.namedPromptId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNamedPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNamedPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPromptId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNamedPromptRequest {
    return { namedPromptId: isSet(object.namedPromptId) ? globalThis.String(object.namedPromptId) : "" };
  },

  toJSON(message: GetNamedPromptRequest): unknown {
    const obj: any = {};
    if (message.namedPromptId !== "") {
      obj.namedPromptId = message.namedPromptId;
    }
    return obj;
  },
};

function createBaseGetNamedPromptResponse(): GetNamedPromptResponse {
  return { namedPrompt: undefined };
}

export const GetNamedPromptResponse: MessageFns<GetNamedPromptResponse> = {
  encode(message: GetNamedPromptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedPrompt !== undefined) {
      NamedPrompt.encode(message.namedPrompt, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNamedPromptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNamedPromptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPrompt = NamedPrompt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNamedPromptResponse {
    return { namedPrompt: isSet(object.namedPrompt) ? NamedPrompt.fromJSON(object.namedPrompt) : undefined };
  },

  toJSON(message: GetNamedPromptResponse): unknown {
    const obj: any = {};
    if (message.namedPrompt !== undefined) {
      obj.namedPrompt = NamedPrompt.toJSON(message.namedPrompt);
    }
    return obj;
  },
};

function createBasePromptVariantOperation(): PromptVariantOperation {
  return { templates: [], providerConfig: undefined };
}

export const PromptVariantOperation: MessageFns<PromptVariantOperation> = {
  encode(message: PromptVariantOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.templates) {
      PromptTemplate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.providerConfig !== undefined) {
      ProviderConfig.encode(message.providerConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptVariantOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptVariantOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templates.push(PromptTemplate.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerConfig = ProviderConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptVariantOperation {
    return {
      templates: globalThis.Array.isArray(object?.templates)
        ? object.templates.map((e: any) => PromptTemplate.fromJSON(e))
        : [],
      providerConfig: isSet(object.providerConfig) ? ProviderConfig.fromJSON(object.providerConfig) : undefined,
    };
  },

  toJSON(message: PromptVariantOperation): unknown {
    const obj: any = {};
    if (message.templates?.length) {
      obj.templates = message.templates.map((e) => PromptTemplate.toJSON(e));
    }
    if (message.providerConfig !== undefined) {
      obj.providerConfig = ProviderConfig.toJSON(message.providerConfig);
    }
    return obj;
  },
};

function createBaseCreateNamedPromptRequest(): CreateNamedPromptRequest {
  return { name: "", description: "", tags: [], promptVariant: undefined };
}

export const CreateNamedPromptRequest: MessageFns<CreateNamedPromptRequest> = {
  encode(message: CreateNamedPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.promptVariant !== undefined) {
      PromptVariantOperation.encode(message.promptVariant, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNamedPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNamedPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.promptVariant = PromptVariantOperation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNamedPromptRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      promptVariant: isSet(object.promptVariant) ? PromptVariantOperation.fromJSON(object.promptVariant) : undefined,
    };
  },

  toJSON(message: CreateNamedPromptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.promptVariant !== undefined) {
      obj.promptVariant = PromptVariantOperation.toJSON(message.promptVariant);
    }
    return obj;
  },
};

function createBaseCreateNamedPromptResponse(): CreateNamedPromptResponse {
  return { namedPrompt: undefined };
}

export const CreateNamedPromptResponse: MessageFns<CreateNamedPromptResponse> = {
  encode(message: CreateNamedPromptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedPrompt !== undefined) {
      NamedPrompt.encode(message.namedPrompt, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNamedPromptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNamedPromptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPrompt = NamedPrompt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNamedPromptResponse {
    return { namedPrompt: isSet(object.namedPrompt) ? NamedPrompt.fromJSON(object.namedPrompt) : undefined };
  },

  toJSON(message: CreateNamedPromptResponse): unknown {
    const obj: any = {};
    if (message.namedPrompt !== undefined) {
      obj.namedPrompt = NamedPrompt.toJSON(message.namedPrompt);
    }
    return obj;
  },
};

function createBaseUpdateNamedPromptOperation(): UpdateNamedPromptOperation {
  return { name: undefined, description: undefined, tags: [], promptVariant: undefined, archivedAt: undefined };
}

export const UpdateNamedPromptOperation: MessageFns<UpdateNamedPromptOperation> = {
  encode(message: UpdateNamedPromptOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.promptVariant !== undefined) {
      PromptVariantOperation.encode(message.promptVariant, writer.uint32(34).fork()).join();
    }
    if (message.archivedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.archivedAt), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNamedPromptOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNamedPromptOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.promptVariant = PromptVariantOperation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.archivedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNamedPromptOperation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      promptVariant: isSet(object.promptVariant) ? PromptVariantOperation.fromJSON(object.promptVariant) : undefined,
      archivedAt: isSet(object.archivedAt) ? fromJsonTimestamp(object.archivedAt) : undefined,
    };
  },

  toJSON(message: UpdateNamedPromptOperation): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.promptVariant !== undefined) {
      obj.promptVariant = PromptVariantOperation.toJSON(message.promptVariant);
    }
    if (message.archivedAt !== undefined) {
      obj.archivedAt = message.archivedAt.toISOString();
    }
    return obj;
  },
};

function createBaseUpdateNamedPromptRequest(): UpdateNamedPromptRequest {
  return { namedPromptId: "", update: undefined, updateMask: undefined };
}

export const UpdateNamedPromptRequest: MessageFns<UpdateNamedPromptRequest> = {
  encode(message: UpdateNamedPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedPromptId !== "") {
      writer.uint32(10).string(message.namedPromptId);
    }
    if (message.update !== undefined) {
      UpdateNamedPromptOperation.encode(message.update, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNamedPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNamedPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPromptId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.update = UpdateNamedPromptOperation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNamedPromptRequest {
    return {
      namedPromptId: isSet(object.namedPromptId) ? globalThis.String(object.namedPromptId) : "",
      update: isSet(object.update) ? UpdateNamedPromptOperation.fromJSON(object.update) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateNamedPromptRequest): unknown {
    const obj: any = {};
    if (message.namedPromptId !== "") {
      obj.namedPromptId = message.namedPromptId;
    }
    if (message.update !== undefined) {
      obj.update = UpdateNamedPromptOperation.toJSON(message.update);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },
};

function createBaseUpdateNamedPromptResponse(): UpdateNamedPromptResponse {
  return { namedPrompt: undefined };
}

export const UpdateNamedPromptResponse: MessageFns<UpdateNamedPromptResponse> = {
  encode(message: UpdateNamedPromptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedPrompt !== undefined) {
      NamedPrompt.encode(message.namedPrompt, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNamedPromptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNamedPromptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPrompt = NamedPrompt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNamedPromptResponse {
    return { namedPrompt: isSet(object.namedPrompt) ? NamedPrompt.fromJSON(object.namedPrompt) : undefined };
  },

  toJSON(message: UpdateNamedPromptResponse): unknown {
    const obj: any = {};
    if (message.namedPrompt !== undefined) {
      obj.namedPrompt = NamedPrompt.toJSON(message.namedPrompt);
    }
    return obj;
  },
};

function createBaseListPromptVariantsRequest(): ListPromptVariantsRequest {
  return { namedPromptId: undefined, evaluationRunId: undefined, cursor: undefined, limit: undefined };
}

export const ListPromptVariantsRequest: MessageFns<ListPromptVariantsRequest> = {
  encode(message: ListPromptVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedPromptId !== undefined) {
      writer.uint32(10).string(message.namedPromptId);
    }
    if (message.evaluationRunId !== undefined) {
      writer.uint32(18).string(message.evaluationRunId);
    }
    if (message.cursor !== undefined) {
      writer.uint32(26).string(message.cursor);
    }
    if (message.limit !== undefined) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPromptVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPromptVariantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPromptId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evaluationRunId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPromptVariantsRequest {
    return {
      namedPromptId: isSet(object.namedPromptId) ? globalThis.String(object.namedPromptId) : undefined,
      evaluationRunId: isSet(object.evaluationRunId) ? globalThis.String(object.evaluationRunId) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: ListPromptVariantsRequest): unknown {
    const obj: any = {};
    if (message.namedPromptId !== undefined) {
      obj.namedPromptId = message.namedPromptId;
    }
    if (message.evaluationRunId !== undefined) {
      obj.evaluationRunId = message.evaluationRunId;
    }
    if (message.cursor !== undefined) {
      obj.cursor = message.cursor;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },
};

function createBaseListPromptVariantsResponse(): ListPromptVariantsResponse {
  return { promptVariants: [], nextCursor: undefined };
}

export const ListPromptVariantsResponse: MessageFns<ListPromptVariantsResponse> = {
  encode(message: ListPromptVariantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.promptVariants) {
      PromptVariant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextCursor !== undefined) {
      writer.uint32(18).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPromptVariantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPromptVariantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.promptVariants.push(PromptVariant.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPromptVariantsResponse {
    return {
      promptVariants: globalThis.Array.isArray(object?.promptVariants)
        ? object.promptVariants.map((e: any) => PromptVariant.fromJSON(e))
        : [],
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : undefined,
    };
  },

  toJSON(message: ListPromptVariantsResponse): unknown {
    const obj: any = {};
    if (message.promptVariants?.length) {
      obj.promptVariants = message.promptVariants.map((e) => PromptVariant.toJSON(e));
    }
    if (message.nextCursor !== undefined) {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },
};

function createBaseListPromptEvaluationRunsRequest(): ListPromptEvaluationRunsRequest {
  return { cursor: undefined, limit: undefined, namedPromptId: undefined };
}

export const ListPromptEvaluationRunsRequest: MessageFns<ListPromptEvaluationRunsRequest> = {
  encode(message: ListPromptEvaluationRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      writer.uint32(10).string(message.cursor);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.namedPromptId !== undefined) {
      writer.uint32(26).string(message.namedPromptId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPromptEvaluationRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPromptEvaluationRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namedPromptId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPromptEvaluationRunsRequest {
    return {
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      namedPromptId: isSet(object.namedPromptId) ? globalThis.String(object.namedPromptId) : undefined,
    };
  },

  toJSON(message: ListPromptEvaluationRunsRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = message.cursor;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.namedPromptId !== undefined) {
      obj.namedPromptId = message.namedPromptId;
    }
    return obj;
  },
};

function createBaseListPromptEvaluationRunsResponse(): ListPromptEvaluationRunsResponse {
  return { evaluationRuns: [], nextCursor: undefined };
}

export const ListPromptEvaluationRunsResponse: MessageFns<ListPromptEvaluationRunsResponse> = {
  encode(message: ListPromptEvaluationRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.evaluationRuns) {
      PromptEvaluationRun.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextCursor !== undefined) {
      writer.uint32(18).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPromptEvaluationRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPromptEvaluationRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evaluationRuns.push(PromptEvaluationRun.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPromptEvaluationRunsResponse {
    return {
      evaluationRuns: globalThis.Array.isArray(object?.evaluationRuns)
        ? object.evaluationRuns.map((e: any) => PromptEvaluationRun.fromJSON(e))
        : [],
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : undefined,
    };
  },

  toJSON(message: ListPromptEvaluationRunsResponse): unknown {
    const obj: any = {};
    if (message.evaluationRuns?.length) {
      obj.evaluationRuns = message.evaluationRuns.map((e) => PromptEvaluationRun.toJSON(e));
    }
    if (message.nextCursor !== undefined) {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },
};

function createBaseGetPromptEvaluationRunRequest(): GetPromptEvaluationRunRequest {
  return { evaluationRunId: undefined, prefillOptions: undefined };
}

export const GetPromptEvaluationRunRequest: MessageFns<GetPromptEvaluationRunRequest> = {
  encode(message: GetPromptEvaluationRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationRunId !== undefined) {
      writer.uint32(10).string(message.evaluationRunId);
    }
    if (message.prefillOptions !== undefined) {
      GetPromptEvaluationRunRequest_PrefillOptions.encode(message.prefillOptions, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPromptEvaluationRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPromptEvaluationRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evaluationRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefillOptions = GetPromptEvaluationRunRequest_PrefillOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPromptEvaluationRunRequest {
    return {
      evaluationRunId: isSet(object.evaluationRunId) ? globalThis.String(object.evaluationRunId) : undefined,
      prefillOptions: isSet(object.prefillOptions)
        ? GetPromptEvaluationRunRequest_PrefillOptions.fromJSON(object.prefillOptions)
        : undefined,
    };
  },

  toJSON(message: GetPromptEvaluationRunRequest): unknown {
    const obj: any = {};
    if (message.evaluationRunId !== undefined) {
      obj.evaluationRunId = message.evaluationRunId;
    }
    if (message.prefillOptions !== undefined) {
      obj.prefillOptions = GetPromptEvaluationRunRequest_PrefillOptions.toJSON(message.prefillOptions);
    }
    return obj;
  },
};

function createBaseGetPromptEvaluationRunRequest_PrefillOptions(): GetPromptEvaluationRunRequest_PrefillOptions {
  return { namedPromptId: undefined, evaluationRunId: undefined };
}

export const GetPromptEvaluationRunRequest_PrefillOptions: MessageFns<GetPromptEvaluationRunRequest_PrefillOptions> = {
  encode(
    message: GetPromptEvaluationRunRequest_PrefillOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.namedPromptId !== undefined) {
      writer.uint32(10).string(message.namedPromptId);
    }
    if (message.evaluationRunId !== undefined) {
      writer.uint32(18).string(message.evaluationRunId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPromptEvaluationRunRequest_PrefillOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPromptEvaluationRunRequest_PrefillOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedPromptId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.evaluationRunId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPromptEvaluationRunRequest_PrefillOptions {
    return {
      namedPromptId: isSet(object.namedPromptId) ? globalThis.String(object.namedPromptId) : undefined,
      evaluationRunId: isSet(object.evaluationRunId) ? globalThis.String(object.evaluationRunId) : undefined,
    };
  },

  toJSON(message: GetPromptEvaluationRunRequest_PrefillOptions): unknown {
    const obj: any = {};
    if (message.namedPromptId !== undefined) {
      obj.namedPromptId = message.namedPromptId;
    }
    if (message.evaluationRunId !== undefined) {
      obj.evaluationRunId = message.evaluationRunId;
    }
    return obj;
  },
};

function createBaseGetPromptEvaluationRunResponse(): GetPromptEvaluationRunResponse {
  return { evaluationRun: undefined };
}

export const GetPromptEvaluationRunResponse: MessageFns<GetPromptEvaluationRunResponse> = {
  encode(message: GetPromptEvaluationRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationRun !== undefined) {
      PromptEvaluationRun.encode(message.evaluationRun, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPromptEvaluationRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPromptEvaluationRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evaluationRun = PromptEvaluationRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPromptEvaluationRunResponse {
    return {
      evaluationRun: isSet(object.evaluationRun) ? PromptEvaluationRun.fromJSON(object.evaluationRun) : undefined,
    };
  },

  toJSON(message: GetPromptEvaluationRunResponse): unknown {
    const obj: any = {};
    if (message.evaluationRun !== undefined) {
      obj.evaluationRun = PromptEvaluationRun.toJSON(message.evaluationRun);
    }
    return obj;
  },
};

function createBaseCreatePromptEvaluationRunRequest(): CreatePromptEvaluationRunRequest {
  return {
    branchName: "",
    datasetId: "",
    datasetRevisionId: "",
    referenceOutput: undefined,
    evaluators: [],
    relatedNamedPromptIds: [],
    relatedEvaluationIds: [],
    metaData: {},
    promptVariants: [],
  };
}

export const CreatePromptEvaluationRunRequest: MessageFns<CreatePromptEvaluationRunRequest> = {
  encode(message: CreatePromptEvaluationRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.branchName !== "") {
      writer.uint32(10).string(message.branchName);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.datasetRevisionId !== "") {
      writer.uint32(26).string(message.datasetRevisionId);
    }
    if (message.referenceOutput !== undefined) {
      writer.uint32(34).string(message.referenceOutput);
    }
    for (const v of message.evaluators) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.relatedNamedPromptIds) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.relatedEvaluationIds) {
      writer.uint32(58).string(v!);
    }
    Object.entries(message.metaData).forEach(([key, value]) => {
      if (value !== undefined) {
        CreatePromptEvaluationRunRequest_MetaDataEntry.encode({ key: key as any, value }, writer.uint32(66).fork())
          .join();
      }
    });
    for (const v of message.promptVariants) {
      PromptVariantOperation.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePromptEvaluationRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePromptEvaluationRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.branchName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.datasetRevisionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.referenceOutput = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evaluators.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.relatedNamedPromptIds.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.relatedEvaluationIds.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = CreatePromptEvaluationRunRequest_MetaDataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metaData[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.promptVariants.push(PromptVariantOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePromptEvaluationRunRequest {
    return {
      branchName: isSet(object.branchName) ? globalThis.String(object.branchName) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      datasetRevisionId: isSet(object.datasetRevisionId) ? globalThis.String(object.datasetRevisionId) : "",
      referenceOutput: isSet(object.referenceOutput) ? globalThis.String(object.referenceOutput) : undefined,
      evaluators: globalThis.Array.isArray(object?.evaluators)
        ? object.evaluators.map((e: any) => globalThis.String(e))
        : [],
      relatedNamedPromptIds: globalThis.Array.isArray(object?.relatedNamedPromptIds)
        ? object.relatedNamedPromptIds.map((e: any) => globalThis.String(e))
        : [],
      relatedEvaluationIds: globalThis.Array.isArray(object?.relatedEvaluationIds)
        ? object.relatedEvaluationIds.map((e: any) => globalThis.String(e))
        : [],
      metaData: isObject(object.metaData)
        ? Object.entries(object.metaData).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      promptVariants: globalThis.Array.isArray(object?.promptVariants)
        ? object.promptVariants.map((e: any) => PromptVariantOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreatePromptEvaluationRunRequest): unknown {
    const obj: any = {};
    if (message.branchName !== "") {
      obj.branchName = message.branchName;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.datasetRevisionId !== "") {
      obj.datasetRevisionId = message.datasetRevisionId;
    }
    if (message.referenceOutput !== undefined) {
      obj.referenceOutput = message.referenceOutput;
    }
    if (message.evaluators?.length) {
      obj.evaluators = message.evaluators;
    }
    if (message.relatedNamedPromptIds?.length) {
      obj.relatedNamedPromptIds = message.relatedNamedPromptIds;
    }
    if (message.relatedEvaluationIds?.length) {
      obj.relatedEvaluationIds = message.relatedEvaluationIds;
    }
    if (message.metaData) {
      const entries = Object.entries(message.metaData);
      if (entries.length > 0) {
        obj.metaData = {};
        entries.forEach(([k, v]) => {
          obj.metaData[k] = v;
        });
      }
    }
    if (message.promptVariants?.length) {
      obj.promptVariants = message.promptVariants.map((e) => PromptVariantOperation.toJSON(e));
    }
    return obj;
  },
};

function createBaseCreatePromptEvaluationRunRequest_MetaDataEntry(): CreatePromptEvaluationRunRequest_MetaDataEntry {
  return { key: "", value: undefined };
}

export const CreatePromptEvaluationRunRequest_MetaDataEntry: MessageFns<
  CreatePromptEvaluationRunRequest_MetaDataEntry
> = {
  encode(
    message: CreatePromptEvaluationRunRequest_MetaDataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePromptEvaluationRunRequest_MetaDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePromptEvaluationRunRequest_MetaDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePromptEvaluationRunRequest_MetaDataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: CreatePromptEvaluationRunRequest_MetaDataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseCreatePromptEvaluationRunResponse(): CreatePromptEvaluationRunResponse {
  return { evaluationRun: undefined };
}

export const CreatePromptEvaluationRunResponse: MessageFns<CreatePromptEvaluationRunResponse> = {
  encode(message: CreatePromptEvaluationRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationRun !== undefined) {
      PromptEvaluationRun.encode(message.evaluationRun, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePromptEvaluationRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePromptEvaluationRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evaluationRun = PromptEvaluationRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePromptEvaluationRunResponse {
    return {
      evaluationRun: isSet(object.evaluationRun) ? PromptEvaluationRun.fromJSON(object.evaluationRun) : undefined,
    };
  },

  toJSON(message: CreatePromptEvaluationRunResponse): unknown {
    const obj: any = {};
    if (message.evaluationRun !== undefined) {
      obj.evaluationRun = PromptEvaluationRun.toJSON(message.evaluationRun);
    }
    return obj;
  },
};

export type PromptServiceService = typeof PromptServiceService;
export const PromptServiceService = {
  /** Return a list of named prompts */
  listNamedPrompts: {
    path: "/chalk.server.v1.PromptService/ListNamedPrompts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListNamedPromptsRequest) => Buffer.from(ListNamedPromptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListNamedPromptsRequest.decode(value),
    responseSerialize: (value: ListNamedPromptsResponse) =>
      Buffer.from(ListNamedPromptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListNamedPromptsResponse.decode(value),
  },
  /** Return a single named prompt with the latest prompt variant */
  getNamedPrompt: {
    path: "/chalk.server.v1.PromptService/GetNamedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNamedPromptRequest) => Buffer.from(GetNamedPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNamedPromptRequest.decode(value),
    responseSerialize: (value: GetNamedPromptResponse) => Buffer.from(GetNamedPromptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNamedPromptResponse.decode(value),
  },
  /** Create a new named prompt and its corresponding prompt variant */
  createNamedPrompt: {
    path: "/chalk.server.v1.PromptService/CreateNamedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateNamedPromptRequest) => Buffer.from(CreateNamedPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateNamedPromptRequest.decode(value),
    responseSerialize: (value: CreateNamedPromptResponse) =>
      Buffer.from(CreateNamedPromptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateNamedPromptResponse.decode(value),
  },
  /** Modify a named prompt; may create a new prompt variant if variant settings changed */
  updateNamedPrompt: {
    path: "/chalk.server.v1.PromptService/UpdateNamedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateNamedPromptRequest) => Buffer.from(UpdateNamedPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateNamedPromptRequest.decode(value),
    responseSerialize: (value: UpdateNamedPromptResponse) =>
      Buffer.from(UpdateNamedPromptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateNamedPromptResponse.decode(value),
  },
  /** Return a list of prompt variants */
  listPromptVariants: {
    path: "/chalk.server.v1.PromptService/ListPromptVariants",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPromptVariantsRequest) =>
      Buffer.from(ListPromptVariantsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListPromptVariantsRequest.decode(value),
    responseSerialize: (value: ListPromptVariantsResponse) =>
      Buffer.from(ListPromptVariantsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListPromptVariantsResponse.decode(value),
  },
  /** Return a list of prompt evaluation runs */
  listPromptEvaluationRuns: {
    path: "/chalk.server.v1.PromptService/ListPromptEvaluationRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPromptEvaluationRunsRequest) =>
      Buffer.from(ListPromptEvaluationRunsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListPromptEvaluationRunsRequest.decode(value),
    responseSerialize: (value: ListPromptEvaluationRunsResponse) =>
      Buffer.from(ListPromptEvaluationRunsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListPromptEvaluationRunsResponse.decode(value),
  },
  /** Return a prompt evaluation run and its prompt variants */
  getPromptEvaluationRun: {
    path: "/chalk.server.v1.PromptService/GetPromptEvaluationRun",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPromptEvaluationRunRequest) =>
      Buffer.from(GetPromptEvaluationRunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPromptEvaluationRunRequest.decode(value),
    responseSerialize: (value: GetPromptEvaluationRunResponse) =>
      Buffer.from(GetPromptEvaluationRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPromptEvaluationRunResponse.decode(value),
  },
  /** Start a new prompt evaluation run */
  createPromptEvaluationRun: {
    path: "/chalk.server.v1.PromptService/CreatePromptEvaluationRun",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePromptEvaluationRunRequest) =>
      Buffer.from(CreatePromptEvaluationRunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePromptEvaluationRunRequest.decode(value),
    responseSerialize: (value: CreatePromptEvaluationRunResponse) =>
      Buffer.from(CreatePromptEvaluationRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreatePromptEvaluationRunResponse.decode(value),
  },
} as const;

export interface PromptServiceServer extends UntypedServiceImplementation {
  /** Return a list of named prompts */
  listNamedPrompts: handleUnaryCall<ListNamedPromptsRequest, ListNamedPromptsResponse>;
  /** Return a single named prompt with the latest prompt variant */
  getNamedPrompt: handleUnaryCall<GetNamedPromptRequest, GetNamedPromptResponse>;
  /** Create a new named prompt and its corresponding prompt variant */
  createNamedPrompt: handleUnaryCall<CreateNamedPromptRequest, CreateNamedPromptResponse>;
  /** Modify a named prompt; may create a new prompt variant if variant settings changed */
  updateNamedPrompt: handleUnaryCall<UpdateNamedPromptRequest, UpdateNamedPromptResponse>;
  /** Return a list of prompt variants */
  listPromptVariants: handleUnaryCall<ListPromptVariantsRequest, ListPromptVariantsResponse>;
  /** Return a list of prompt evaluation runs */
  listPromptEvaluationRuns: handleUnaryCall<ListPromptEvaluationRunsRequest, ListPromptEvaluationRunsResponse>;
  /** Return a prompt evaluation run and its prompt variants */
  getPromptEvaluationRun: handleUnaryCall<GetPromptEvaluationRunRequest, GetPromptEvaluationRunResponse>;
  /** Start a new prompt evaluation run */
  createPromptEvaluationRun: handleUnaryCall<CreatePromptEvaluationRunRequest, CreatePromptEvaluationRunResponse>;
}

export interface PromptServiceClient extends Client {
  /** Return a list of named prompts */
  listNamedPrompts(
    request: ListNamedPromptsRequest,
    callback: (error: ServiceError | null, response: ListNamedPromptsResponse) => void,
  ): ClientUnaryCall;
  listNamedPrompts(
    request: ListNamedPromptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListNamedPromptsResponse) => void,
  ): ClientUnaryCall;
  listNamedPrompts(
    request: ListNamedPromptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListNamedPromptsResponse) => void,
  ): ClientUnaryCall;
  /** Return a single named prompt with the latest prompt variant */
  getNamedPrompt(
    request: GetNamedPromptRequest,
    callback: (error: ServiceError | null, response: GetNamedPromptResponse) => void,
  ): ClientUnaryCall;
  getNamedPrompt(
    request: GetNamedPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNamedPromptResponse) => void,
  ): ClientUnaryCall;
  getNamedPrompt(
    request: GetNamedPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNamedPromptResponse) => void,
  ): ClientUnaryCall;
  /** Create a new named prompt and its corresponding prompt variant */
  createNamedPrompt(
    request: CreateNamedPromptRequest,
    callback: (error: ServiceError | null, response: CreateNamedPromptResponse) => void,
  ): ClientUnaryCall;
  createNamedPrompt(
    request: CreateNamedPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateNamedPromptResponse) => void,
  ): ClientUnaryCall;
  createNamedPrompt(
    request: CreateNamedPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateNamedPromptResponse) => void,
  ): ClientUnaryCall;
  /** Modify a named prompt; may create a new prompt variant if variant settings changed */
  updateNamedPrompt(
    request: UpdateNamedPromptRequest,
    callback: (error: ServiceError | null, response: UpdateNamedPromptResponse) => void,
  ): ClientUnaryCall;
  updateNamedPrompt(
    request: UpdateNamedPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateNamedPromptResponse) => void,
  ): ClientUnaryCall;
  updateNamedPrompt(
    request: UpdateNamedPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateNamedPromptResponse) => void,
  ): ClientUnaryCall;
  /** Return a list of prompt variants */
  listPromptVariants(
    request: ListPromptVariantsRequest,
    callback: (error: ServiceError | null, response: ListPromptVariantsResponse) => void,
  ): ClientUnaryCall;
  listPromptVariants(
    request: ListPromptVariantsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPromptVariantsResponse) => void,
  ): ClientUnaryCall;
  listPromptVariants(
    request: ListPromptVariantsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPromptVariantsResponse) => void,
  ): ClientUnaryCall;
  /** Return a list of prompt evaluation runs */
  listPromptEvaluationRuns(
    request: ListPromptEvaluationRunsRequest,
    callback: (error: ServiceError | null, response: ListPromptEvaluationRunsResponse) => void,
  ): ClientUnaryCall;
  listPromptEvaluationRuns(
    request: ListPromptEvaluationRunsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPromptEvaluationRunsResponse) => void,
  ): ClientUnaryCall;
  listPromptEvaluationRuns(
    request: ListPromptEvaluationRunsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPromptEvaluationRunsResponse) => void,
  ): ClientUnaryCall;
  /** Return a prompt evaluation run and its prompt variants */
  getPromptEvaluationRun(
    request: GetPromptEvaluationRunRequest,
    callback: (error: ServiceError | null, response: GetPromptEvaluationRunResponse) => void,
  ): ClientUnaryCall;
  getPromptEvaluationRun(
    request: GetPromptEvaluationRunRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPromptEvaluationRunResponse) => void,
  ): ClientUnaryCall;
  getPromptEvaluationRun(
    request: GetPromptEvaluationRunRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPromptEvaluationRunResponse) => void,
  ): ClientUnaryCall;
  /** Start a new prompt evaluation run */
  createPromptEvaluationRun(
    request: CreatePromptEvaluationRunRequest,
    callback: (error: ServiceError | null, response: CreatePromptEvaluationRunResponse) => void,
  ): ClientUnaryCall;
  createPromptEvaluationRun(
    request: CreatePromptEvaluationRunRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreatePromptEvaluationRunResponse) => void,
  ): ClientUnaryCall;
  createPromptEvaluationRun(
    request: CreatePromptEvaluationRunRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreatePromptEvaluationRunResponse) => void,
  ): ClientUnaryCall;
}

export const PromptServiceClient = makeGenericClientConstructor(
  PromptServiceService,
  "chalk.server.v1.PromptService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PromptServiceClient;
  service: typeof PromptServiceService;
  serviceName: string;
};

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
