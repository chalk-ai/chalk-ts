// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/server/v1/deploy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../../google/protobuf/empty.pb";
import { Export } from "../../artifacts/v1/export.pb";
import { ChalkError } from "../../common/v1/chalk_error.pb";
import { Graph } from "../../graph/v1/graph.pb";
import { Deployment, InstanceSizing } from "./deployment.pb";

export const protobufPackage = "chalk.server.v1";

export interface DeployBranchRequest {
  branchName: string;
  resetBranch: boolean;
  archive: Uint8Array;
  isHotDeploy: boolean;
}

export interface DeployBranchResponse {
  deploymentId: string;
  /** @deprecated */
  graph?: Graph | undefined;
  deploymentErrors: ChalkError[];
  export?: Export | undefined;
}

export interface CreateBranchFromSourceDeploymentRequest {
  branchName: string;
  sourceBranchName?: string | undefined;
  sourceDeploymentId?: string | undefined;
  currentMainlineDeployment?: Empty | undefined;
}

export interface CreateBranchFromSourceDeploymentResponse {
  deploymentId: string;
  deploymentErrors: ChalkError[];
  export?: Export | undefined;
  branchAlreadyExists: boolean;
}

export interface GetDeploymentRequest {
  deploymentId: string;
}

export interface GetDeploymentResponse {
  deployment: Deployment | undefined;
}

export interface ListDeploymentsRequest {
  cursor?: string | undefined;
  limit?: number | undefined;
  includeBranch?: boolean | undefined;
  branchName?: string | undefined;
}

export interface ListDeploymentsResponse {
  deployments: Deployment[];
  cursor?: string | undefined;
}

export interface SuspendDeploymentRequest {
  deploymentId: string;
}

export interface SuspendDeploymentResponse {
  deployment: Deployment | undefined;
}

export interface ScaleDeploymentRequest {
  deploymentId: string;
  sizing: InstanceSizing | undefined;
}

export interface ScaleDeploymentResponse {
  deployment: Deployment | undefined;
}

export interface TagDeploymentRequest {
  deploymentId: string;
  tag: string;
}

export interface TagDeploymentResponse {
  deployment: Deployment | undefined;
  untaggedDeploymentId?: string | undefined;
}

export interface GetActiveDeploymentsRequest {
}

export interface GetActiveDeploymentsResponse {
  deployments: Deployment[];
}

function createBaseDeployBranchRequest(): DeployBranchRequest {
  return { branchName: "", resetBranch: false, archive: new Uint8Array(0), isHotDeploy: false };
}

export const DeployBranchRequest: MessageFns<DeployBranchRequest> = {
  encode(message: DeployBranchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.branchName !== "") {
      writer.uint32(10).string(message.branchName);
    }
    if (message.resetBranch !== false) {
      writer.uint32(16).bool(message.resetBranch);
    }
    if (message.archive.length !== 0) {
      writer.uint32(26).bytes(message.archive);
    }
    if (message.isHotDeploy !== false) {
      writer.uint32(32).bool(message.isHotDeploy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployBranchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployBranchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.branchName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.resetBranch = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.archive = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isHotDeploy = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployBranchRequest {
    return {
      branchName: isSet(object.branchName) ? globalThis.String(object.branchName) : "",
      resetBranch: isSet(object.resetBranch) ? globalThis.Boolean(object.resetBranch) : false,
      archive: isSet(object.archive) ? bytesFromBase64(object.archive) : new Uint8Array(0),
      isHotDeploy: isSet(object.isHotDeploy) ? globalThis.Boolean(object.isHotDeploy) : false,
    };
  },

  toJSON(message: DeployBranchRequest): unknown {
    const obj: any = {};
    if (message.branchName !== "") {
      obj.branchName = message.branchName;
    }
    if (message.resetBranch !== false) {
      obj.resetBranch = message.resetBranch;
    }
    if (message.archive.length !== 0) {
      obj.archive = base64FromBytes(message.archive);
    }
    if (message.isHotDeploy !== false) {
      obj.isHotDeploy = message.isHotDeploy;
    }
    return obj;
  },
};

function createBaseDeployBranchResponse(): DeployBranchResponse {
  return { deploymentId: "", graph: undefined, deploymentErrors: [], export: undefined };
}

export const DeployBranchResponse: MessageFns<DeployBranchResponse> = {
  encode(message: DeployBranchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.graph !== undefined) {
      Graph.encode(message.graph, writer.uint32(18).fork()).join();
    }
    for (const v of message.deploymentErrors) {
      ChalkError.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.export !== undefined) {
      Export.encode(message.export, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployBranchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployBranchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.graph = Graph.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deploymentErrors.push(ChalkError.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.export = Export.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployBranchResponse {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      graph: isSet(object.graph) ? Graph.fromJSON(object.graph) : undefined,
      deploymentErrors: globalThis.Array.isArray(object?.deploymentErrors)
        ? object.deploymentErrors.map((e: any) => ChalkError.fromJSON(e))
        : [],
      export: isSet(object.export) ? Export.fromJSON(object.export) : undefined,
    };
  },

  toJSON(message: DeployBranchResponse): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.graph !== undefined) {
      obj.graph = Graph.toJSON(message.graph);
    }
    if (message.deploymentErrors?.length) {
      obj.deploymentErrors = message.deploymentErrors.map((e) => ChalkError.toJSON(e));
    }
    if (message.export !== undefined) {
      obj.export = Export.toJSON(message.export);
    }
    return obj;
  },
};

function createBaseCreateBranchFromSourceDeploymentRequest(): CreateBranchFromSourceDeploymentRequest {
  return {
    branchName: "",
    sourceBranchName: undefined,
    sourceDeploymentId: undefined,
    currentMainlineDeployment: undefined,
  };
}

export const CreateBranchFromSourceDeploymentRequest: MessageFns<CreateBranchFromSourceDeploymentRequest> = {
  encode(message: CreateBranchFromSourceDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.branchName !== "") {
      writer.uint32(10).string(message.branchName);
    }
    if (message.sourceBranchName !== undefined) {
      writer.uint32(18).string(message.sourceBranchName);
    }
    if (message.sourceDeploymentId !== undefined) {
      writer.uint32(26).string(message.sourceDeploymentId);
    }
    if (message.currentMainlineDeployment !== undefined) {
      Empty.encode(message.currentMainlineDeployment, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBranchFromSourceDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBranchFromSourceDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.branchName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceBranchName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceDeploymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currentMainlineDeployment = Empty.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBranchFromSourceDeploymentRequest {
    return {
      branchName: isSet(object.branchName) ? globalThis.String(object.branchName) : "",
      sourceBranchName: isSet(object.sourceBranchName) ? globalThis.String(object.sourceBranchName) : undefined,
      sourceDeploymentId: isSet(object.sourceDeploymentId) ? globalThis.String(object.sourceDeploymentId) : undefined,
      currentMainlineDeployment: isSet(object.currentMainlineDeployment)
        ? Empty.fromJSON(object.currentMainlineDeployment)
        : undefined,
    };
  },

  toJSON(message: CreateBranchFromSourceDeploymentRequest): unknown {
    const obj: any = {};
    if (message.branchName !== "") {
      obj.branchName = message.branchName;
    }
    if (message.sourceBranchName !== undefined) {
      obj.sourceBranchName = message.sourceBranchName;
    }
    if (message.sourceDeploymentId !== undefined) {
      obj.sourceDeploymentId = message.sourceDeploymentId;
    }
    if (message.currentMainlineDeployment !== undefined) {
      obj.currentMainlineDeployment = Empty.toJSON(message.currentMainlineDeployment);
    }
    return obj;
  },
};

function createBaseCreateBranchFromSourceDeploymentResponse(): CreateBranchFromSourceDeploymentResponse {
  return { deploymentId: "", deploymentErrors: [], export: undefined, branchAlreadyExists: false };
}

export const CreateBranchFromSourceDeploymentResponse: MessageFns<CreateBranchFromSourceDeploymentResponse> = {
  encode(message: CreateBranchFromSourceDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    for (const v of message.deploymentErrors) {
      ChalkError.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.export !== undefined) {
      Export.encode(message.export, writer.uint32(26).fork()).join();
    }
    if (message.branchAlreadyExists !== false) {
      writer.uint32(32).bool(message.branchAlreadyExists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBranchFromSourceDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBranchFromSourceDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deploymentErrors.push(ChalkError.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.export = Export.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.branchAlreadyExists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBranchFromSourceDeploymentResponse {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      deploymentErrors: globalThis.Array.isArray(object?.deploymentErrors)
        ? object.deploymentErrors.map((e: any) => ChalkError.fromJSON(e))
        : [],
      export: isSet(object.export) ? Export.fromJSON(object.export) : undefined,
      branchAlreadyExists: isSet(object.branchAlreadyExists) ? globalThis.Boolean(object.branchAlreadyExists) : false,
    };
  },

  toJSON(message: CreateBranchFromSourceDeploymentResponse): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.deploymentErrors?.length) {
      obj.deploymentErrors = message.deploymentErrors.map((e) => ChalkError.toJSON(e));
    }
    if (message.export !== undefined) {
      obj.export = Export.toJSON(message.export);
    }
    if (message.branchAlreadyExists !== false) {
      obj.branchAlreadyExists = message.branchAlreadyExists;
    }
    return obj;
  },
};

function createBaseGetDeploymentRequest(): GetDeploymentRequest {
  return { deploymentId: "" };
}

export const GetDeploymentRequest: MessageFns<GetDeploymentRequest> = {
  encode(message: GetDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentRequest {
    return { deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "" };
  },

  toJSON(message: GetDeploymentRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },
};

function createBaseGetDeploymentResponse(): GetDeploymentResponse {
  return { deployment: undefined };
}

export const GetDeploymentResponse: MessageFns<GetDeploymentResponse> = {
  encode(message: GetDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentResponse {
    return { deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined };
  },

  toJSON(message: GetDeploymentResponse): unknown {
    const obj: any = {};
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },
};

function createBaseListDeploymentsRequest(): ListDeploymentsRequest {
  return { cursor: undefined, limit: undefined, includeBranch: undefined, branchName: undefined };
}

export const ListDeploymentsRequest: MessageFns<ListDeploymentsRequest> = {
  encode(message: ListDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      writer.uint32(10).string(message.cursor);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.includeBranch !== undefined) {
      writer.uint32(24).bool(message.includeBranch);
    }
    if (message.branchName !== undefined) {
      writer.uint32(34).string(message.branchName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeBranch = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.branchName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentsRequest {
    return {
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      includeBranch: isSet(object.includeBranch) ? globalThis.Boolean(object.includeBranch) : undefined,
      branchName: isSet(object.branchName) ? globalThis.String(object.branchName) : undefined,
    };
  },

  toJSON(message: ListDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = message.cursor;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.includeBranch !== undefined) {
      obj.includeBranch = message.includeBranch;
    }
    if (message.branchName !== undefined) {
      obj.branchName = message.branchName;
    }
    return obj;
  },
};

function createBaseListDeploymentsResponse(): ListDeploymentsResponse {
  return { deployments: [], cursor: undefined };
}

export const ListDeploymentsResponse: MessageFns<ListDeploymentsResponse> = {
  encode(message: ListDeploymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      writer.uint32(18).string(message.cursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentsResponse {
    return {
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : undefined,
    };
  },

  toJSON(message: ListDeploymentsResponse): unknown {
    const obj: any = {};
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = message.cursor;
    }
    return obj;
  },
};

function createBaseSuspendDeploymentRequest(): SuspendDeploymentRequest {
  return { deploymentId: "" };
}

export const SuspendDeploymentRequest: MessageFns<SuspendDeploymentRequest> = {
  encode(message: SuspendDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuspendDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuspendDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuspendDeploymentRequest {
    return { deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "" };
  },

  toJSON(message: SuspendDeploymentRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    return obj;
  },
};

function createBaseSuspendDeploymentResponse(): SuspendDeploymentResponse {
  return { deployment: undefined };
}

export const SuspendDeploymentResponse: MessageFns<SuspendDeploymentResponse> = {
  encode(message: SuspendDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuspendDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuspendDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuspendDeploymentResponse {
    return { deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined };
  },

  toJSON(message: SuspendDeploymentResponse): unknown {
    const obj: any = {};
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },
};

function createBaseScaleDeploymentRequest(): ScaleDeploymentRequest {
  return { deploymentId: "", sizing: undefined };
}

export const ScaleDeploymentRequest: MessageFns<ScaleDeploymentRequest> = {
  encode(message: ScaleDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.sizing !== undefined) {
      InstanceSizing.encode(message.sizing, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScaleDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sizing = InstanceSizing.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScaleDeploymentRequest {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      sizing: isSet(object.sizing) ? InstanceSizing.fromJSON(object.sizing) : undefined,
    };
  },

  toJSON(message: ScaleDeploymentRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.sizing !== undefined) {
      obj.sizing = InstanceSizing.toJSON(message.sizing);
    }
    return obj;
  },
};

function createBaseScaleDeploymentResponse(): ScaleDeploymentResponse {
  return { deployment: undefined };
}

export const ScaleDeploymentResponse: MessageFns<ScaleDeploymentResponse> = {
  encode(message: ScaleDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScaleDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScaleDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScaleDeploymentResponse {
    return { deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined };
  },

  toJSON(message: ScaleDeploymentResponse): unknown {
    const obj: any = {};
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },
};

function createBaseTagDeploymentRequest(): TagDeploymentRequest {
  return { deploymentId: "", tag: "" };
}

export const TagDeploymentRequest: MessageFns<TagDeploymentRequest> = {
  encode(message: TagDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deploymentId !== "") {
      writer.uint32(10).string(message.deploymentId);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagDeploymentRequest {
    return {
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: TagDeploymentRequest): unknown {
    const obj: any = {};
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },
};

function createBaseTagDeploymentResponse(): TagDeploymentResponse {
  return { deployment: undefined, untaggedDeploymentId: undefined };
}

export const TagDeploymentResponse: MessageFns<TagDeploymentResponse> = {
  encode(message: TagDeploymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(10).fork()).join();
    }
    if (message.untaggedDeploymentId !== undefined) {
      writer.uint32(18).string(message.untaggedDeploymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagDeploymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagDeploymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.untaggedDeploymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagDeploymentResponse {
    return {
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
      untaggedDeploymentId: isSet(object.untaggedDeploymentId)
        ? globalThis.String(object.untaggedDeploymentId)
        : undefined,
    };
  },

  toJSON(message: TagDeploymentResponse): unknown {
    const obj: any = {};
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    if (message.untaggedDeploymentId !== undefined) {
      obj.untaggedDeploymentId = message.untaggedDeploymentId;
    }
    return obj;
  },
};

function createBaseGetActiveDeploymentsRequest(): GetActiveDeploymentsRequest {
  return {};
}

export const GetActiveDeploymentsRequest: MessageFns<GetActiveDeploymentsRequest> = {
  encode(_: GetActiveDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetActiveDeploymentsRequest {
    return {};
  },

  toJSON(_: GetActiveDeploymentsRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

function createBaseGetActiveDeploymentsResponse(): GetActiveDeploymentsResponse {
  return { deployments: [] };
}

export const GetActiveDeploymentsResponse: MessageFns<GetActiveDeploymentsResponse> = {
  encode(message: GetActiveDeploymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveDeploymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveDeploymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveDeploymentsResponse {
    return {
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetActiveDeploymentsResponse): unknown {
    const obj: any = {};
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    return obj;
  },
};

export type DeployServiceService = typeof DeployServiceService;
export const DeployServiceService = {
  deployBranch: {
    path: "/chalk.server.v1.DeployService/DeployBranch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeployBranchRequest) => Buffer.from(DeployBranchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeployBranchRequest.decode(value),
    responseSerialize: (value: DeployBranchResponse) => Buffer.from(DeployBranchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeployBranchResponse.decode(value),
  },
  createBranchFromSourceDeployment: {
    path: "/chalk.server.v1.DeployService/CreateBranchFromSourceDeployment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBranchFromSourceDeploymentRequest) =>
      Buffer.from(CreateBranchFromSourceDeploymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateBranchFromSourceDeploymentRequest.decode(value),
    responseSerialize: (value: CreateBranchFromSourceDeploymentResponse) =>
      Buffer.from(CreateBranchFromSourceDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateBranchFromSourceDeploymentResponse.decode(value),
  },
  getDeployment: {
    path: "/chalk.server.v1.DeployService/GetDeployment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDeploymentRequest) => Buffer.from(GetDeploymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDeploymentRequest.decode(value),
    responseSerialize: (value: GetDeploymentResponse) => Buffer.from(GetDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDeploymentResponse.decode(value),
  },
  listDeployments: {
    path: "/chalk.server.v1.DeployService/ListDeployments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDeploymentsRequest) => Buffer.from(ListDeploymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListDeploymentsRequest.decode(value),
    responseSerialize: (value: ListDeploymentsResponse) => Buffer.from(ListDeploymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListDeploymentsResponse.decode(value),
  },
  getActiveDeployments: {
    path: "/chalk.server.v1.DeployService/GetActiveDeployments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetActiveDeploymentsRequest) =>
      Buffer.from(GetActiveDeploymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetActiveDeploymentsRequest.decode(value),
    responseSerialize: (value: GetActiveDeploymentsResponse) =>
      Buffer.from(GetActiveDeploymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetActiveDeploymentsResponse.decode(value),
  },
  suspendDeployment: {
    path: "/chalk.server.v1.DeployService/SuspendDeployment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SuspendDeploymentRequest) => Buffer.from(SuspendDeploymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SuspendDeploymentRequest.decode(value),
    responseSerialize: (value: SuspendDeploymentResponse) =>
      Buffer.from(SuspendDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SuspendDeploymentResponse.decode(value),
  },
  scaleDeployment: {
    path: "/chalk.server.v1.DeployService/ScaleDeployment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ScaleDeploymentRequest) => Buffer.from(ScaleDeploymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ScaleDeploymentRequest.decode(value),
    responseSerialize: (value: ScaleDeploymentResponse) => Buffer.from(ScaleDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScaleDeploymentResponse.decode(value),
  },
  tagDeployment: {
    path: "/chalk.server.v1.DeployService/TagDeployment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TagDeploymentRequest) => Buffer.from(TagDeploymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TagDeploymentRequest.decode(value),
    responseSerialize: (value: TagDeploymentResponse) => Buffer.from(TagDeploymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TagDeploymentResponse.decode(value),
  },
} as const;

export interface DeployServiceServer extends UntypedServiceImplementation {
  deployBranch: handleUnaryCall<DeployBranchRequest, DeployBranchResponse>;
  createBranchFromSourceDeployment: handleUnaryCall<
    CreateBranchFromSourceDeploymentRequest,
    CreateBranchFromSourceDeploymentResponse
  >;
  getDeployment: handleUnaryCall<GetDeploymentRequest, GetDeploymentResponse>;
  listDeployments: handleUnaryCall<ListDeploymentsRequest, ListDeploymentsResponse>;
  getActiveDeployments: handleUnaryCall<GetActiveDeploymentsRequest, GetActiveDeploymentsResponse>;
  suspendDeployment: handleUnaryCall<SuspendDeploymentRequest, SuspendDeploymentResponse>;
  scaleDeployment: handleUnaryCall<ScaleDeploymentRequest, ScaleDeploymentResponse>;
  tagDeployment: handleUnaryCall<TagDeploymentRequest, TagDeploymentResponse>;
}

export interface DeployServiceClient extends Client {
  deployBranch(
    request: DeployBranchRequest,
    callback: (error: ServiceError | null, response: DeployBranchResponse) => void,
  ): ClientUnaryCall;
  deployBranch(
    request: DeployBranchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeployBranchResponse) => void,
  ): ClientUnaryCall;
  deployBranch(
    request: DeployBranchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeployBranchResponse) => void,
  ): ClientUnaryCall;
  createBranchFromSourceDeployment(
    request: CreateBranchFromSourceDeploymentRequest,
    callback: (error: ServiceError | null, response: CreateBranchFromSourceDeploymentResponse) => void,
  ): ClientUnaryCall;
  createBranchFromSourceDeployment(
    request: CreateBranchFromSourceDeploymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBranchFromSourceDeploymentResponse) => void,
  ): ClientUnaryCall;
  createBranchFromSourceDeployment(
    request: CreateBranchFromSourceDeploymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBranchFromSourceDeploymentResponse) => void,
  ): ClientUnaryCall;
  getDeployment(
    request: GetDeploymentRequest,
    callback: (error: ServiceError | null, response: GetDeploymentResponse) => void,
  ): ClientUnaryCall;
  getDeployment(
    request: GetDeploymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDeploymentResponse) => void,
  ): ClientUnaryCall;
  getDeployment(
    request: GetDeploymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDeploymentResponse) => void,
  ): ClientUnaryCall;
  listDeployments(
    request: ListDeploymentsRequest,
    callback: (error: ServiceError | null, response: ListDeploymentsResponse) => void,
  ): ClientUnaryCall;
  listDeployments(
    request: ListDeploymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListDeploymentsResponse) => void,
  ): ClientUnaryCall;
  listDeployments(
    request: ListDeploymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListDeploymentsResponse) => void,
  ): ClientUnaryCall;
  getActiveDeployments(
    request: GetActiveDeploymentsRequest,
    callback: (error: ServiceError | null, response: GetActiveDeploymentsResponse) => void,
  ): ClientUnaryCall;
  getActiveDeployments(
    request: GetActiveDeploymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetActiveDeploymentsResponse) => void,
  ): ClientUnaryCall;
  getActiveDeployments(
    request: GetActiveDeploymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetActiveDeploymentsResponse) => void,
  ): ClientUnaryCall;
  suspendDeployment(
    request: SuspendDeploymentRequest,
    callback: (error: ServiceError | null, response: SuspendDeploymentResponse) => void,
  ): ClientUnaryCall;
  suspendDeployment(
    request: SuspendDeploymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SuspendDeploymentResponse) => void,
  ): ClientUnaryCall;
  suspendDeployment(
    request: SuspendDeploymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SuspendDeploymentResponse) => void,
  ): ClientUnaryCall;
  scaleDeployment(
    request: ScaleDeploymentRequest,
    callback: (error: ServiceError | null, response: ScaleDeploymentResponse) => void,
  ): ClientUnaryCall;
  scaleDeployment(
    request: ScaleDeploymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScaleDeploymentResponse) => void,
  ): ClientUnaryCall;
  scaleDeployment(
    request: ScaleDeploymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScaleDeploymentResponse) => void,
  ): ClientUnaryCall;
  tagDeployment(
    request: TagDeploymentRequest,
    callback: (error: ServiceError | null, response: TagDeploymentResponse) => void,
  ): ClientUnaryCall;
  tagDeployment(
    request: TagDeploymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TagDeploymentResponse) => void,
  ): ClientUnaryCall;
  tagDeployment(
    request: TagDeploymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TagDeploymentResponse) => void,
  ): ClientUnaryCall;
}

export const DeployServiceClient = makeGenericClientConstructor(
  DeployServiceService,
  "chalk.server.v1.DeployService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DeployServiceClient;
  service: typeof DeployServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
