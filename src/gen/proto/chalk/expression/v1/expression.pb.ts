// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/expression/v1/expression.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ArrowType, ScalarValue } from "../../arrow/v1/arrow.pb";

export const protobufPackage = "chalk.expression.v1";

export enum ScalarFunction {
  SCALAR_FUNCTION_UNSPECIFIED = 0,
  SCALAR_FUNCTION_ABS = 1,
  SCALAR_FUNCTION_ACOS = 2,
  SCALAR_FUNCTION_ASIN = 3,
  SCALAR_FUNCTION_ATAN = 4,
  SCALAR_FUNCTION_ASCII = 5,
  SCALAR_FUNCTION_CEIL = 6,
  SCALAR_FUNCTION_COS = 7,
  SCALAR_FUNCTION_DIGEST = 8,
  SCALAR_FUNCTION_EXP = 9,
  SCALAR_FUNCTION_FLOOR = 10,
  SCALAR_FUNCTION_LN = 11,
  SCALAR_FUNCTION_LOG = 12,
  SCALAR_FUNCTION_LOG10 = 13,
  SCALAR_FUNCTION_LOG2 = 14,
  SCALAR_FUNCTION_ROUND = 15,
  SCALAR_FUNCTION_SIGNUM = 16,
  SCALAR_FUNCTION_SIN = 17,
  SCALAR_FUNCTION_SQRT = 18,
  SCALAR_FUNCTION_TAN = 19,
  SCALAR_FUNCTION_TRUNC = 20,
  SCALAR_FUNCTION_ARRAY = 21,
  SCALAR_FUNCTION_REGEXP_MATCH = 22,
  SCALAR_FUNCTION_BIT_LENGTH = 23,
  SCALAR_FUNCTION_BTRIM = 24,
  SCALAR_FUNCTION_CHARACTER_LENGTH = 25,
  SCALAR_FUNCTION_CHR = 26,
  SCALAR_FUNCTION_CONCAT = 27,
  SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR = 28,
  SCALAR_FUNCTION_DATE_PART = 29,
  SCALAR_FUNCTION_DATE_TRUNC = 30,
  SCALAR_FUNCTION_INIT_CAP = 31,
  SCALAR_FUNCTION_LEFT = 32,
  SCALAR_FUNCTION_LPAD = 33,
  SCALAR_FUNCTION_LOWER = 34,
  SCALAR_FUNCTION_LTRIM = 35,
  SCALAR_FUNCTION_MD5 = 36,
  SCALAR_FUNCTION_NULL_IF = 37,
  SCALAR_FUNCTION_OCTET_LENGTH = 38,
  SCALAR_FUNCTION_RANDOM = 39,
  SCALAR_FUNCTION_REGEXP_REPLACE = 40,
  SCALAR_FUNCTION_REPEAT = 41,
  SCALAR_FUNCTION_REPLACE = 42,
  SCALAR_FUNCTION_REVERSE = 43,
  SCALAR_FUNCTION_RIGHT = 44,
  SCALAR_FUNCTION_RPAD = 45,
  SCALAR_FUNCTION_RTRIM = 46,
  SCALAR_FUNCTION_SHA224 = 47,
  SCALAR_FUNCTION_SHA256 = 48,
  SCALAR_FUNCTION_SHA384 = 49,
  SCALAR_FUNCTION_SHA512 = 50,
  SCALAR_FUNCTION_SPLIT_PART = 51,
  SCALAR_FUNCTION_STARTS_WITH = 52,
  SCALAR_FUNCTION_STRPOS = 53,
  SCALAR_FUNCTION_SUBSTR = 54,
  SCALAR_FUNCTION_TO_HEX = 55,
  SCALAR_FUNCTION_TO_TIMESTAMP = 56,
  SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS = 57,
  SCALAR_FUNCTION_TO_TIMESTAMP_MICROS = 58,
  SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS = 59,
  SCALAR_FUNCTION_NOW = 60,
  SCALAR_FUNCTION_TRANSLATE = 61,
  SCALAR_FUNCTION_TRIM = 62,
  SCALAR_FUNCTION_UPPER = 63,
  SCALAR_FUNCTION_COALESCE = 64,
  SCALAR_FUNCTION_POWER = 65,
  SCALAR_FUNCTION_STRUCT_FUN = 66,
  SCALAR_FUNCTION_FROM_UNIXTIME = 67,
  SCALAR_FUNCTION_ATAN2 = 68,
  SCALAR_FUNCTION_DATE_BIN = 69,
  SCALAR_FUNCTION_ARROW_TYPEOF = 70,
  SCALAR_FUNCTION_CURRENT_DATE = 71,
  SCALAR_FUNCTION_CURRENT_TIME = 72,
  SCALAR_FUNCTION_UUID = 73,
  SCALAR_FUNCTION_CBRT = 74,
  SCALAR_FUNCTION_ACOSH = 75,
  SCALAR_FUNCTION_ASINH = 76,
  SCALAR_FUNCTION_ATANH = 77,
  SCALAR_FUNCTION_SINH = 78,
  SCALAR_FUNCTION_COSH = 79,
  SCALAR_FUNCTION_TANH = 80,
  SCALAR_FUNCTION_PI = 81,
  SCALAR_FUNCTION_DEGREES = 82,
  SCALAR_FUNCTION_RADIANS = 83,
  SCALAR_FUNCTION_FACTORIAL = 84,
  SCALAR_FUNCTION_LCM = 85,
  SCALAR_FUNCTION_GCD = 86,
  SCALAR_FUNCTION_ARRAY_APPEND = 87,
  SCALAR_FUNCTION_ARRAY_CONCAT = 88,
  SCALAR_FUNCTION_ARRAY_DIMS = 89,
  SCALAR_FUNCTION_ARRAY_REPEAT = 90,
  SCALAR_FUNCTION_ARRAY_LENGTH = 91,
  SCALAR_FUNCTION_ARRAY_NDIMS = 92,
  SCALAR_FUNCTION_ARRAY_POSITION = 93,
  SCALAR_FUNCTION_ARRAY_POSITIONS = 94,
  SCALAR_FUNCTION_ARRAY_PREPEND = 95,
  SCALAR_FUNCTION_ARRAY_REMOVE = 96,
  SCALAR_FUNCTION_ARRAY_REPLACE = 97,
  SCALAR_FUNCTION_ARRAY_TO_STRING = 98,
  SCALAR_FUNCTION_CARDINALITY = 99,
  SCALAR_FUNCTION_ARRAY_ELEMENT = 100,
  SCALAR_FUNCTION_ARRAY_SLICE = 101,
  SCALAR_FUNCTION_ENCODE = 102,
  SCALAR_FUNCTION_DECODE = 103,
  SCALAR_FUNCTION_COT = 104,
  SCALAR_FUNCTION_ARRAY_HAS = 105,
  SCALAR_FUNCTION_ARRAY_HAS_ANY = 106,
  SCALAR_FUNCTION_ARRAY_HAS_ALL = 107,
  SCALAR_FUNCTION_ARRAY_REMOVE_N = 108,
  SCALAR_FUNCTION_ARRAY_REPLACE_N = 109,
  SCALAR_FUNCTION_ARRAY_REMOVE_ALL = 110,
  SCALAR_FUNCTION_ARRAY_REPLACE_ALL = 111,
  SCALAR_FUNCTION_NANVL = 112,
  SCALAR_FUNCTION_FLATTEN = 113,
  SCALAR_FUNCTION_ISNAN = 114,
  SCALAR_FUNCTION_ISZERO = 115,
  SCALAR_FUNCTION_ARRAY_EMPTY = 116,
  SCALAR_FUNCTION_ARRAY_POP_BACK = 117,
  SCALAR_FUNCTION_STRING_TO_ARRAY = 118,
  SCALAR_FUNCTION_TO_TIMESTAMP_NANOS = 119,
  SCALAR_FUNCTION_ARRAY_INTERSECT = 120,
  SCALAR_FUNCTION_ARRAY_UNION = 121,
  SCALAR_FUNCTION_OVER_LAY = 122,
  SCALAR_FUNCTION_RANGE = 123,
  SCALAR_FUNCTION_ARRAY_EXCEPT = 124,
  SCALAR_FUNCTION_ARRAY_POP_FRONT = 125,
  SCALAR_FUNCTION_LEVENSHTEIN = 126,
  SCALAR_FUNCTION_SUBSTR_INDEX = 127,
  SCALAR_FUNCTION_FIND_IN_SET = 128,
  SCALAR_FUNCTION_ARRAY_SORT = 129,
  SCALAR_FUNCTION_ARRAY_DISTINCT = 130,
  UNRECOGNIZED = -1,
}

export function scalarFunctionFromJSON(object: any): ScalarFunction {
  switch (object) {
    case 0:
    case "SCALAR_FUNCTION_UNSPECIFIED":
      return ScalarFunction.SCALAR_FUNCTION_UNSPECIFIED;
    case 1:
    case "SCALAR_FUNCTION_ABS":
      return ScalarFunction.SCALAR_FUNCTION_ABS;
    case 2:
    case "SCALAR_FUNCTION_ACOS":
      return ScalarFunction.SCALAR_FUNCTION_ACOS;
    case 3:
    case "SCALAR_FUNCTION_ASIN":
      return ScalarFunction.SCALAR_FUNCTION_ASIN;
    case 4:
    case "SCALAR_FUNCTION_ATAN":
      return ScalarFunction.SCALAR_FUNCTION_ATAN;
    case 5:
    case "SCALAR_FUNCTION_ASCII":
      return ScalarFunction.SCALAR_FUNCTION_ASCII;
    case 6:
    case "SCALAR_FUNCTION_CEIL":
      return ScalarFunction.SCALAR_FUNCTION_CEIL;
    case 7:
    case "SCALAR_FUNCTION_COS":
      return ScalarFunction.SCALAR_FUNCTION_COS;
    case 8:
    case "SCALAR_FUNCTION_DIGEST":
      return ScalarFunction.SCALAR_FUNCTION_DIGEST;
    case 9:
    case "SCALAR_FUNCTION_EXP":
      return ScalarFunction.SCALAR_FUNCTION_EXP;
    case 10:
    case "SCALAR_FUNCTION_FLOOR":
      return ScalarFunction.SCALAR_FUNCTION_FLOOR;
    case 11:
    case "SCALAR_FUNCTION_LN":
      return ScalarFunction.SCALAR_FUNCTION_LN;
    case 12:
    case "SCALAR_FUNCTION_LOG":
      return ScalarFunction.SCALAR_FUNCTION_LOG;
    case 13:
    case "SCALAR_FUNCTION_LOG10":
      return ScalarFunction.SCALAR_FUNCTION_LOG10;
    case 14:
    case "SCALAR_FUNCTION_LOG2":
      return ScalarFunction.SCALAR_FUNCTION_LOG2;
    case 15:
    case "SCALAR_FUNCTION_ROUND":
      return ScalarFunction.SCALAR_FUNCTION_ROUND;
    case 16:
    case "SCALAR_FUNCTION_SIGNUM":
      return ScalarFunction.SCALAR_FUNCTION_SIGNUM;
    case 17:
    case "SCALAR_FUNCTION_SIN":
      return ScalarFunction.SCALAR_FUNCTION_SIN;
    case 18:
    case "SCALAR_FUNCTION_SQRT":
      return ScalarFunction.SCALAR_FUNCTION_SQRT;
    case 19:
    case "SCALAR_FUNCTION_TAN":
      return ScalarFunction.SCALAR_FUNCTION_TAN;
    case 20:
    case "SCALAR_FUNCTION_TRUNC":
      return ScalarFunction.SCALAR_FUNCTION_TRUNC;
    case 21:
    case "SCALAR_FUNCTION_ARRAY":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY;
    case 22:
    case "SCALAR_FUNCTION_REGEXP_MATCH":
      return ScalarFunction.SCALAR_FUNCTION_REGEXP_MATCH;
    case 23:
    case "SCALAR_FUNCTION_BIT_LENGTH":
      return ScalarFunction.SCALAR_FUNCTION_BIT_LENGTH;
    case 24:
    case "SCALAR_FUNCTION_BTRIM":
      return ScalarFunction.SCALAR_FUNCTION_BTRIM;
    case 25:
    case "SCALAR_FUNCTION_CHARACTER_LENGTH":
      return ScalarFunction.SCALAR_FUNCTION_CHARACTER_LENGTH;
    case 26:
    case "SCALAR_FUNCTION_CHR":
      return ScalarFunction.SCALAR_FUNCTION_CHR;
    case 27:
    case "SCALAR_FUNCTION_CONCAT":
      return ScalarFunction.SCALAR_FUNCTION_CONCAT;
    case 28:
    case "SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR":
      return ScalarFunction.SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR;
    case 29:
    case "SCALAR_FUNCTION_DATE_PART":
      return ScalarFunction.SCALAR_FUNCTION_DATE_PART;
    case 30:
    case "SCALAR_FUNCTION_DATE_TRUNC":
      return ScalarFunction.SCALAR_FUNCTION_DATE_TRUNC;
    case 31:
    case "SCALAR_FUNCTION_INIT_CAP":
      return ScalarFunction.SCALAR_FUNCTION_INIT_CAP;
    case 32:
    case "SCALAR_FUNCTION_LEFT":
      return ScalarFunction.SCALAR_FUNCTION_LEFT;
    case 33:
    case "SCALAR_FUNCTION_LPAD":
      return ScalarFunction.SCALAR_FUNCTION_LPAD;
    case 34:
    case "SCALAR_FUNCTION_LOWER":
      return ScalarFunction.SCALAR_FUNCTION_LOWER;
    case 35:
    case "SCALAR_FUNCTION_LTRIM":
      return ScalarFunction.SCALAR_FUNCTION_LTRIM;
    case 36:
    case "SCALAR_FUNCTION_MD5":
      return ScalarFunction.SCALAR_FUNCTION_MD5;
    case 37:
    case "SCALAR_FUNCTION_NULL_IF":
      return ScalarFunction.SCALAR_FUNCTION_NULL_IF;
    case 38:
    case "SCALAR_FUNCTION_OCTET_LENGTH":
      return ScalarFunction.SCALAR_FUNCTION_OCTET_LENGTH;
    case 39:
    case "SCALAR_FUNCTION_RANDOM":
      return ScalarFunction.SCALAR_FUNCTION_RANDOM;
    case 40:
    case "SCALAR_FUNCTION_REGEXP_REPLACE":
      return ScalarFunction.SCALAR_FUNCTION_REGEXP_REPLACE;
    case 41:
    case "SCALAR_FUNCTION_REPEAT":
      return ScalarFunction.SCALAR_FUNCTION_REPEAT;
    case 42:
    case "SCALAR_FUNCTION_REPLACE":
      return ScalarFunction.SCALAR_FUNCTION_REPLACE;
    case 43:
    case "SCALAR_FUNCTION_REVERSE":
      return ScalarFunction.SCALAR_FUNCTION_REVERSE;
    case 44:
    case "SCALAR_FUNCTION_RIGHT":
      return ScalarFunction.SCALAR_FUNCTION_RIGHT;
    case 45:
    case "SCALAR_FUNCTION_RPAD":
      return ScalarFunction.SCALAR_FUNCTION_RPAD;
    case 46:
    case "SCALAR_FUNCTION_RTRIM":
      return ScalarFunction.SCALAR_FUNCTION_RTRIM;
    case 47:
    case "SCALAR_FUNCTION_SHA224":
      return ScalarFunction.SCALAR_FUNCTION_SHA224;
    case 48:
    case "SCALAR_FUNCTION_SHA256":
      return ScalarFunction.SCALAR_FUNCTION_SHA256;
    case 49:
    case "SCALAR_FUNCTION_SHA384":
      return ScalarFunction.SCALAR_FUNCTION_SHA384;
    case 50:
    case "SCALAR_FUNCTION_SHA512":
      return ScalarFunction.SCALAR_FUNCTION_SHA512;
    case 51:
    case "SCALAR_FUNCTION_SPLIT_PART":
      return ScalarFunction.SCALAR_FUNCTION_SPLIT_PART;
    case 52:
    case "SCALAR_FUNCTION_STARTS_WITH":
      return ScalarFunction.SCALAR_FUNCTION_STARTS_WITH;
    case 53:
    case "SCALAR_FUNCTION_STRPOS":
      return ScalarFunction.SCALAR_FUNCTION_STRPOS;
    case 54:
    case "SCALAR_FUNCTION_SUBSTR":
      return ScalarFunction.SCALAR_FUNCTION_SUBSTR;
    case 55:
    case "SCALAR_FUNCTION_TO_HEX":
      return ScalarFunction.SCALAR_FUNCTION_TO_HEX;
    case 56:
    case "SCALAR_FUNCTION_TO_TIMESTAMP":
      return ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP;
    case 57:
    case "SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS":
      return ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS;
    case 58:
    case "SCALAR_FUNCTION_TO_TIMESTAMP_MICROS":
      return ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_MICROS;
    case 59:
    case "SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS":
      return ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS;
    case 60:
    case "SCALAR_FUNCTION_NOW":
      return ScalarFunction.SCALAR_FUNCTION_NOW;
    case 61:
    case "SCALAR_FUNCTION_TRANSLATE":
      return ScalarFunction.SCALAR_FUNCTION_TRANSLATE;
    case 62:
    case "SCALAR_FUNCTION_TRIM":
      return ScalarFunction.SCALAR_FUNCTION_TRIM;
    case 63:
    case "SCALAR_FUNCTION_UPPER":
      return ScalarFunction.SCALAR_FUNCTION_UPPER;
    case 64:
    case "SCALAR_FUNCTION_COALESCE":
      return ScalarFunction.SCALAR_FUNCTION_COALESCE;
    case 65:
    case "SCALAR_FUNCTION_POWER":
      return ScalarFunction.SCALAR_FUNCTION_POWER;
    case 66:
    case "SCALAR_FUNCTION_STRUCT_FUN":
      return ScalarFunction.SCALAR_FUNCTION_STRUCT_FUN;
    case 67:
    case "SCALAR_FUNCTION_FROM_UNIXTIME":
      return ScalarFunction.SCALAR_FUNCTION_FROM_UNIXTIME;
    case 68:
    case "SCALAR_FUNCTION_ATAN2":
      return ScalarFunction.SCALAR_FUNCTION_ATAN2;
    case 69:
    case "SCALAR_FUNCTION_DATE_BIN":
      return ScalarFunction.SCALAR_FUNCTION_DATE_BIN;
    case 70:
    case "SCALAR_FUNCTION_ARROW_TYPEOF":
      return ScalarFunction.SCALAR_FUNCTION_ARROW_TYPEOF;
    case 71:
    case "SCALAR_FUNCTION_CURRENT_DATE":
      return ScalarFunction.SCALAR_FUNCTION_CURRENT_DATE;
    case 72:
    case "SCALAR_FUNCTION_CURRENT_TIME":
      return ScalarFunction.SCALAR_FUNCTION_CURRENT_TIME;
    case 73:
    case "SCALAR_FUNCTION_UUID":
      return ScalarFunction.SCALAR_FUNCTION_UUID;
    case 74:
    case "SCALAR_FUNCTION_CBRT":
      return ScalarFunction.SCALAR_FUNCTION_CBRT;
    case 75:
    case "SCALAR_FUNCTION_ACOSH":
      return ScalarFunction.SCALAR_FUNCTION_ACOSH;
    case 76:
    case "SCALAR_FUNCTION_ASINH":
      return ScalarFunction.SCALAR_FUNCTION_ASINH;
    case 77:
    case "SCALAR_FUNCTION_ATANH":
      return ScalarFunction.SCALAR_FUNCTION_ATANH;
    case 78:
    case "SCALAR_FUNCTION_SINH":
      return ScalarFunction.SCALAR_FUNCTION_SINH;
    case 79:
    case "SCALAR_FUNCTION_COSH":
      return ScalarFunction.SCALAR_FUNCTION_COSH;
    case 80:
    case "SCALAR_FUNCTION_TANH":
      return ScalarFunction.SCALAR_FUNCTION_TANH;
    case 81:
    case "SCALAR_FUNCTION_PI":
      return ScalarFunction.SCALAR_FUNCTION_PI;
    case 82:
    case "SCALAR_FUNCTION_DEGREES":
      return ScalarFunction.SCALAR_FUNCTION_DEGREES;
    case 83:
    case "SCALAR_FUNCTION_RADIANS":
      return ScalarFunction.SCALAR_FUNCTION_RADIANS;
    case 84:
    case "SCALAR_FUNCTION_FACTORIAL":
      return ScalarFunction.SCALAR_FUNCTION_FACTORIAL;
    case 85:
    case "SCALAR_FUNCTION_LCM":
      return ScalarFunction.SCALAR_FUNCTION_LCM;
    case 86:
    case "SCALAR_FUNCTION_GCD":
      return ScalarFunction.SCALAR_FUNCTION_GCD;
    case 87:
    case "SCALAR_FUNCTION_ARRAY_APPEND":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_APPEND;
    case 88:
    case "SCALAR_FUNCTION_ARRAY_CONCAT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_CONCAT;
    case 89:
    case "SCALAR_FUNCTION_ARRAY_DIMS":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_DIMS;
    case 90:
    case "SCALAR_FUNCTION_ARRAY_REPEAT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REPEAT;
    case 91:
    case "SCALAR_FUNCTION_ARRAY_LENGTH":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_LENGTH;
    case 92:
    case "SCALAR_FUNCTION_ARRAY_NDIMS":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_NDIMS;
    case 93:
    case "SCALAR_FUNCTION_ARRAY_POSITION":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_POSITION;
    case 94:
    case "SCALAR_FUNCTION_ARRAY_POSITIONS":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_POSITIONS;
    case 95:
    case "SCALAR_FUNCTION_ARRAY_PREPEND":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_PREPEND;
    case 96:
    case "SCALAR_FUNCTION_ARRAY_REMOVE":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REMOVE;
    case 97:
    case "SCALAR_FUNCTION_ARRAY_REPLACE":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REPLACE;
    case 98:
    case "SCALAR_FUNCTION_ARRAY_TO_STRING":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_TO_STRING;
    case 99:
    case "SCALAR_FUNCTION_CARDINALITY":
      return ScalarFunction.SCALAR_FUNCTION_CARDINALITY;
    case 100:
    case "SCALAR_FUNCTION_ARRAY_ELEMENT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_ELEMENT;
    case 101:
    case "SCALAR_FUNCTION_ARRAY_SLICE":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_SLICE;
    case 102:
    case "SCALAR_FUNCTION_ENCODE":
      return ScalarFunction.SCALAR_FUNCTION_ENCODE;
    case 103:
    case "SCALAR_FUNCTION_DECODE":
      return ScalarFunction.SCALAR_FUNCTION_DECODE;
    case 104:
    case "SCALAR_FUNCTION_COT":
      return ScalarFunction.SCALAR_FUNCTION_COT;
    case 105:
    case "SCALAR_FUNCTION_ARRAY_HAS":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_HAS;
    case 106:
    case "SCALAR_FUNCTION_ARRAY_HAS_ANY":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_HAS_ANY;
    case 107:
    case "SCALAR_FUNCTION_ARRAY_HAS_ALL":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_HAS_ALL;
    case 108:
    case "SCALAR_FUNCTION_ARRAY_REMOVE_N":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REMOVE_N;
    case 109:
    case "SCALAR_FUNCTION_ARRAY_REPLACE_N":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REPLACE_N;
    case 110:
    case "SCALAR_FUNCTION_ARRAY_REMOVE_ALL":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REMOVE_ALL;
    case 111:
    case "SCALAR_FUNCTION_ARRAY_REPLACE_ALL":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_REPLACE_ALL;
    case 112:
    case "SCALAR_FUNCTION_NANVL":
      return ScalarFunction.SCALAR_FUNCTION_NANVL;
    case 113:
    case "SCALAR_FUNCTION_FLATTEN":
      return ScalarFunction.SCALAR_FUNCTION_FLATTEN;
    case 114:
    case "SCALAR_FUNCTION_ISNAN":
      return ScalarFunction.SCALAR_FUNCTION_ISNAN;
    case 115:
    case "SCALAR_FUNCTION_ISZERO":
      return ScalarFunction.SCALAR_FUNCTION_ISZERO;
    case 116:
    case "SCALAR_FUNCTION_ARRAY_EMPTY":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_EMPTY;
    case 117:
    case "SCALAR_FUNCTION_ARRAY_POP_BACK":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_POP_BACK;
    case 118:
    case "SCALAR_FUNCTION_STRING_TO_ARRAY":
      return ScalarFunction.SCALAR_FUNCTION_STRING_TO_ARRAY;
    case 119:
    case "SCALAR_FUNCTION_TO_TIMESTAMP_NANOS":
      return ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_NANOS;
    case 120:
    case "SCALAR_FUNCTION_ARRAY_INTERSECT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_INTERSECT;
    case 121:
    case "SCALAR_FUNCTION_ARRAY_UNION":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_UNION;
    case 122:
    case "SCALAR_FUNCTION_OVER_LAY":
      return ScalarFunction.SCALAR_FUNCTION_OVER_LAY;
    case 123:
    case "SCALAR_FUNCTION_RANGE":
      return ScalarFunction.SCALAR_FUNCTION_RANGE;
    case 124:
    case "SCALAR_FUNCTION_ARRAY_EXCEPT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_EXCEPT;
    case 125:
    case "SCALAR_FUNCTION_ARRAY_POP_FRONT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_POP_FRONT;
    case 126:
    case "SCALAR_FUNCTION_LEVENSHTEIN":
      return ScalarFunction.SCALAR_FUNCTION_LEVENSHTEIN;
    case 127:
    case "SCALAR_FUNCTION_SUBSTR_INDEX":
      return ScalarFunction.SCALAR_FUNCTION_SUBSTR_INDEX;
    case 128:
    case "SCALAR_FUNCTION_FIND_IN_SET":
      return ScalarFunction.SCALAR_FUNCTION_FIND_IN_SET;
    case 129:
    case "SCALAR_FUNCTION_ARRAY_SORT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_SORT;
    case 130:
    case "SCALAR_FUNCTION_ARRAY_DISTINCT":
      return ScalarFunction.SCALAR_FUNCTION_ARRAY_DISTINCT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScalarFunction.UNRECOGNIZED;
  }
}

export function scalarFunctionToJSON(object: ScalarFunction): string {
  switch (object) {
    case ScalarFunction.SCALAR_FUNCTION_UNSPECIFIED:
      return "SCALAR_FUNCTION_UNSPECIFIED";
    case ScalarFunction.SCALAR_FUNCTION_ABS:
      return "SCALAR_FUNCTION_ABS";
    case ScalarFunction.SCALAR_FUNCTION_ACOS:
      return "SCALAR_FUNCTION_ACOS";
    case ScalarFunction.SCALAR_FUNCTION_ASIN:
      return "SCALAR_FUNCTION_ASIN";
    case ScalarFunction.SCALAR_FUNCTION_ATAN:
      return "SCALAR_FUNCTION_ATAN";
    case ScalarFunction.SCALAR_FUNCTION_ASCII:
      return "SCALAR_FUNCTION_ASCII";
    case ScalarFunction.SCALAR_FUNCTION_CEIL:
      return "SCALAR_FUNCTION_CEIL";
    case ScalarFunction.SCALAR_FUNCTION_COS:
      return "SCALAR_FUNCTION_COS";
    case ScalarFunction.SCALAR_FUNCTION_DIGEST:
      return "SCALAR_FUNCTION_DIGEST";
    case ScalarFunction.SCALAR_FUNCTION_EXP:
      return "SCALAR_FUNCTION_EXP";
    case ScalarFunction.SCALAR_FUNCTION_FLOOR:
      return "SCALAR_FUNCTION_FLOOR";
    case ScalarFunction.SCALAR_FUNCTION_LN:
      return "SCALAR_FUNCTION_LN";
    case ScalarFunction.SCALAR_FUNCTION_LOG:
      return "SCALAR_FUNCTION_LOG";
    case ScalarFunction.SCALAR_FUNCTION_LOG10:
      return "SCALAR_FUNCTION_LOG10";
    case ScalarFunction.SCALAR_FUNCTION_LOG2:
      return "SCALAR_FUNCTION_LOG2";
    case ScalarFunction.SCALAR_FUNCTION_ROUND:
      return "SCALAR_FUNCTION_ROUND";
    case ScalarFunction.SCALAR_FUNCTION_SIGNUM:
      return "SCALAR_FUNCTION_SIGNUM";
    case ScalarFunction.SCALAR_FUNCTION_SIN:
      return "SCALAR_FUNCTION_SIN";
    case ScalarFunction.SCALAR_FUNCTION_SQRT:
      return "SCALAR_FUNCTION_SQRT";
    case ScalarFunction.SCALAR_FUNCTION_TAN:
      return "SCALAR_FUNCTION_TAN";
    case ScalarFunction.SCALAR_FUNCTION_TRUNC:
      return "SCALAR_FUNCTION_TRUNC";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY:
      return "SCALAR_FUNCTION_ARRAY";
    case ScalarFunction.SCALAR_FUNCTION_REGEXP_MATCH:
      return "SCALAR_FUNCTION_REGEXP_MATCH";
    case ScalarFunction.SCALAR_FUNCTION_BIT_LENGTH:
      return "SCALAR_FUNCTION_BIT_LENGTH";
    case ScalarFunction.SCALAR_FUNCTION_BTRIM:
      return "SCALAR_FUNCTION_BTRIM";
    case ScalarFunction.SCALAR_FUNCTION_CHARACTER_LENGTH:
      return "SCALAR_FUNCTION_CHARACTER_LENGTH";
    case ScalarFunction.SCALAR_FUNCTION_CHR:
      return "SCALAR_FUNCTION_CHR";
    case ScalarFunction.SCALAR_FUNCTION_CONCAT:
      return "SCALAR_FUNCTION_CONCAT";
    case ScalarFunction.SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR:
      return "SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR";
    case ScalarFunction.SCALAR_FUNCTION_DATE_PART:
      return "SCALAR_FUNCTION_DATE_PART";
    case ScalarFunction.SCALAR_FUNCTION_DATE_TRUNC:
      return "SCALAR_FUNCTION_DATE_TRUNC";
    case ScalarFunction.SCALAR_FUNCTION_INIT_CAP:
      return "SCALAR_FUNCTION_INIT_CAP";
    case ScalarFunction.SCALAR_FUNCTION_LEFT:
      return "SCALAR_FUNCTION_LEFT";
    case ScalarFunction.SCALAR_FUNCTION_LPAD:
      return "SCALAR_FUNCTION_LPAD";
    case ScalarFunction.SCALAR_FUNCTION_LOWER:
      return "SCALAR_FUNCTION_LOWER";
    case ScalarFunction.SCALAR_FUNCTION_LTRIM:
      return "SCALAR_FUNCTION_LTRIM";
    case ScalarFunction.SCALAR_FUNCTION_MD5:
      return "SCALAR_FUNCTION_MD5";
    case ScalarFunction.SCALAR_FUNCTION_NULL_IF:
      return "SCALAR_FUNCTION_NULL_IF";
    case ScalarFunction.SCALAR_FUNCTION_OCTET_LENGTH:
      return "SCALAR_FUNCTION_OCTET_LENGTH";
    case ScalarFunction.SCALAR_FUNCTION_RANDOM:
      return "SCALAR_FUNCTION_RANDOM";
    case ScalarFunction.SCALAR_FUNCTION_REGEXP_REPLACE:
      return "SCALAR_FUNCTION_REGEXP_REPLACE";
    case ScalarFunction.SCALAR_FUNCTION_REPEAT:
      return "SCALAR_FUNCTION_REPEAT";
    case ScalarFunction.SCALAR_FUNCTION_REPLACE:
      return "SCALAR_FUNCTION_REPLACE";
    case ScalarFunction.SCALAR_FUNCTION_REVERSE:
      return "SCALAR_FUNCTION_REVERSE";
    case ScalarFunction.SCALAR_FUNCTION_RIGHT:
      return "SCALAR_FUNCTION_RIGHT";
    case ScalarFunction.SCALAR_FUNCTION_RPAD:
      return "SCALAR_FUNCTION_RPAD";
    case ScalarFunction.SCALAR_FUNCTION_RTRIM:
      return "SCALAR_FUNCTION_RTRIM";
    case ScalarFunction.SCALAR_FUNCTION_SHA224:
      return "SCALAR_FUNCTION_SHA224";
    case ScalarFunction.SCALAR_FUNCTION_SHA256:
      return "SCALAR_FUNCTION_SHA256";
    case ScalarFunction.SCALAR_FUNCTION_SHA384:
      return "SCALAR_FUNCTION_SHA384";
    case ScalarFunction.SCALAR_FUNCTION_SHA512:
      return "SCALAR_FUNCTION_SHA512";
    case ScalarFunction.SCALAR_FUNCTION_SPLIT_PART:
      return "SCALAR_FUNCTION_SPLIT_PART";
    case ScalarFunction.SCALAR_FUNCTION_STARTS_WITH:
      return "SCALAR_FUNCTION_STARTS_WITH";
    case ScalarFunction.SCALAR_FUNCTION_STRPOS:
      return "SCALAR_FUNCTION_STRPOS";
    case ScalarFunction.SCALAR_FUNCTION_SUBSTR:
      return "SCALAR_FUNCTION_SUBSTR";
    case ScalarFunction.SCALAR_FUNCTION_TO_HEX:
      return "SCALAR_FUNCTION_TO_HEX";
    case ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP:
      return "SCALAR_FUNCTION_TO_TIMESTAMP";
    case ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS:
      return "SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS";
    case ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_MICROS:
      return "SCALAR_FUNCTION_TO_TIMESTAMP_MICROS";
    case ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS:
      return "SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS";
    case ScalarFunction.SCALAR_FUNCTION_NOW:
      return "SCALAR_FUNCTION_NOW";
    case ScalarFunction.SCALAR_FUNCTION_TRANSLATE:
      return "SCALAR_FUNCTION_TRANSLATE";
    case ScalarFunction.SCALAR_FUNCTION_TRIM:
      return "SCALAR_FUNCTION_TRIM";
    case ScalarFunction.SCALAR_FUNCTION_UPPER:
      return "SCALAR_FUNCTION_UPPER";
    case ScalarFunction.SCALAR_FUNCTION_COALESCE:
      return "SCALAR_FUNCTION_COALESCE";
    case ScalarFunction.SCALAR_FUNCTION_POWER:
      return "SCALAR_FUNCTION_POWER";
    case ScalarFunction.SCALAR_FUNCTION_STRUCT_FUN:
      return "SCALAR_FUNCTION_STRUCT_FUN";
    case ScalarFunction.SCALAR_FUNCTION_FROM_UNIXTIME:
      return "SCALAR_FUNCTION_FROM_UNIXTIME";
    case ScalarFunction.SCALAR_FUNCTION_ATAN2:
      return "SCALAR_FUNCTION_ATAN2";
    case ScalarFunction.SCALAR_FUNCTION_DATE_BIN:
      return "SCALAR_FUNCTION_DATE_BIN";
    case ScalarFunction.SCALAR_FUNCTION_ARROW_TYPEOF:
      return "SCALAR_FUNCTION_ARROW_TYPEOF";
    case ScalarFunction.SCALAR_FUNCTION_CURRENT_DATE:
      return "SCALAR_FUNCTION_CURRENT_DATE";
    case ScalarFunction.SCALAR_FUNCTION_CURRENT_TIME:
      return "SCALAR_FUNCTION_CURRENT_TIME";
    case ScalarFunction.SCALAR_FUNCTION_UUID:
      return "SCALAR_FUNCTION_UUID";
    case ScalarFunction.SCALAR_FUNCTION_CBRT:
      return "SCALAR_FUNCTION_CBRT";
    case ScalarFunction.SCALAR_FUNCTION_ACOSH:
      return "SCALAR_FUNCTION_ACOSH";
    case ScalarFunction.SCALAR_FUNCTION_ASINH:
      return "SCALAR_FUNCTION_ASINH";
    case ScalarFunction.SCALAR_FUNCTION_ATANH:
      return "SCALAR_FUNCTION_ATANH";
    case ScalarFunction.SCALAR_FUNCTION_SINH:
      return "SCALAR_FUNCTION_SINH";
    case ScalarFunction.SCALAR_FUNCTION_COSH:
      return "SCALAR_FUNCTION_COSH";
    case ScalarFunction.SCALAR_FUNCTION_TANH:
      return "SCALAR_FUNCTION_TANH";
    case ScalarFunction.SCALAR_FUNCTION_PI:
      return "SCALAR_FUNCTION_PI";
    case ScalarFunction.SCALAR_FUNCTION_DEGREES:
      return "SCALAR_FUNCTION_DEGREES";
    case ScalarFunction.SCALAR_FUNCTION_RADIANS:
      return "SCALAR_FUNCTION_RADIANS";
    case ScalarFunction.SCALAR_FUNCTION_FACTORIAL:
      return "SCALAR_FUNCTION_FACTORIAL";
    case ScalarFunction.SCALAR_FUNCTION_LCM:
      return "SCALAR_FUNCTION_LCM";
    case ScalarFunction.SCALAR_FUNCTION_GCD:
      return "SCALAR_FUNCTION_GCD";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_APPEND:
      return "SCALAR_FUNCTION_ARRAY_APPEND";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_CONCAT:
      return "SCALAR_FUNCTION_ARRAY_CONCAT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_DIMS:
      return "SCALAR_FUNCTION_ARRAY_DIMS";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REPEAT:
      return "SCALAR_FUNCTION_ARRAY_REPEAT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_LENGTH:
      return "SCALAR_FUNCTION_ARRAY_LENGTH";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_NDIMS:
      return "SCALAR_FUNCTION_ARRAY_NDIMS";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_POSITION:
      return "SCALAR_FUNCTION_ARRAY_POSITION";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_POSITIONS:
      return "SCALAR_FUNCTION_ARRAY_POSITIONS";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_PREPEND:
      return "SCALAR_FUNCTION_ARRAY_PREPEND";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REMOVE:
      return "SCALAR_FUNCTION_ARRAY_REMOVE";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REPLACE:
      return "SCALAR_FUNCTION_ARRAY_REPLACE";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_TO_STRING:
      return "SCALAR_FUNCTION_ARRAY_TO_STRING";
    case ScalarFunction.SCALAR_FUNCTION_CARDINALITY:
      return "SCALAR_FUNCTION_CARDINALITY";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_ELEMENT:
      return "SCALAR_FUNCTION_ARRAY_ELEMENT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_SLICE:
      return "SCALAR_FUNCTION_ARRAY_SLICE";
    case ScalarFunction.SCALAR_FUNCTION_ENCODE:
      return "SCALAR_FUNCTION_ENCODE";
    case ScalarFunction.SCALAR_FUNCTION_DECODE:
      return "SCALAR_FUNCTION_DECODE";
    case ScalarFunction.SCALAR_FUNCTION_COT:
      return "SCALAR_FUNCTION_COT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_HAS:
      return "SCALAR_FUNCTION_ARRAY_HAS";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_HAS_ANY:
      return "SCALAR_FUNCTION_ARRAY_HAS_ANY";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_HAS_ALL:
      return "SCALAR_FUNCTION_ARRAY_HAS_ALL";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REMOVE_N:
      return "SCALAR_FUNCTION_ARRAY_REMOVE_N";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REPLACE_N:
      return "SCALAR_FUNCTION_ARRAY_REPLACE_N";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REMOVE_ALL:
      return "SCALAR_FUNCTION_ARRAY_REMOVE_ALL";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_REPLACE_ALL:
      return "SCALAR_FUNCTION_ARRAY_REPLACE_ALL";
    case ScalarFunction.SCALAR_FUNCTION_NANVL:
      return "SCALAR_FUNCTION_NANVL";
    case ScalarFunction.SCALAR_FUNCTION_FLATTEN:
      return "SCALAR_FUNCTION_FLATTEN";
    case ScalarFunction.SCALAR_FUNCTION_ISNAN:
      return "SCALAR_FUNCTION_ISNAN";
    case ScalarFunction.SCALAR_FUNCTION_ISZERO:
      return "SCALAR_FUNCTION_ISZERO";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_EMPTY:
      return "SCALAR_FUNCTION_ARRAY_EMPTY";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_POP_BACK:
      return "SCALAR_FUNCTION_ARRAY_POP_BACK";
    case ScalarFunction.SCALAR_FUNCTION_STRING_TO_ARRAY:
      return "SCALAR_FUNCTION_STRING_TO_ARRAY";
    case ScalarFunction.SCALAR_FUNCTION_TO_TIMESTAMP_NANOS:
      return "SCALAR_FUNCTION_TO_TIMESTAMP_NANOS";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_INTERSECT:
      return "SCALAR_FUNCTION_ARRAY_INTERSECT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_UNION:
      return "SCALAR_FUNCTION_ARRAY_UNION";
    case ScalarFunction.SCALAR_FUNCTION_OVER_LAY:
      return "SCALAR_FUNCTION_OVER_LAY";
    case ScalarFunction.SCALAR_FUNCTION_RANGE:
      return "SCALAR_FUNCTION_RANGE";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_EXCEPT:
      return "SCALAR_FUNCTION_ARRAY_EXCEPT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_POP_FRONT:
      return "SCALAR_FUNCTION_ARRAY_POP_FRONT";
    case ScalarFunction.SCALAR_FUNCTION_LEVENSHTEIN:
      return "SCALAR_FUNCTION_LEVENSHTEIN";
    case ScalarFunction.SCALAR_FUNCTION_SUBSTR_INDEX:
      return "SCALAR_FUNCTION_SUBSTR_INDEX";
    case ScalarFunction.SCALAR_FUNCTION_FIND_IN_SET:
      return "SCALAR_FUNCTION_FIND_IN_SET";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_SORT:
      return "SCALAR_FUNCTION_ARRAY_SORT";
    case ScalarFunction.SCALAR_FUNCTION_ARRAY_DISTINCT:
      return "SCALAR_FUNCTION_ARRAY_DISTINCT";
    case ScalarFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AggregateFunction {
  AGGREGATE_FUNCTION_UNSPECIFIED = 0,
  AGGREGATE_FUNCTION_MIN = 1,
  AGGREGATE_FUNCTION_MAX = 2,
  AGGREGATE_FUNCTION_SUM = 3,
  AGGREGATE_FUNCTION_AVG = 4,
  AGGREGATE_FUNCTION_COUNT = 5,
  AGGREGATE_FUNCTION_APPROX_DISTINCT = 6,
  AGGREGATE_FUNCTION_ARRAY = 7,
  AGGREGATE_FUNCTION_VARIANCE = 8,
  AGGREGATE_FUNCTION_VARIANCE_POP = 9,
  AGGREGATE_FUNCTION_COVARIANCE = 10,
  AGGREGATE_FUNCTION_COVARIANCE_POP = 11,
  AGGREGATE_FUNCTION_STDDEV = 12,
  AGGREGATE_FUNCTION_STDDEV_POP = 13,
  AGGREGATE_FUNCTION_CORRELATION = 14,
  AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT = 15,
  AGGREGATE_FUNCTION_APPROX_MEDIAN = 16,
  AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT = 17,
  AGGREGATE_FUNCTION_GROUPING = 18,
  AGGREGATE_FUNCTION_MEDIAN = 19,
  AGGREGATE_FUNCTION_BIT_AND = 20,
  AGGREGATE_FUNCTION_BIT_OR = 21,
  AGGREGATE_FUNCTION_BIT_XOR = 22,
  AGGREGATE_FUNCTION_BOOL_AND = 23,
  AGGREGATE_FUNCTION_BOOL_OR = 24,
  AGGREGATE_FUNCTION_FIRST_VALUE = 25,
  AGGREGATE_FUNCTION_LAST_VALUE = 26,
  AGGREGATE_FUNCTION_REGR_SLOPE = 27,
  AGGREGATE_FUNCTION_REGR_INTERCEPT = 28,
  AGGREGATE_FUNCTION_REGR_COUNT = 29,
  AGGREGATE_FUNCTION_REGR_R2 = 30,
  AGGREGATE_FUNCTION_REGR_AVGX = 31,
  AGGREGATE_FUNCTION_REGR_AVGY = 32,
  AGGREGATE_FUNCTION_REGR_SXX = 33,
  AGGREGATE_FUNCTION_REGR_SYY = 34,
  AGGREGATE_FUNCTION_REGR_SXY = 35,
  AGGREGATE_FUNCTION_STRING = 36,
  UNRECOGNIZED = -1,
}

export function aggregateFunctionFromJSON(object: any): AggregateFunction {
  switch (object) {
    case 0:
    case "AGGREGATE_FUNCTION_UNSPECIFIED":
      return AggregateFunction.AGGREGATE_FUNCTION_UNSPECIFIED;
    case 1:
    case "AGGREGATE_FUNCTION_MIN":
      return AggregateFunction.AGGREGATE_FUNCTION_MIN;
    case 2:
    case "AGGREGATE_FUNCTION_MAX":
      return AggregateFunction.AGGREGATE_FUNCTION_MAX;
    case 3:
    case "AGGREGATE_FUNCTION_SUM":
      return AggregateFunction.AGGREGATE_FUNCTION_SUM;
    case 4:
    case "AGGREGATE_FUNCTION_AVG":
      return AggregateFunction.AGGREGATE_FUNCTION_AVG;
    case 5:
    case "AGGREGATE_FUNCTION_COUNT":
      return AggregateFunction.AGGREGATE_FUNCTION_COUNT;
    case 6:
    case "AGGREGATE_FUNCTION_APPROX_DISTINCT":
      return AggregateFunction.AGGREGATE_FUNCTION_APPROX_DISTINCT;
    case 7:
    case "AGGREGATE_FUNCTION_ARRAY":
      return AggregateFunction.AGGREGATE_FUNCTION_ARRAY;
    case 8:
    case "AGGREGATE_FUNCTION_VARIANCE":
      return AggregateFunction.AGGREGATE_FUNCTION_VARIANCE;
    case 9:
    case "AGGREGATE_FUNCTION_VARIANCE_POP":
      return AggregateFunction.AGGREGATE_FUNCTION_VARIANCE_POP;
    case 10:
    case "AGGREGATE_FUNCTION_COVARIANCE":
      return AggregateFunction.AGGREGATE_FUNCTION_COVARIANCE;
    case 11:
    case "AGGREGATE_FUNCTION_COVARIANCE_POP":
      return AggregateFunction.AGGREGATE_FUNCTION_COVARIANCE_POP;
    case 12:
    case "AGGREGATE_FUNCTION_STDDEV":
      return AggregateFunction.AGGREGATE_FUNCTION_STDDEV;
    case 13:
    case "AGGREGATE_FUNCTION_STDDEV_POP":
      return AggregateFunction.AGGREGATE_FUNCTION_STDDEV_POP;
    case 14:
    case "AGGREGATE_FUNCTION_CORRELATION":
      return AggregateFunction.AGGREGATE_FUNCTION_CORRELATION;
    case 15:
    case "AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT":
      return AggregateFunction.AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT;
    case 16:
    case "AGGREGATE_FUNCTION_APPROX_MEDIAN":
      return AggregateFunction.AGGREGATE_FUNCTION_APPROX_MEDIAN;
    case 17:
    case "AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT":
      return AggregateFunction.AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT;
    case 18:
    case "AGGREGATE_FUNCTION_GROUPING":
      return AggregateFunction.AGGREGATE_FUNCTION_GROUPING;
    case 19:
    case "AGGREGATE_FUNCTION_MEDIAN":
      return AggregateFunction.AGGREGATE_FUNCTION_MEDIAN;
    case 20:
    case "AGGREGATE_FUNCTION_BIT_AND":
      return AggregateFunction.AGGREGATE_FUNCTION_BIT_AND;
    case 21:
    case "AGGREGATE_FUNCTION_BIT_OR":
      return AggregateFunction.AGGREGATE_FUNCTION_BIT_OR;
    case 22:
    case "AGGREGATE_FUNCTION_BIT_XOR":
      return AggregateFunction.AGGREGATE_FUNCTION_BIT_XOR;
    case 23:
    case "AGGREGATE_FUNCTION_BOOL_AND":
      return AggregateFunction.AGGREGATE_FUNCTION_BOOL_AND;
    case 24:
    case "AGGREGATE_FUNCTION_BOOL_OR":
      return AggregateFunction.AGGREGATE_FUNCTION_BOOL_OR;
    case 25:
    case "AGGREGATE_FUNCTION_FIRST_VALUE":
      return AggregateFunction.AGGREGATE_FUNCTION_FIRST_VALUE;
    case 26:
    case "AGGREGATE_FUNCTION_LAST_VALUE":
      return AggregateFunction.AGGREGATE_FUNCTION_LAST_VALUE;
    case 27:
    case "AGGREGATE_FUNCTION_REGR_SLOPE":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_SLOPE;
    case 28:
    case "AGGREGATE_FUNCTION_REGR_INTERCEPT":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_INTERCEPT;
    case 29:
    case "AGGREGATE_FUNCTION_REGR_COUNT":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_COUNT;
    case 30:
    case "AGGREGATE_FUNCTION_REGR_R2":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_R2;
    case 31:
    case "AGGREGATE_FUNCTION_REGR_AVGX":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_AVGX;
    case 32:
    case "AGGREGATE_FUNCTION_REGR_AVGY":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_AVGY;
    case 33:
    case "AGGREGATE_FUNCTION_REGR_SXX":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_SXX;
    case 34:
    case "AGGREGATE_FUNCTION_REGR_SYY":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_SYY;
    case 35:
    case "AGGREGATE_FUNCTION_REGR_SXY":
      return AggregateFunction.AGGREGATE_FUNCTION_REGR_SXY;
    case 36:
    case "AGGREGATE_FUNCTION_STRING":
      return AggregateFunction.AGGREGATE_FUNCTION_STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AggregateFunction.UNRECOGNIZED;
  }
}

export function aggregateFunctionToJSON(object: AggregateFunction): string {
  switch (object) {
    case AggregateFunction.AGGREGATE_FUNCTION_UNSPECIFIED:
      return "AGGREGATE_FUNCTION_UNSPECIFIED";
    case AggregateFunction.AGGREGATE_FUNCTION_MIN:
      return "AGGREGATE_FUNCTION_MIN";
    case AggregateFunction.AGGREGATE_FUNCTION_MAX:
      return "AGGREGATE_FUNCTION_MAX";
    case AggregateFunction.AGGREGATE_FUNCTION_SUM:
      return "AGGREGATE_FUNCTION_SUM";
    case AggregateFunction.AGGREGATE_FUNCTION_AVG:
      return "AGGREGATE_FUNCTION_AVG";
    case AggregateFunction.AGGREGATE_FUNCTION_COUNT:
      return "AGGREGATE_FUNCTION_COUNT";
    case AggregateFunction.AGGREGATE_FUNCTION_APPROX_DISTINCT:
      return "AGGREGATE_FUNCTION_APPROX_DISTINCT";
    case AggregateFunction.AGGREGATE_FUNCTION_ARRAY:
      return "AGGREGATE_FUNCTION_ARRAY";
    case AggregateFunction.AGGREGATE_FUNCTION_VARIANCE:
      return "AGGREGATE_FUNCTION_VARIANCE";
    case AggregateFunction.AGGREGATE_FUNCTION_VARIANCE_POP:
      return "AGGREGATE_FUNCTION_VARIANCE_POP";
    case AggregateFunction.AGGREGATE_FUNCTION_COVARIANCE:
      return "AGGREGATE_FUNCTION_COVARIANCE";
    case AggregateFunction.AGGREGATE_FUNCTION_COVARIANCE_POP:
      return "AGGREGATE_FUNCTION_COVARIANCE_POP";
    case AggregateFunction.AGGREGATE_FUNCTION_STDDEV:
      return "AGGREGATE_FUNCTION_STDDEV";
    case AggregateFunction.AGGREGATE_FUNCTION_STDDEV_POP:
      return "AGGREGATE_FUNCTION_STDDEV_POP";
    case AggregateFunction.AGGREGATE_FUNCTION_CORRELATION:
      return "AGGREGATE_FUNCTION_CORRELATION";
    case AggregateFunction.AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT:
      return "AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT";
    case AggregateFunction.AGGREGATE_FUNCTION_APPROX_MEDIAN:
      return "AGGREGATE_FUNCTION_APPROX_MEDIAN";
    case AggregateFunction.AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT:
      return "AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT";
    case AggregateFunction.AGGREGATE_FUNCTION_GROUPING:
      return "AGGREGATE_FUNCTION_GROUPING";
    case AggregateFunction.AGGREGATE_FUNCTION_MEDIAN:
      return "AGGREGATE_FUNCTION_MEDIAN";
    case AggregateFunction.AGGREGATE_FUNCTION_BIT_AND:
      return "AGGREGATE_FUNCTION_BIT_AND";
    case AggregateFunction.AGGREGATE_FUNCTION_BIT_OR:
      return "AGGREGATE_FUNCTION_BIT_OR";
    case AggregateFunction.AGGREGATE_FUNCTION_BIT_XOR:
      return "AGGREGATE_FUNCTION_BIT_XOR";
    case AggregateFunction.AGGREGATE_FUNCTION_BOOL_AND:
      return "AGGREGATE_FUNCTION_BOOL_AND";
    case AggregateFunction.AGGREGATE_FUNCTION_BOOL_OR:
      return "AGGREGATE_FUNCTION_BOOL_OR";
    case AggregateFunction.AGGREGATE_FUNCTION_FIRST_VALUE:
      return "AGGREGATE_FUNCTION_FIRST_VALUE";
    case AggregateFunction.AGGREGATE_FUNCTION_LAST_VALUE:
      return "AGGREGATE_FUNCTION_LAST_VALUE";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_SLOPE:
      return "AGGREGATE_FUNCTION_REGR_SLOPE";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_INTERCEPT:
      return "AGGREGATE_FUNCTION_REGR_INTERCEPT";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_COUNT:
      return "AGGREGATE_FUNCTION_REGR_COUNT";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_R2:
      return "AGGREGATE_FUNCTION_REGR_R2";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_AVGX:
      return "AGGREGATE_FUNCTION_REGR_AVGX";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_AVGY:
      return "AGGREGATE_FUNCTION_REGR_AVGY";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_SXX:
      return "AGGREGATE_FUNCTION_REGR_SXX";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_SYY:
      return "AGGREGATE_FUNCTION_REGR_SYY";
    case AggregateFunction.AGGREGATE_FUNCTION_REGR_SXY:
      return "AGGREGATE_FUNCTION_REGR_SXY";
    case AggregateFunction.AGGREGATE_FUNCTION_STRING:
      return "AGGREGATE_FUNCTION_STRING";
    case AggregateFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BuiltInWindowFunction {
  BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED = 0,
  BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER = 1,
  BUILT_IN_WINDOW_FUNCTION_RANK = 2,
  BUILT_IN_WINDOW_FUNCTION_DENSE_RANK = 3,
  BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK = 4,
  BUILT_IN_WINDOW_FUNCTION_CUME_DIST = 5,
  BUILT_IN_WINDOW_FUNCTION_NTILE = 6,
  BUILT_IN_WINDOW_FUNCTION_LAG = 7,
  BUILT_IN_WINDOW_FUNCTION_LEAD = 8,
  BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE = 9,
  BUILT_IN_WINDOW_FUNCTION_LAST_VALUE = 10,
  BUILT_IN_WINDOW_FUNCTION_NTH_VALUE = 11,
  UNRECOGNIZED = -1,
}

export function builtInWindowFunctionFromJSON(object: any): BuiltInWindowFunction {
  switch (object) {
    case 0:
    case "BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED;
    case 1:
    case "BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER;
    case 2:
    case "BUILT_IN_WINDOW_FUNCTION_RANK":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_RANK;
    case 3:
    case "BUILT_IN_WINDOW_FUNCTION_DENSE_RANK":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_DENSE_RANK;
    case 4:
    case "BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK;
    case 5:
    case "BUILT_IN_WINDOW_FUNCTION_CUME_DIST":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_CUME_DIST;
    case 6:
    case "BUILT_IN_WINDOW_FUNCTION_NTILE":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_NTILE;
    case 7:
    case "BUILT_IN_WINDOW_FUNCTION_LAG":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_LAG;
    case 8:
    case "BUILT_IN_WINDOW_FUNCTION_LEAD":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_LEAD;
    case 9:
    case "BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE;
    case 10:
    case "BUILT_IN_WINDOW_FUNCTION_LAST_VALUE":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_LAST_VALUE;
    case 11:
    case "BUILT_IN_WINDOW_FUNCTION_NTH_VALUE":
      return BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_NTH_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuiltInWindowFunction.UNRECOGNIZED;
  }
}

export function builtInWindowFunctionToJSON(object: BuiltInWindowFunction): string {
  switch (object) {
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED:
      return "BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER:
      return "BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_RANK:
      return "BUILT_IN_WINDOW_FUNCTION_RANK";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_DENSE_RANK:
      return "BUILT_IN_WINDOW_FUNCTION_DENSE_RANK";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK:
      return "BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_CUME_DIST:
      return "BUILT_IN_WINDOW_FUNCTION_CUME_DIST";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_NTILE:
      return "BUILT_IN_WINDOW_FUNCTION_NTILE";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_LAG:
      return "BUILT_IN_WINDOW_FUNCTION_LAG";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_LEAD:
      return "BUILT_IN_WINDOW_FUNCTION_LEAD";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE:
      return "BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_LAST_VALUE:
      return "BUILT_IN_WINDOW_FUNCTION_LAST_VALUE";
    case BuiltInWindowFunction.BUILT_IN_WINDOW_FUNCTION_NTH_VALUE:
      return "BUILT_IN_WINDOW_FUNCTION_NTH_VALUE";
    case BuiltInWindowFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WindowFrameUnits {
  WINDOW_FRAME_UNITS_UNSPECIFIED = 0,
  WINDOW_FRAME_UNITS_ROWS = 1,
  WINDOW_FRAME_UNITS_RANGE = 2,
  WINDOW_FRAME_UNITS_GROUPS = 3,
  UNRECOGNIZED = -1,
}

export function windowFrameUnitsFromJSON(object: any): WindowFrameUnits {
  switch (object) {
    case 0:
    case "WINDOW_FRAME_UNITS_UNSPECIFIED":
      return WindowFrameUnits.WINDOW_FRAME_UNITS_UNSPECIFIED;
    case 1:
    case "WINDOW_FRAME_UNITS_ROWS":
      return WindowFrameUnits.WINDOW_FRAME_UNITS_ROWS;
    case 2:
    case "WINDOW_FRAME_UNITS_RANGE":
      return WindowFrameUnits.WINDOW_FRAME_UNITS_RANGE;
    case 3:
    case "WINDOW_FRAME_UNITS_GROUPS":
      return WindowFrameUnits.WINDOW_FRAME_UNITS_GROUPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowFrameUnits.UNRECOGNIZED;
  }
}

export function windowFrameUnitsToJSON(object: WindowFrameUnits): string {
  switch (object) {
    case WindowFrameUnits.WINDOW_FRAME_UNITS_UNSPECIFIED:
      return "WINDOW_FRAME_UNITS_UNSPECIFIED";
    case WindowFrameUnits.WINDOW_FRAME_UNITS_ROWS:
      return "WINDOW_FRAME_UNITS_ROWS";
    case WindowFrameUnits.WINDOW_FRAME_UNITS_RANGE:
      return "WINDOW_FRAME_UNITS_RANGE";
    case WindowFrameUnits.WINDOW_FRAME_UNITS_GROUPS:
      return "WINDOW_FRAME_UNITS_GROUPS";
    case WindowFrameUnits.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WindowFrameBoundType {
  WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED = 0,
  WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW = 1,
  WINDOW_FRAME_BOUND_TYPE_PRECEDING = 2,
  WINDOW_FRAME_BOUND_TYPE_FOLLOWING = 3,
  UNRECOGNIZED = -1,
}

export function windowFrameBoundTypeFromJSON(object: any): WindowFrameBoundType {
  switch (object) {
    case 0:
    case "WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED":
      return WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED;
    case 1:
    case "WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW":
      return WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW;
    case 2:
    case "WINDOW_FRAME_BOUND_TYPE_PRECEDING":
      return WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_PRECEDING;
    case 3:
    case "WINDOW_FRAME_BOUND_TYPE_FOLLOWING":
      return WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_FOLLOWING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowFrameBoundType.UNRECOGNIZED;
  }
}

export function windowFrameBoundTypeToJSON(object: WindowFrameBoundType): string {
  switch (object) {
    case WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED:
      return "WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED";
    case WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW:
      return "WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW";
    case WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_PRECEDING:
      return "WINDOW_FRAME_BOUND_TYPE_PRECEDING";
    case WindowFrameBoundType.WINDOW_FRAME_BOUND_TYPE_FOLLOWING:
      return "WINDOW_FRAME_BOUND_TYPE_FOLLOWING";
    case WindowFrameBoundType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Identifier {
  name: string;
}

/** A field-access expression, like `arr.length`. */
export interface ExprGetAttribute {
  parent: LogicalExprNode | undefined;
  attribute: Identifier | undefined;
}

/** A key-lookup expression, like `hash[name]` or `matrix[r, c]`. */
export interface ExprGetSubscript {
  parent: LogicalExprNode | undefined;
  subscript: LogicalExprNode[];
}

/**
 * A function call, like `abs(x)` or `arr.indexof(6)` or `a + b`.
 *
 * In function calls, like `abs(x)`, the `func` will be an identifier with the
 * specified name.
 *
 * In method calls, like `arr.indexof(6)`, the `func` will be a get-attribute
 * expression.
 *
 * In operator expressions, the `func` will be an identifier with the operator
 * as its name e.g. `"+"`.
 */
export interface ExprCall {
  func: LogicalExprNode | undefined;
  args: LogicalExprNode[];
  kwargs: { [key: string]: LogicalExprNode };
}

export interface ExprCall_KwargsEntry {
  key: string;
  value: LogicalExprNode | undefined;
}

/** A literal expression. */
export interface ExprLiteral {
  value:
    | ScalarValue
    | undefined;
  /**
   * All Python literal values are encoded as arrow scalar values.
   * - If this bool is `False`, then the decoded value was originally a plain
   * Python value.
   * - If this bool is `True`, then the decoded value should be a
   * `pyarrow.Scalar` value.
   */
  isArrowScalarObject: boolean;
}

export interface LogicalExprNode {
  identifier?: Identifier | undefined;
  getAttribute?: ExprGetAttribute | undefined;
  getSubscript?: ExprGetSubscript | undefined;
  call?: ExprCall | undefined;
  literalValue?:
    | ExprLiteral
    | undefined;
  /** The memory ID of this node. Nodes with equal id share are *identical*, sharing any nondeterminism and mutations. */
  exprId: string;
  /**
   * column references
   *
   * @deprecated
   */
  column?:
    | Column
    | undefined;
  /**
   * alias
   *
   * @deprecated
   */
  alias?:
    | AliasNode
    | undefined;
  /** @deprecated */
  literal?:
    | ScalarValue
    | undefined;
  /**
   * binary expressions
   *
   * @deprecated
   */
  binaryExpr?:
    | BinaryExprNode
    | undefined;
  /**
   * aggregate expressions
   *
   * @deprecated
   */
  aggregateExpr?:
    | AggregateExprNode
    | undefined;
  /**
   * null checks
   *
   * @deprecated
   */
  isNullExpr?:
    | IsNull
    | undefined;
  /** @deprecated */
  isNotNullExpr?:
    | IsNotNull
    | undefined;
  /** @deprecated */
  notExpr?:
    | Not
    | undefined;
  /** @deprecated */
  between?:
    | BetweenNode
    | undefined;
  /** @deprecated */
  case?:
    | CaseNode
    | undefined;
  /** @deprecated */
  cast?:
    | CastNode
    | undefined;
  /** @deprecated */
  sort?:
    | SortExprNode
    | undefined;
  /** @deprecated */
  negative?:
    | NegativeNode
    | undefined;
  /** @deprecated */
  inList?:
    | InListNode
    | undefined;
  /** @deprecated */
  wildcard?:
    | Wildcard
    | undefined;
  /** @deprecated */
  scalarFunction?:
    | ScalarFunctionNode
    | undefined;
  /** @deprecated */
  tryCast?:
    | TryCastNode
    | undefined;
  /**
   * window expressions
   *
   * @deprecated
   */
  windowExpr?:
    | WindowExprNode
    | undefined;
  /**
   * AggregateUDF expressions
   *
   * @deprecated
   */
  aggregateUdfExpr?:
    | AggregateUDFExprNode
    | undefined;
  /**
   * Scalar UDF expressions
   *
   * @deprecated
   */
  scalarUdfExpr?:
    | ScalarUDFExprNode
    | undefined;
  /** @deprecated */
  getIndexedField?:
    | GetIndexedField
    | undefined;
  /** @deprecated */
  groupingSet?:
    | GroupingSetNode
    | undefined;
  /** @deprecated */
  cube?:
    | CubeNode
    | undefined;
  /** @deprecated */
  rollup?:
    | RollupNode
    | undefined;
  /** @deprecated */
  isTrue?:
    | IsTrue
    | undefined;
  /** @deprecated */
  isFalse?:
    | IsFalse
    | undefined;
  /** @deprecated */
  isUnknown?:
    | IsUnknown
    | undefined;
  /** @deprecated */
  isNotTrue?:
    | IsNotTrue
    | undefined;
  /** @deprecated */
  isNotFalse?:
    | IsNotFalse
    | undefined;
  /** @deprecated */
  isNotUnknown?:
    | IsNotUnknown
    | undefined;
  /** @deprecated */
  like?:
    | LikeNode
    | undefined;
  /** @deprecated */
  ilike?:
    | ILikeNode
    | undefined;
  /** @deprecated */
  similarTo?:
    | SimilarToNode
    | undefined;
  /** @deprecated */
  placeholder?: PlaceholderNode | undefined;
}

export interface ColumnRelation {
  relation: string;
}

export interface Column {
  name: string;
  relation: ColumnRelation | undefined;
}

export interface Wildcard {
  qualifier?: string | undefined;
}

export interface PlaceholderNode {
  id: string;
  dataType: ArrowType | undefined;
}

export interface LogicalExprList {
  expr: LogicalExprNode[];
}

export interface GroupingSetNode {
  expr: LogicalExprList[];
}

export interface CubeNode {
  expr: LogicalExprNode[];
}

export interface RollupNode {
  expr: LogicalExprNode[];
}

export interface NamedStructField {
  name: ScalarValue | undefined;
}

export interface ListIndex {
  key: LogicalExprNode | undefined;
}

export interface ListRange {
  start: LogicalExprNode | undefined;
  stop: LogicalExprNode | undefined;
}

export interface GetIndexedField {
  expr: LogicalExprNode | undefined;
  namedStructField?: NamedStructField | undefined;
  listIndex?: ListIndex | undefined;
  listRange?: ListRange | undefined;
}

export interface IsNull {
  expr: LogicalExprNode | undefined;
}

export interface IsNotNull {
  expr: LogicalExprNode | undefined;
}

export interface IsTrue {
  expr: LogicalExprNode | undefined;
}

export interface IsFalse {
  expr: LogicalExprNode | undefined;
}

export interface IsUnknown {
  expr: LogicalExprNode | undefined;
}

export interface IsNotTrue {
  expr: LogicalExprNode | undefined;
}

export interface IsNotFalse {
  expr: LogicalExprNode | undefined;
}

export interface IsNotUnknown {
  expr: LogicalExprNode | undefined;
}

export interface Not {
  expr: LogicalExprNode | undefined;
}

export interface AliasNode {
  expr: LogicalExprNode | undefined;
  alias: string;
  relation: OwnedTableReference[];
}

export interface BareTableReference {
  table: string;
}

export interface PartialTableReference {
  schema: string;
  table: string;
}

export interface FullTableReference {
  catalog: string;
  schema: string;
  table: string;
}

export interface OwnedTableReference {
  bare?: BareTableReference | undefined;
  partial?: PartialTableReference | undefined;
  full?: FullTableReference | undefined;
}

export interface BinaryExprNode {
  /**
   * Represents the operands from the left inner most expression
   * to the right outer most expression where each of them are chained
   * with the operator 'op'.
   */
  operands: LogicalExprNode[];
  op: string;
}

export interface NegativeNode {
  expr: LogicalExprNode | undefined;
}

export interface InListNode {
  expr: LogicalExprNode | undefined;
  list: LogicalExprNode[];
  negated: boolean;
}

export interface ScalarFunctionNode {
  fun: ScalarFunction;
  args: LogicalExprNode[];
}

export interface AggregateExprNode {
  aggrFunction: AggregateFunction;
  expr: LogicalExprNode[];
  distinct: boolean;
  filter: LogicalExprNode | undefined;
  orderBy: LogicalExprNode[];
}

export interface AggregateUDFExprNode {
  funName: string;
  args: LogicalExprNode[];
  filter: LogicalExprNode | undefined;
  orderBy: LogicalExprNode[];
  kwargs: { [key: string]: LogicalExprNode };
}

export interface AggregateUDFExprNode_KwargsEntry {
  key: string;
  value: LogicalExprNode | undefined;
}

export interface ScalarUDFExprNode {
  funName: string;
  args: LogicalExprNode[];
}

export interface WindowExprNode {
  aggrFunction?: AggregateFunction | undefined;
  builtInFunction?: BuiltInWindowFunction | undefined;
  udaf?: string | undefined;
  udwf?: string | undefined;
  expr: LogicalExprNode | undefined;
  partitionBy: LogicalExprNode[];
  orderBy: LogicalExprNode[];
  /** repeated LogicalExprNode filter = 7; */
  windowFrame: WindowFrame | undefined;
}

export interface BetweenNode {
  expr: LogicalExprNode | undefined;
  negated: boolean;
  low: LogicalExprNode | undefined;
  high: LogicalExprNode | undefined;
}

export interface LikeNode {
  negated: boolean;
  expr: LogicalExprNode | undefined;
  pattern: LogicalExprNode | undefined;
  escapeChar: string;
}

export interface ILikeNode {
  negated: boolean;
  expr: LogicalExprNode | undefined;
  pattern: LogicalExprNode | undefined;
  escapeChar: string;
}

export interface SimilarToNode {
  negated: boolean;
  expr: LogicalExprNode | undefined;
  pattern: LogicalExprNode | undefined;
  escapeChar: string;
}

export interface CaseNode {
  expr: LogicalExprNode | undefined;
  whenThenExpr: WhenThen[];
  elseExpr: LogicalExprNode | undefined;
}

export interface WhenThen {
  whenExpr: LogicalExprNode | undefined;
  thenExpr: LogicalExprNode | undefined;
}

export interface CastNode {
  expr: LogicalExprNode | undefined;
  arrowType: ArrowType | undefined;
}

export interface TryCastNode {
  expr: LogicalExprNode | undefined;
  arrowType: ArrowType | undefined;
}

export interface SortExprNode {
  expr: LogicalExprNode | undefined;
  asc: boolean;
  nullsFirst: boolean;
}

export interface WindowFrame {
  windowFrameUnits: WindowFrameUnits;
  startBound: WindowFrameBound | undefined;
  bound?: WindowFrameBound | undefined;
}

export interface WindowFrameBound {
  windowFrameBoundType: WindowFrameBoundType;
  boundValue: ScalarValue | undefined;
}

function createBaseIdentifier(): Identifier {
  return { name: "" };
}

export const Identifier: MessageFns<Identifier> = {
  encode(message: Identifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Identifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Identifier {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Identifier): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

function createBaseExprGetAttribute(): ExprGetAttribute {
  return { parent: undefined, attribute: undefined };
}

export const ExprGetAttribute: MessageFns<ExprGetAttribute> = {
  encode(message: ExprGetAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== undefined) {
      LogicalExprNode.encode(message.parent, writer.uint32(10).fork()).join();
    }
    if (message.attribute !== undefined) {
      Identifier.encode(message.attribute, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExprGetAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExprGetAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attribute = Identifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExprGetAttribute {
    return {
      parent: isSet(object.parent) ? LogicalExprNode.fromJSON(object.parent) : undefined,
      attribute: isSet(object.attribute) ? Identifier.fromJSON(object.attribute) : undefined,
    };
  },

  toJSON(message: ExprGetAttribute): unknown {
    const obj: any = {};
    if (message.parent !== undefined) {
      obj.parent = LogicalExprNode.toJSON(message.parent);
    }
    if (message.attribute !== undefined) {
      obj.attribute = Identifier.toJSON(message.attribute);
    }
    return obj;
  },
};

function createBaseExprGetSubscript(): ExprGetSubscript {
  return { parent: undefined, subscript: [] };
}

export const ExprGetSubscript: MessageFns<ExprGetSubscript> = {
  encode(message: ExprGetSubscript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== undefined) {
      LogicalExprNode.encode(message.parent, writer.uint32(10).fork()).join();
    }
    for (const v of message.subscript) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExprGetSubscript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExprGetSubscript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscript.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExprGetSubscript {
    return {
      parent: isSet(object.parent) ? LogicalExprNode.fromJSON(object.parent) : undefined,
      subscript: globalThis.Array.isArray(object?.subscript)
        ? object.subscript.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExprGetSubscript): unknown {
    const obj: any = {};
    if (message.parent !== undefined) {
      obj.parent = LogicalExprNode.toJSON(message.parent);
    }
    if (message.subscript?.length) {
      obj.subscript = message.subscript.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseExprCall(): ExprCall {
  return { func: undefined, args: [], kwargs: {} };
}

export const ExprCall: MessageFns<ExprCall> = {
  encode(message: ExprCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.func !== undefined) {
      LogicalExprNode.encode(message.func, writer.uint32(10).fork()).join();
    }
    for (const v of message.args) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.kwargs).forEach(([key, value]) => {
      ExprCall_KwargsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExprCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExprCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.func = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ExprCall_KwargsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.kwargs[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExprCall {
    return {
      func: isSet(object.func) ? LogicalExprNode.fromJSON(object.func) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
      kwargs: isObject(object.kwargs)
        ? Object.entries(object.kwargs).reduce<{ [key: string]: LogicalExprNode }>((acc, [key, value]) => {
          acc[key] = LogicalExprNode.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ExprCall): unknown {
    const obj: any = {};
    if (message.func !== undefined) {
      obj.func = LogicalExprNode.toJSON(message.func);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.kwargs) {
      const entries = Object.entries(message.kwargs);
      if (entries.length > 0) {
        obj.kwargs = {};
        entries.forEach(([k, v]) => {
          obj.kwargs[k] = LogicalExprNode.toJSON(v);
        });
      }
    }
    return obj;
  },
};

function createBaseExprCall_KwargsEntry(): ExprCall_KwargsEntry {
  return { key: "", value: undefined };
}

export const ExprCall_KwargsEntry: MessageFns<ExprCall_KwargsEntry> = {
  encode(message: ExprCall_KwargsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LogicalExprNode.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExprCall_KwargsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExprCall_KwargsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExprCall_KwargsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LogicalExprNode.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExprCall_KwargsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LogicalExprNode.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseExprLiteral(): ExprLiteral {
  return { value: undefined, isArrowScalarObject: false };
}

export const ExprLiteral: MessageFns<ExprLiteral> = {
  encode(message: ExprLiteral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (message.isArrowScalarObject !== false) {
      writer.uint32(16).bool(message.isArrowScalarObject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExprLiteral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExprLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isArrowScalarObject = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExprLiteral {
    return {
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
      isArrowScalarObject: isSet(object.isArrowScalarObject) ? globalThis.Boolean(object.isArrowScalarObject) : false,
    };
  },

  toJSON(message: ExprLiteral): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    if (message.isArrowScalarObject !== false) {
      obj.isArrowScalarObject = message.isArrowScalarObject;
    }
    return obj;
  },
};

function createBaseLogicalExprNode(): LogicalExprNode {
  return {
    identifier: undefined,
    getAttribute: undefined,
    getSubscript: undefined,
    call: undefined,
    literalValue: undefined,
    exprId: "",
    column: undefined,
    alias: undefined,
    literal: undefined,
    binaryExpr: undefined,
    aggregateExpr: undefined,
    isNullExpr: undefined,
    isNotNullExpr: undefined,
    notExpr: undefined,
    between: undefined,
    case: undefined,
    cast: undefined,
    sort: undefined,
    negative: undefined,
    inList: undefined,
    wildcard: undefined,
    scalarFunction: undefined,
    tryCast: undefined,
    windowExpr: undefined,
    aggregateUdfExpr: undefined,
    scalarUdfExpr: undefined,
    getIndexedField: undefined,
    groupingSet: undefined,
    cube: undefined,
    rollup: undefined,
    isTrue: undefined,
    isFalse: undefined,
    isUnknown: undefined,
    isNotTrue: undefined,
    isNotFalse: undefined,
    isNotUnknown: undefined,
    like: undefined,
    ilike: undefined,
    similarTo: undefined,
    placeholder: undefined,
  };
}

export const LogicalExprNode: MessageFns<LogicalExprNode> = {
  encode(message: LogicalExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      Identifier.encode(message.identifier, writer.uint32(282).fork()).join();
    }
    if (message.getAttribute !== undefined) {
      ExprGetAttribute.encode(message.getAttribute, writer.uint32(290).fork()).join();
    }
    if (message.getSubscript !== undefined) {
      ExprGetSubscript.encode(message.getSubscript, writer.uint32(298).fork()).join();
    }
    if (message.call !== undefined) {
      ExprCall.encode(message.call, writer.uint32(306).fork()).join();
    }
    if (message.literalValue !== undefined) {
      ExprLiteral.encode(message.literalValue, writer.uint32(314).fork()).join();
    }
    if (message.exprId !== "") {
      writer.uint32(322).string(message.exprId);
    }
    if (message.column !== undefined) {
      Column.encode(message.column, writer.uint32(10).fork()).join();
    }
    if (message.alias !== undefined) {
      AliasNode.encode(message.alias, writer.uint32(18).fork()).join();
    }
    if (message.literal !== undefined) {
      ScalarValue.encode(message.literal, writer.uint32(26).fork()).join();
    }
    if (message.binaryExpr !== undefined) {
      BinaryExprNode.encode(message.binaryExpr, writer.uint32(34).fork()).join();
    }
    if (message.aggregateExpr !== undefined) {
      AggregateExprNode.encode(message.aggregateExpr, writer.uint32(42).fork()).join();
    }
    if (message.isNullExpr !== undefined) {
      IsNull.encode(message.isNullExpr, writer.uint32(50).fork()).join();
    }
    if (message.isNotNullExpr !== undefined) {
      IsNotNull.encode(message.isNotNullExpr, writer.uint32(58).fork()).join();
    }
    if (message.notExpr !== undefined) {
      Not.encode(message.notExpr, writer.uint32(66).fork()).join();
    }
    if (message.between !== undefined) {
      BetweenNode.encode(message.between, writer.uint32(74).fork()).join();
    }
    if (message.case !== undefined) {
      CaseNode.encode(message.case, writer.uint32(82).fork()).join();
    }
    if (message.cast !== undefined) {
      CastNode.encode(message.cast, writer.uint32(90).fork()).join();
    }
    if (message.sort !== undefined) {
      SortExprNode.encode(message.sort, writer.uint32(98).fork()).join();
    }
    if (message.negative !== undefined) {
      NegativeNode.encode(message.negative, writer.uint32(106).fork()).join();
    }
    if (message.inList !== undefined) {
      InListNode.encode(message.inList, writer.uint32(114).fork()).join();
    }
    if (message.wildcard !== undefined) {
      Wildcard.encode(message.wildcard, writer.uint32(122).fork()).join();
    }
    if (message.scalarFunction !== undefined) {
      ScalarFunctionNode.encode(message.scalarFunction, writer.uint32(130).fork()).join();
    }
    if (message.tryCast !== undefined) {
      TryCastNode.encode(message.tryCast, writer.uint32(138).fork()).join();
    }
    if (message.windowExpr !== undefined) {
      WindowExprNode.encode(message.windowExpr, writer.uint32(146).fork()).join();
    }
    if (message.aggregateUdfExpr !== undefined) {
      AggregateUDFExprNode.encode(message.aggregateUdfExpr, writer.uint32(154).fork()).join();
    }
    if (message.scalarUdfExpr !== undefined) {
      ScalarUDFExprNode.encode(message.scalarUdfExpr, writer.uint32(162).fork()).join();
    }
    if (message.getIndexedField !== undefined) {
      GetIndexedField.encode(message.getIndexedField, writer.uint32(170).fork()).join();
    }
    if (message.groupingSet !== undefined) {
      GroupingSetNode.encode(message.groupingSet, writer.uint32(178).fork()).join();
    }
    if (message.cube !== undefined) {
      CubeNode.encode(message.cube, writer.uint32(186).fork()).join();
    }
    if (message.rollup !== undefined) {
      RollupNode.encode(message.rollup, writer.uint32(194).fork()).join();
    }
    if (message.isTrue !== undefined) {
      IsTrue.encode(message.isTrue, writer.uint32(202).fork()).join();
    }
    if (message.isFalse !== undefined) {
      IsFalse.encode(message.isFalse, writer.uint32(210).fork()).join();
    }
    if (message.isUnknown !== undefined) {
      IsUnknown.encode(message.isUnknown, writer.uint32(218).fork()).join();
    }
    if (message.isNotTrue !== undefined) {
      IsNotTrue.encode(message.isNotTrue, writer.uint32(226).fork()).join();
    }
    if (message.isNotFalse !== undefined) {
      IsNotFalse.encode(message.isNotFalse, writer.uint32(234).fork()).join();
    }
    if (message.isNotUnknown !== undefined) {
      IsNotUnknown.encode(message.isNotUnknown, writer.uint32(242).fork()).join();
    }
    if (message.like !== undefined) {
      LikeNode.encode(message.like, writer.uint32(250).fork()).join();
    }
    if (message.ilike !== undefined) {
      ILikeNode.encode(message.ilike, writer.uint32(258).fork()).join();
    }
    if (message.similarTo !== undefined) {
      SimilarToNode.encode(message.similarTo, writer.uint32(266).fork()).join();
    }
    if (message.placeholder !== undefined) {
      PlaceholderNode.encode(message.placeholder, writer.uint32(274).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogicalExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogicalExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.identifier = Identifier.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.getAttribute = ExprGetAttribute.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.getSubscript = ExprGetSubscript.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.call = ExprCall.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.literalValue = ExprLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.exprId = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.column = Column.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alias = AliasNode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.literal = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.binaryExpr = BinaryExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aggregateExpr = AggregateExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.isNullExpr = IsNull.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.isNotNullExpr = IsNotNull.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.notExpr = Not.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.between = BetweenNode.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.case = CaseNode.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.cast = CastNode.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.sort = SortExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.negative = NegativeNode.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.inList = InListNode.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.wildcard = Wildcard.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.scalarFunction = ScalarFunctionNode.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.tryCast = TryCastNode.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.windowExpr = WindowExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.aggregateUdfExpr = AggregateUDFExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.scalarUdfExpr = ScalarUDFExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.getIndexedField = GetIndexedField.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.groupingSet = GroupingSetNode.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.cube = CubeNode.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.rollup = RollupNode.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.isTrue = IsTrue.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.isFalse = IsFalse.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.isUnknown = IsUnknown.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.isNotTrue = IsNotTrue.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.isNotFalse = IsNotFalse.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.isNotUnknown = IsNotUnknown.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.like = LikeNode.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.ilike = ILikeNode.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.similarTo = SimilarToNode.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.placeholder = PlaceholderNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogicalExprNode {
    return {
      identifier: isSet(object.identifier) ? Identifier.fromJSON(object.identifier) : undefined,
      getAttribute: isSet(object.getAttribute) ? ExprGetAttribute.fromJSON(object.getAttribute) : undefined,
      getSubscript: isSet(object.getSubscript) ? ExprGetSubscript.fromJSON(object.getSubscript) : undefined,
      call: isSet(object.call) ? ExprCall.fromJSON(object.call) : undefined,
      literalValue: isSet(object.literalValue) ? ExprLiteral.fromJSON(object.literalValue) : undefined,
      exprId: isSet(object.exprId) ? globalThis.String(object.exprId) : "",
      column: isSet(object.column) ? Column.fromJSON(object.column) : undefined,
      alias: isSet(object.alias) ? AliasNode.fromJSON(object.alias) : undefined,
      literal: isSet(object.literal) ? ScalarValue.fromJSON(object.literal) : undefined,
      binaryExpr: isSet(object.binaryExpr) ? BinaryExprNode.fromJSON(object.binaryExpr) : undefined,
      aggregateExpr: isSet(object.aggregateExpr) ? AggregateExprNode.fromJSON(object.aggregateExpr) : undefined,
      isNullExpr: isSet(object.isNullExpr) ? IsNull.fromJSON(object.isNullExpr) : undefined,
      isNotNullExpr: isSet(object.isNotNullExpr) ? IsNotNull.fromJSON(object.isNotNullExpr) : undefined,
      notExpr: isSet(object.notExpr) ? Not.fromJSON(object.notExpr) : undefined,
      between: isSet(object.between) ? BetweenNode.fromJSON(object.between) : undefined,
      case: isSet(object.case) ? CaseNode.fromJSON(object.case) : undefined,
      cast: isSet(object.cast) ? CastNode.fromJSON(object.cast) : undefined,
      sort: isSet(object.sort) ? SortExprNode.fromJSON(object.sort) : undefined,
      negative: isSet(object.negative) ? NegativeNode.fromJSON(object.negative) : undefined,
      inList: isSet(object.inList) ? InListNode.fromJSON(object.inList) : undefined,
      wildcard: isSet(object.wildcard) ? Wildcard.fromJSON(object.wildcard) : undefined,
      scalarFunction: isSet(object.scalarFunction) ? ScalarFunctionNode.fromJSON(object.scalarFunction) : undefined,
      tryCast: isSet(object.tryCast) ? TryCastNode.fromJSON(object.tryCast) : undefined,
      windowExpr: isSet(object.windowExpr) ? WindowExprNode.fromJSON(object.windowExpr) : undefined,
      aggregateUdfExpr: isSet(object.aggregateUdfExpr)
        ? AggregateUDFExprNode.fromJSON(object.aggregateUdfExpr)
        : undefined,
      scalarUdfExpr: isSet(object.scalarUdfExpr) ? ScalarUDFExprNode.fromJSON(object.scalarUdfExpr) : undefined,
      getIndexedField: isSet(object.getIndexedField) ? GetIndexedField.fromJSON(object.getIndexedField) : undefined,
      groupingSet: isSet(object.groupingSet) ? GroupingSetNode.fromJSON(object.groupingSet) : undefined,
      cube: isSet(object.cube) ? CubeNode.fromJSON(object.cube) : undefined,
      rollup: isSet(object.rollup) ? RollupNode.fromJSON(object.rollup) : undefined,
      isTrue: isSet(object.isTrue) ? IsTrue.fromJSON(object.isTrue) : undefined,
      isFalse: isSet(object.isFalse) ? IsFalse.fromJSON(object.isFalse) : undefined,
      isUnknown: isSet(object.isUnknown) ? IsUnknown.fromJSON(object.isUnknown) : undefined,
      isNotTrue: isSet(object.isNotTrue) ? IsNotTrue.fromJSON(object.isNotTrue) : undefined,
      isNotFalse: isSet(object.isNotFalse) ? IsNotFalse.fromJSON(object.isNotFalse) : undefined,
      isNotUnknown: isSet(object.isNotUnknown) ? IsNotUnknown.fromJSON(object.isNotUnknown) : undefined,
      like: isSet(object.like) ? LikeNode.fromJSON(object.like) : undefined,
      ilike: isSet(object.ilike) ? ILikeNode.fromJSON(object.ilike) : undefined,
      similarTo: isSet(object.similarTo) ? SimilarToNode.fromJSON(object.similarTo) : undefined,
      placeholder: isSet(object.placeholder) ? PlaceholderNode.fromJSON(object.placeholder) : undefined,
    };
  },

  toJSON(message: LogicalExprNode): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = Identifier.toJSON(message.identifier);
    }
    if (message.getAttribute !== undefined) {
      obj.getAttribute = ExprGetAttribute.toJSON(message.getAttribute);
    }
    if (message.getSubscript !== undefined) {
      obj.getSubscript = ExprGetSubscript.toJSON(message.getSubscript);
    }
    if (message.call !== undefined) {
      obj.call = ExprCall.toJSON(message.call);
    }
    if (message.literalValue !== undefined) {
      obj.literalValue = ExprLiteral.toJSON(message.literalValue);
    }
    if (message.exprId !== "") {
      obj.exprId = message.exprId;
    }
    if (message.column !== undefined) {
      obj.column = Column.toJSON(message.column);
    }
    if (message.alias !== undefined) {
      obj.alias = AliasNode.toJSON(message.alias);
    }
    if (message.literal !== undefined) {
      obj.literal = ScalarValue.toJSON(message.literal);
    }
    if (message.binaryExpr !== undefined) {
      obj.binaryExpr = BinaryExprNode.toJSON(message.binaryExpr);
    }
    if (message.aggregateExpr !== undefined) {
      obj.aggregateExpr = AggregateExprNode.toJSON(message.aggregateExpr);
    }
    if (message.isNullExpr !== undefined) {
      obj.isNullExpr = IsNull.toJSON(message.isNullExpr);
    }
    if (message.isNotNullExpr !== undefined) {
      obj.isNotNullExpr = IsNotNull.toJSON(message.isNotNullExpr);
    }
    if (message.notExpr !== undefined) {
      obj.notExpr = Not.toJSON(message.notExpr);
    }
    if (message.between !== undefined) {
      obj.between = BetweenNode.toJSON(message.between);
    }
    if (message.case !== undefined) {
      obj.case = CaseNode.toJSON(message.case);
    }
    if (message.cast !== undefined) {
      obj.cast = CastNode.toJSON(message.cast);
    }
    if (message.sort !== undefined) {
      obj.sort = SortExprNode.toJSON(message.sort);
    }
    if (message.negative !== undefined) {
      obj.negative = NegativeNode.toJSON(message.negative);
    }
    if (message.inList !== undefined) {
      obj.inList = InListNode.toJSON(message.inList);
    }
    if (message.wildcard !== undefined) {
      obj.wildcard = Wildcard.toJSON(message.wildcard);
    }
    if (message.scalarFunction !== undefined) {
      obj.scalarFunction = ScalarFunctionNode.toJSON(message.scalarFunction);
    }
    if (message.tryCast !== undefined) {
      obj.tryCast = TryCastNode.toJSON(message.tryCast);
    }
    if (message.windowExpr !== undefined) {
      obj.windowExpr = WindowExprNode.toJSON(message.windowExpr);
    }
    if (message.aggregateUdfExpr !== undefined) {
      obj.aggregateUdfExpr = AggregateUDFExprNode.toJSON(message.aggregateUdfExpr);
    }
    if (message.scalarUdfExpr !== undefined) {
      obj.scalarUdfExpr = ScalarUDFExprNode.toJSON(message.scalarUdfExpr);
    }
    if (message.getIndexedField !== undefined) {
      obj.getIndexedField = GetIndexedField.toJSON(message.getIndexedField);
    }
    if (message.groupingSet !== undefined) {
      obj.groupingSet = GroupingSetNode.toJSON(message.groupingSet);
    }
    if (message.cube !== undefined) {
      obj.cube = CubeNode.toJSON(message.cube);
    }
    if (message.rollup !== undefined) {
      obj.rollup = RollupNode.toJSON(message.rollup);
    }
    if (message.isTrue !== undefined) {
      obj.isTrue = IsTrue.toJSON(message.isTrue);
    }
    if (message.isFalse !== undefined) {
      obj.isFalse = IsFalse.toJSON(message.isFalse);
    }
    if (message.isUnknown !== undefined) {
      obj.isUnknown = IsUnknown.toJSON(message.isUnknown);
    }
    if (message.isNotTrue !== undefined) {
      obj.isNotTrue = IsNotTrue.toJSON(message.isNotTrue);
    }
    if (message.isNotFalse !== undefined) {
      obj.isNotFalse = IsNotFalse.toJSON(message.isNotFalse);
    }
    if (message.isNotUnknown !== undefined) {
      obj.isNotUnknown = IsNotUnknown.toJSON(message.isNotUnknown);
    }
    if (message.like !== undefined) {
      obj.like = LikeNode.toJSON(message.like);
    }
    if (message.ilike !== undefined) {
      obj.ilike = ILikeNode.toJSON(message.ilike);
    }
    if (message.similarTo !== undefined) {
      obj.similarTo = SimilarToNode.toJSON(message.similarTo);
    }
    if (message.placeholder !== undefined) {
      obj.placeholder = PlaceholderNode.toJSON(message.placeholder);
    }
    return obj;
  },
};

function createBaseColumnRelation(): ColumnRelation {
  return { relation: "" };
}

export const ColumnRelation: MessageFns<ColumnRelation> = {
  encode(message: ColumnRelation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.relation !== "") {
      writer.uint32(10).string(message.relation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.relation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnRelation {
    return { relation: isSet(object.relation) ? globalThis.String(object.relation) : "" };
  },

  toJSON(message: ColumnRelation): unknown {
    const obj: any = {};
    if (message.relation !== "") {
      obj.relation = message.relation;
    }
    return obj;
  },
};

function createBaseColumn(): Column {
  return { name: "", relation: undefined };
}

export const Column: MessageFns<Column> = {
  encode(message: Column, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.relation !== undefined) {
      ColumnRelation.encode(message.relation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Column {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relation = ColumnRelation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Column {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      relation: isSet(object.relation) ? ColumnRelation.fromJSON(object.relation) : undefined,
    };
  },

  toJSON(message: Column): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.relation !== undefined) {
      obj.relation = ColumnRelation.toJSON(message.relation);
    }
    return obj;
  },
};

function createBaseWildcard(): Wildcard {
  return { qualifier: undefined };
}

export const Wildcard: MessageFns<Wildcard> = {
  encode(message: Wildcard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.qualifier !== undefined) {
      writer.uint32(10).string(message.qualifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wildcard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWildcard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.qualifier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wildcard {
    return { qualifier: isSet(object.qualifier) ? globalThis.String(object.qualifier) : undefined };
  },

  toJSON(message: Wildcard): unknown {
    const obj: any = {};
    if (message.qualifier !== undefined) {
      obj.qualifier = message.qualifier;
    }
    return obj;
  },
};

function createBasePlaceholderNode(): PlaceholderNode {
  return { id: "", dataType: undefined };
}

export const PlaceholderNode: MessageFns<PlaceholderNode> = {
  encode(message: PlaceholderNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.dataType !== undefined) {
      ArrowType.encode(message.dataType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceholderNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceholderNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceholderNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      dataType: isSet(object.dataType) ? ArrowType.fromJSON(object.dataType) : undefined,
    };
  },

  toJSON(message: PlaceholderNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.dataType !== undefined) {
      obj.dataType = ArrowType.toJSON(message.dataType);
    }
    return obj;
  },
};

function createBaseLogicalExprList(): LogicalExprList {
  return { expr: [] };
}

export const LogicalExprList: MessageFns<LogicalExprList> = {
  encode(message: LogicalExprList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expr) {
      LogicalExprNode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogicalExprList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogicalExprList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogicalExprList {
    return {
      expr: globalThis.Array.isArray(object?.expr) ? object.expr.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: LogicalExprList): unknown {
    const obj: any = {};
    if (message.expr?.length) {
      obj.expr = message.expr.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseGroupingSetNode(): GroupingSetNode {
  return { expr: [] };
}

export const GroupingSetNode: MessageFns<GroupingSetNode> = {
  encode(message: GroupingSetNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expr) {
      LogicalExprList.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupingSetNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupingSetNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr.push(LogicalExprList.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupingSetNode {
    return {
      expr: globalThis.Array.isArray(object?.expr) ? object.expr.map((e: any) => LogicalExprList.fromJSON(e)) : [],
    };
  },

  toJSON(message: GroupingSetNode): unknown {
    const obj: any = {};
    if (message.expr?.length) {
      obj.expr = message.expr.map((e) => LogicalExprList.toJSON(e));
    }
    return obj;
  },
};

function createBaseCubeNode(): CubeNode {
  return { expr: [] };
}

export const CubeNode: MessageFns<CubeNode> = {
  encode(message: CubeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expr) {
      LogicalExprNode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CubeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCubeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CubeNode {
    return {
      expr: globalThis.Array.isArray(object?.expr) ? object.expr.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: CubeNode): unknown {
    const obj: any = {};
    if (message.expr?.length) {
      obj.expr = message.expr.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseRollupNode(): RollupNode {
  return { expr: [] };
}

export const RollupNode: MessageFns<RollupNode> = {
  encode(message: RollupNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expr) {
      LogicalExprNode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollupNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollupNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollupNode {
    return {
      expr: globalThis.Array.isArray(object?.expr) ? object.expr.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: RollupNode): unknown {
    const obj: any = {};
    if (message.expr?.length) {
      obj.expr = message.expr.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseNamedStructField(): NamedStructField {
  return { name: undefined };
}

export const NamedStructField: MessageFns<NamedStructField> = {
  encode(message: NamedStructField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      ScalarValue.encode(message.name, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedStructField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedStructField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedStructField {
    return { name: isSet(object.name) ? ScalarValue.fromJSON(object.name) : undefined };
  },

  toJSON(message: NamedStructField): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = ScalarValue.toJSON(message.name);
    }
    return obj;
  },
};

function createBaseListIndex(): ListIndex {
  return { key: undefined };
}

export const ListIndex: MessageFns<ListIndex> = {
  encode(message: ListIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      LogicalExprNode.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndex {
    return { key: isSet(object.key) ? LogicalExprNode.fromJSON(object.key) : undefined };
  },

  toJSON(message: ListIndex): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = LogicalExprNode.toJSON(message.key);
    }
    return obj;
  },
};

function createBaseListRange(): ListRange {
  return { start: undefined, stop: undefined };
}

export const ListRange: MessageFns<ListRange> = {
  encode(message: ListRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      LogicalExprNode.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.stop !== undefined) {
      LogicalExprNode.encode(message.stop, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.start = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stop = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRange {
    return {
      start: isSet(object.start) ? LogicalExprNode.fromJSON(object.start) : undefined,
      stop: isSet(object.stop) ? LogicalExprNode.fromJSON(object.stop) : undefined,
    };
  },

  toJSON(message: ListRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = LogicalExprNode.toJSON(message.start);
    }
    if (message.stop !== undefined) {
      obj.stop = LogicalExprNode.toJSON(message.stop);
    }
    return obj;
  },
};

function createBaseGetIndexedField(): GetIndexedField {
  return { expr: undefined, namedStructField: undefined, listIndex: undefined, listRange: undefined };
}

export const GetIndexedField: MessageFns<GetIndexedField> = {
  encode(message: GetIndexedField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.namedStructField !== undefined) {
      NamedStructField.encode(message.namedStructField, writer.uint32(18).fork()).join();
    }
    if (message.listIndex !== undefined) {
      ListIndex.encode(message.listIndex, writer.uint32(26).fork()).join();
    }
    if (message.listRange !== undefined) {
      ListRange.encode(message.listRange, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexedField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexedField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namedStructField = NamedStructField.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.listIndex = ListIndex.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.listRange = ListRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexedField {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      namedStructField: isSet(object.namedStructField) ? NamedStructField.fromJSON(object.namedStructField) : undefined,
      listIndex: isSet(object.listIndex) ? ListIndex.fromJSON(object.listIndex) : undefined,
      listRange: isSet(object.listRange) ? ListRange.fromJSON(object.listRange) : undefined,
    };
  },

  toJSON(message: GetIndexedField): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.namedStructField !== undefined) {
      obj.namedStructField = NamedStructField.toJSON(message.namedStructField);
    }
    if (message.listIndex !== undefined) {
      obj.listIndex = ListIndex.toJSON(message.listIndex);
    }
    if (message.listRange !== undefined) {
      obj.listRange = ListRange.toJSON(message.listRange);
    }
    return obj;
  },
};

function createBaseIsNull(): IsNull {
  return { expr: undefined };
}

export const IsNull: MessageFns<IsNull> = {
  encode(message: IsNull, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNull {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNull();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNull {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsNull): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsNotNull(): IsNotNull {
  return { expr: undefined };
}

export const IsNotNull: MessageFns<IsNotNull> = {
  encode(message: IsNotNull, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNotNull {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNotNull();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNotNull {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsNotNull): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsTrue(): IsTrue {
  return { expr: undefined };
}

export const IsTrue: MessageFns<IsTrue> = {
  encode(message: IsTrue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsTrue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsTrue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsTrue {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsTrue): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsFalse(): IsFalse {
  return { expr: undefined };
}

export const IsFalse: MessageFns<IsFalse> = {
  encode(message: IsFalse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsFalse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsFalse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsFalse {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsFalse): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsUnknown(): IsUnknown {
  return { expr: undefined };
}

export const IsUnknown: MessageFns<IsUnknown> = {
  encode(message: IsUnknown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsUnknown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsUnknown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsUnknown {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsUnknown): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsNotTrue(): IsNotTrue {
  return { expr: undefined };
}

export const IsNotTrue: MessageFns<IsNotTrue> = {
  encode(message: IsNotTrue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNotTrue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNotTrue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNotTrue {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsNotTrue): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsNotFalse(): IsNotFalse {
  return { expr: undefined };
}

export const IsNotFalse: MessageFns<IsNotFalse> = {
  encode(message: IsNotFalse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNotFalse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNotFalse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNotFalse {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsNotFalse): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseIsNotUnknown(): IsNotUnknown {
  return { expr: undefined };
}

export const IsNotUnknown: MessageFns<IsNotUnknown> = {
  encode(message: IsNotUnknown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsNotUnknown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsNotUnknown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsNotUnknown {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: IsNotUnknown): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseNot(): Not {
  return { expr: undefined };
}

export const Not: MessageFns<Not> = {
  encode(message: Not, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Not {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Not {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: Not): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseAliasNode(): AliasNode {
  return { expr: undefined, alias: "", relation: [] };
}

export const AliasNode: MessageFns<AliasNode> = {
  encode(message: AliasNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.alias !== "") {
      writer.uint32(18).string(message.alias);
    }
    for (const v of message.relation) {
      OwnedTableReference.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AliasNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAliasNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alias = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relation.push(OwnedTableReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AliasNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
      relation: globalThis.Array.isArray(object?.relation)
        ? object.relation.map((e: any) => OwnedTableReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AliasNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.alias !== "") {
      obj.alias = message.alias;
    }
    if (message.relation?.length) {
      obj.relation = message.relation.map((e) => OwnedTableReference.toJSON(e));
    }
    return obj;
  },
};

function createBaseBareTableReference(): BareTableReference {
  return { table: "" };
}

export const BareTableReference: MessageFns<BareTableReference> = {
  encode(message: BareTableReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BareTableReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBareTableReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BareTableReference {
    return { table: isSet(object.table) ? globalThis.String(object.table) : "" };
  },

  toJSON(message: BareTableReference): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    return obj;
  },
};

function createBasePartialTableReference(): PartialTableReference {
  return { schema: "", table: "" };
}

export const PartialTableReference: MessageFns<PartialTableReference> = {
  encode(message: PartialTableReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(18).string(message.table);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartialTableReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartialTableReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.table = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartialTableReference {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
    };
  },

  toJSON(message: PartialTableReference): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    return obj;
  },
};

function createBaseFullTableReference(): FullTableReference {
  return { catalog: "", schema: "", table: "" };
}

export const FullTableReference: MessageFns<FullTableReference> = {
  encode(message: FullTableReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.catalog !== "") {
      writer.uint32(10).string(message.catalog);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(26).string(message.table);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FullTableReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFullTableReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.catalog = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.table = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FullTableReference {
    return {
      catalog: isSet(object.catalog) ? globalThis.String(object.catalog) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
    };
  },

  toJSON(message: FullTableReference): unknown {
    const obj: any = {};
    if (message.catalog !== "") {
      obj.catalog = message.catalog;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    return obj;
  },
};

function createBaseOwnedTableReference(): OwnedTableReference {
  return { bare: undefined, partial: undefined, full: undefined };
}

export const OwnedTableReference: MessageFns<OwnedTableReference> = {
  encode(message: OwnedTableReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bare !== undefined) {
      BareTableReference.encode(message.bare, writer.uint32(10).fork()).join();
    }
    if (message.partial !== undefined) {
      PartialTableReference.encode(message.partial, writer.uint32(18).fork()).join();
    }
    if (message.full !== undefined) {
      FullTableReference.encode(message.full, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OwnedTableReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwnedTableReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bare = BareTableReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partial = PartialTableReference.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.full = FullTableReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OwnedTableReference {
    return {
      bare: isSet(object.bare) ? BareTableReference.fromJSON(object.bare) : undefined,
      partial: isSet(object.partial) ? PartialTableReference.fromJSON(object.partial) : undefined,
      full: isSet(object.full) ? FullTableReference.fromJSON(object.full) : undefined,
    };
  },

  toJSON(message: OwnedTableReference): unknown {
    const obj: any = {};
    if (message.bare !== undefined) {
      obj.bare = BareTableReference.toJSON(message.bare);
    }
    if (message.partial !== undefined) {
      obj.partial = PartialTableReference.toJSON(message.partial);
    }
    if (message.full !== undefined) {
      obj.full = FullTableReference.toJSON(message.full);
    }
    return obj;
  },
};

function createBaseBinaryExprNode(): BinaryExprNode {
  return { operands: [], op: "" };
}

export const BinaryExprNode: MessageFns<BinaryExprNode> = {
  encode(message: BinaryExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operands) {
      LogicalExprNode.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.op !== "") {
      writer.uint32(26).string(message.op);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operands.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.op = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinaryExprNode {
    return {
      operands: globalThis.Array.isArray(object?.operands)
        ? object.operands.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      op: isSet(object.op) ? globalThis.String(object.op) : "",
    };
  },

  toJSON(message: BinaryExprNode): unknown {
    const obj: any = {};
    if (message.operands?.length) {
      obj.operands = message.operands.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.op !== "") {
      obj.op = message.op;
    }
    return obj;
  },
};

function createBaseNegativeNode(): NegativeNode {
  return { expr: undefined };
}

export const NegativeNode: MessageFns<NegativeNode> = {
  encode(message: NegativeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NegativeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNegativeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NegativeNode {
    return { expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined };
  },

  toJSON(message: NegativeNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    return obj;
  },
};

function createBaseInListNode(): InListNode {
  return { expr: undefined, list: [], negated: false };
}

export const InListNode: MessageFns<InListNode> = {
  encode(message: InListNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    for (const v of message.list) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.negated !== false) {
      writer.uint32(24).bool(message.negated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InListNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInListNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.list.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.negated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InListNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
    };
  },

  toJSON(message: InListNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.list?.length) {
      obj.list = message.list.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    return obj;
  },
};

function createBaseScalarFunctionNode(): ScalarFunctionNode {
  return { fun: 0, args: [] };
}

export const ScalarFunctionNode: MessageFns<ScalarFunctionNode> = {
  encode(message: ScalarFunctionNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fun !== 0) {
      writer.uint32(8).int32(message.fun);
    }
    for (const v of message.args) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarFunctionNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarFunctionNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fun = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarFunctionNode {
    return {
      fun: isSet(object.fun) ? scalarFunctionFromJSON(object.fun) : 0,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: ScalarFunctionNode): unknown {
    const obj: any = {};
    if (message.fun !== 0) {
      obj.fun = scalarFunctionToJSON(message.fun);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseAggregateExprNode(): AggregateExprNode {
  return { aggrFunction: 0, expr: [], distinct: false, filter: undefined, orderBy: [] };
}

export const AggregateExprNode: MessageFns<AggregateExprNode> = {
  encode(message: AggregateExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggrFunction !== 0) {
      writer.uint32(8).int32(message.aggrFunction);
    }
    for (const v of message.expr) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.distinct !== false) {
      writer.uint32(24).bool(message.distinct);
    }
    if (message.filter !== undefined) {
      LogicalExprNode.encode(message.filter, writer.uint32(34).fork()).join();
    }
    for (const v of message.orderBy) {
      LogicalExprNode.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.aggrFunction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expr.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.distinct = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.orderBy.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateExprNode {
    return {
      aggrFunction: isSet(object.aggrFunction) ? aggregateFunctionFromJSON(object.aggrFunction) : 0,
      expr: globalThis.Array.isArray(object?.expr) ? object.expr.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
      distinct: isSet(object.distinct) ? globalThis.Boolean(object.distinct) : false,
      filter: isSet(object.filter) ? LogicalExprNode.fromJSON(object.filter) : undefined,
      orderBy: globalThis.Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateExprNode): unknown {
    const obj: any = {};
    if (message.aggrFunction !== 0) {
      obj.aggrFunction = aggregateFunctionToJSON(message.aggrFunction);
    }
    if (message.expr?.length) {
      obj.expr = message.expr.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.distinct !== false) {
      obj.distinct = message.distinct;
    }
    if (message.filter !== undefined) {
      obj.filter = LogicalExprNode.toJSON(message.filter);
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseAggregateUDFExprNode(): AggregateUDFExprNode {
  return { funName: "", args: [], filter: undefined, orderBy: [], kwargs: {} };
}

export const AggregateUDFExprNode: MessageFns<AggregateUDFExprNode> = {
  encode(message: AggregateUDFExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.funName !== "") {
      writer.uint32(10).string(message.funName);
    }
    for (const v of message.args) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.filter !== undefined) {
      LogicalExprNode.encode(message.filter, writer.uint32(26).fork()).join();
    }
    for (const v of message.orderBy) {
      LogicalExprNode.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.kwargs).forEach(([key, value]) => {
      AggregateUDFExprNode_KwargsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateUDFExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateUDFExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.funName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderBy.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = AggregateUDFExprNode_KwargsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.kwargs[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateUDFExprNode {
    return {
      funName: isSet(object.funName) ? globalThis.String(object.funName) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
      filter: isSet(object.filter) ? LogicalExprNode.fromJSON(object.filter) : undefined,
      orderBy: globalThis.Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      kwargs: isObject(object.kwargs)
        ? Object.entries(object.kwargs).reduce<{ [key: string]: LogicalExprNode }>((acc, [key, value]) => {
          acc[key] = LogicalExprNode.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AggregateUDFExprNode): unknown {
    const obj: any = {};
    if (message.funName !== "") {
      obj.funName = message.funName;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.filter !== undefined) {
      obj.filter = LogicalExprNode.toJSON(message.filter);
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.kwargs) {
      const entries = Object.entries(message.kwargs);
      if (entries.length > 0) {
        obj.kwargs = {};
        entries.forEach(([k, v]) => {
          obj.kwargs[k] = LogicalExprNode.toJSON(v);
        });
      }
    }
    return obj;
  },
};

function createBaseAggregateUDFExprNode_KwargsEntry(): AggregateUDFExprNode_KwargsEntry {
  return { key: "", value: undefined };
}

export const AggregateUDFExprNode_KwargsEntry: MessageFns<AggregateUDFExprNode_KwargsEntry> = {
  encode(message: AggregateUDFExprNode_KwargsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LogicalExprNode.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateUDFExprNode_KwargsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateUDFExprNode_KwargsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateUDFExprNode_KwargsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LogicalExprNode.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AggregateUDFExprNode_KwargsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LogicalExprNode.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseScalarUDFExprNode(): ScalarUDFExprNode {
  return { funName: "", args: [] };
}

export const ScalarUDFExprNode: MessageFns<ScalarUDFExprNode> = {
  encode(message: ScalarUDFExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.funName !== "") {
      writer.uint32(10).string(message.funName);
    }
    for (const v of message.args) {
      LogicalExprNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarUDFExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarUDFExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.funName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarUDFExprNode {
    return {
      funName: isSet(object.funName) ? globalThis.String(object.funName) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => LogicalExprNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: ScalarUDFExprNode): unknown {
    const obj: any = {};
    if (message.funName !== "") {
      obj.funName = message.funName;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => LogicalExprNode.toJSON(e));
    }
    return obj;
  },
};

function createBaseWindowExprNode(): WindowExprNode {
  return {
    aggrFunction: undefined,
    builtInFunction: undefined,
    udaf: undefined,
    udwf: undefined,
    expr: undefined,
    partitionBy: [],
    orderBy: [],
    windowFrame: undefined,
  };
}

export const WindowExprNode: MessageFns<WindowExprNode> = {
  encode(message: WindowExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggrFunction !== undefined) {
      writer.uint32(8).int32(message.aggrFunction);
    }
    if (message.builtInFunction !== undefined) {
      writer.uint32(16).int32(message.builtInFunction);
    }
    if (message.udaf !== undefined) {
      writer.uint32(26).string(message.udaf);
    }
    if (message.udwf !== undefined) {
      writer.uint32(74).string(message.udwf);
    }
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(34).fork()).join();
    }
    for (const v of message.partitionBy) {
      LogicalExprNode.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.orderBy) {
      LogicalExprNode.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.windowFrame !== undefined) {
      WindowFrame.encode(message.windowFrame, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.aggrFunction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.builtInFunction = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.udaf = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.udwf = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.partitionBy.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderBy.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.windowFrame = WindowFrame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowExprNode {
    return {
      aggrFunction: isSet(object.aggrFunction) ? aggregateFunctionFromJSON(object.aggrFunction) : undefined,
      builtInFunction: isSet(object.builtInFunction)
        ? builtInWindowFunctionFromJSON(object.builtInFunction)
        : undefined,
      udaf: isSet(object.udaf) ? globalThis.String(object.udaf) : undefined,
      udwf: isSet(object.udwf) ? globalThis.String(object.udwf) : undefined,
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      partitionBy: globalThis.Array.isArray(object?.partitionBy)
        ? object.partitionBy.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      orderBy: globalThis.Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      windowFrame: isSet(object.windowFrame) ? WindowFrame.fromJSON(object.windowFrame) : undefined,
    };
  },

  toJSON(message: WindowExprNode): unknown {
    const obj: any = {};
    if (message.aggrFunction !== undefined) {
      obj.aggrFunction = aggregateFunctionToJSON(message.aggrFunction);
    }
    if (message.builtInFunction !== undefined) {
      obj.builtInFunction = builtInWindowFunctionToJSON(message.builtInFunction);
    }
    if (message.udaf !== undefined) {
      obj.udaf = message.udaf;
    }
    if (message.udwf !== undefined) {
      obj.udwf = message.udwf;
    }
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.partitionBy?.length) {
      obj.partitionBy = message.partitionBy.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.windowFrame !== undefined) {
      obj.windowFrame = WindowFrame.toJSON(message.windowFrame);
    }
    return obj;
  },
};

function createBaseBetweenNode(): BetweenNode {
  return { expr: undefined, negated: false, low: undefined, high: undefined };
}

export const BetweenNode: MessageFns<BetweenNode> = {
  encode(message: BetweenNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.negated !== false) {
      writer.uint32(16).bool(message.negated);
    }
    if (message.low !== undefined) {
      LogicalExprNode.encode(message.low, writer.uint32(26).fork()).join();
    }
    if (message.high !== undefined) {
      LogicalExprNode.encode(message.high, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BetweenNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBetweenNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.negated = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.low = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.high = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BetweenNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
      low: isSet(object.low) ? LogicalExprNode.fromJSON(object.low) : undefined,
      high: isSet(object.high) ? LogicalExprNode.fromJSON(object.high) : undefined,
    };
  },

  toJSON(message: BetweenNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    if (message.low !== undefined) {
      obj.low = LogicalExprNode.toJSON(message.low);
    }
    if (message.high !== undefined) {
      obj.high = LogicalExprNode.toJSON(message.high);
    }
    return obj;
  },
};

function createBaseLikeNode(): LikeNode {
  return { negated: false, expr: undefined, pattern: undefined, escapeChar: "" };
}

export const LikeNode: MessageFns<LikeNode> = {
  encode(message: LikeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.negated !== false) {
      writer.uint32(8).bool(message.negated);
    }
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(18).fork()).join();
    }
    if (message.pattern !== undefined) {
      LogicalExprNode.encode(message.pattern, writer.uint32(26).fork()).join();
    }
    if (message.escapeChar !== "") {
      writer.uint32(34).string(message.escapeChar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LikeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLikeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.negated = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pattern = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.escapeChar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LikeNode {
    return {
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      pattern: isSet(object.pattern) ? LogicalExprNode.fromJSON(object.pattern) : undefined,
      escapeChar: isSet(object.escapeChar) ? globalThis.String(object.escapeChar) : "",
    };
  },

  toJSON(message: LikeNode): unknown {
    const obj: any = {};
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.pattern !== undefined) {
      obj.pattern = LogicalExprNode.toJSON(message.pattern);
    }
    if (message.escapeChar !== "") {
      obj.escapeChar = message.escapeChar;
    }
    return obj;
  },
};

function createBaseILikeNode(): ILikeNode {
  return { negated: false, expr: undefined, pattern: undefined, escapeChar: "" };
}

export const ILikeNode: MessageFns<ILikeNode> = {
  encode(message: ILikeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.negated !== false) {
      writer.uint32(8).bool(message.negated);
    }
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(18).fork()).join();
    }
    if (message.pattern !== undefined) {
      LogicalExprNode.encode(message.pattern, writer.uint32(26).fork()).join();
    }
    if (message.escapeChar !== "") {
      writer.uint32(34).string(message.escapeChar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ILikeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseILikeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.negated = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pattern = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.escapeChar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ILikeNode {
    return {
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      pattern: isSet(object.pattern) ? LogicalExprNode.fromJSON(object.pattern) : undefined,
      escapeChar: isSet(object.escapeChar) ? globalThis.String(object.escapeChar) : "",
    };
  },

  toJSON(message: ILikeNode): unknown {
    const obj: any = {};
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.pattern !== undefined) {
      obj.pattern = LogicalExprNode.toJSON(message.pattern);
    }
    if (message.escapeChar !== "") {
      obj.escapeChar = message.escapeChar;
    }
    return obj;
  },
};

function createBaseSimilarToNode(): SimilarToNode {
  return { negated: false, expr: undefined, pattern: undefined, escapeChar: "" };
}

export const SimilarToNode: MessageFns<SimilarToNode> = {
  encode(message: SimilarToNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.negated !== false) {
      writer.uint32(8).bool(message.negated);
    }
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(18).fork()).join();
    }
    if (message.pattern !== undefined) {
      LogicalExprNode.encode(message.pattern, writer.uint32(26).fork()).join();
    }
    if (message.escapeChar !== "") {
      writer.uint32(34).string(message.escapeChar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimilarToNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimilarToNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.negated = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pattern = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.escapeChar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimilarToNode {
    return {
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      pattern: isSet(object.pattern) ? LogicalExprNode.fromJSON(object.pattern) : undefined,
      escapeChar: isSet(object.escapeChar) ? globalThis.String(object.escapeChar) : "",
    };
  },

  toJSON(message: SimilarToNode): unknown {
    const obj: any = {};
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.pattern !== undefined) {
      obj.pattern = LogicalExprNode.toJSON(message.pattern);
    }
    if (message.escapeChar !== "") {
      obj.escapeChar = message.escapeChar;
    }
    return obj;
  },
};

function createBaseCaseNode(): CaseNode {
  return { expr: undefined, whenThenExpr: [], elseExpr: undefined };
}

export const CaseNode: MessageFns<CaseNode> = {
  encode(message: CaseNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    for (const v of message.whenThenExpr) {
      WhenThen.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.elseExpr !== undefined) {
      LogicalExprNode.encode(message.elseExpr, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaseNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.whenThenExpr.push(WhenThen.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.elseExpr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaseNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      whenThenExpr: globalThis.Array.isArray(object?.whenThenExpr)
        ? object.whenThenExpr.map((e: any) => WhenThen.fromJSON(e))
        : [],
      elseExpr: isSet(object.elseExpr) ? LogicalExprNode.fromJSON(object.elseExpr) : undefined,
    };
  },

  toJSON(message: CaseNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.whenThenExpr?.length) {
      obj.whenThenExpr = message.whenThenExpr.map((e) => WhenThen.toJSON(e));
    }
    if (message.elseExpr !== undefined) {
      obj.elseExpr = LogicalExprNode.toJSON(message.elseExpr);
    }
    return obj;
  },
};

function createBaseWhenThen(): WhenThen {
  return { whenExpr: undefined, thenExpr: undefined };
}

export const WhenThen: MessageFns<WhenThen> = {
  encode(message: WhenThen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.whenExpr !== undefined) {
      LogicalExprNode.encode(message.whenExpr, writer.uint32(10).fork()).join();
    }
    if (message.thenExpr !== undefined) {
      LogicalExprNode.encode(message.thenExpr, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhenThen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhenThen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.whenExpr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thenExpr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhenThen {
    return {
      whenExpr: isSet(object.whenExpr) ? LogicalExprNode.fromJSON(object.whenExpr) : undefined,
      thenExpr: isSet(object.thenExpr) ? LogicalExprNode.fromJSON(object.thenExpr) : undefined,
    };
  },

  toJSON(message: WhenThen): unknown {
    const obj: any = {};
    if (message.whenExpr !== undefined) {
      obj.whenExpr = LogicalExprNode.toJSON(message.whenExpr);
    }
    if (message.thenExpr !== undefined) {
      obj.thenExpr = LogicalExprNode.toJSON(message.thenExpr);
    }
    return obj;
  },
};

function createBaseCastNode(): CastNode {
  return { expr: undefined, arrowType: undefined };
}

export const CastNode: MessageFns<CastNode> = {
  encode(message: CastNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CastNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCastNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CastNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: CastNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },
};

function createBaseTryCastNode(): TryCastNode {
  return { expr: undefined, arrowType: undefined };
}

export const TryCastNode: MessageFns<TryCastNode> = {
  encode(message: TryCastNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TryCastNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTryCastNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TryCastNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: TryCastNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },
};

function createBaseSortExprNode(): SortExprNode {
  return { expr: undefined, asc: false, nullsFirst: false };
}

export const SortExprNode: MessageFns<SortExprNode> = {
  encode(message: SortExprNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expr !== undefined) {
      LogicalExprNode.encode(message.expr, writer.uint32(10).fork()).join();
    }
    if (message.asc !== false) {
      writer.uint32(16).bool(message.asc);
    }
    if (message.nullsFirst !== false) {
      writer.uint32(24).bool(message.nullsFirst);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SortExprNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortExprNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.asc = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nullsFirst = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SortExprNode {
    return {
      expr: isSet(object.expr) ? LogicalExprNode.fromJSON(object.expr) : undefined,
      asc: isSet(object.asc) ? globalThis.Boolean(object.asc) : false,
      nullsFirst: isSet(object.nullsFirst) ? globalThis.Boolean(object.nullsFirst) : false,
    };
  },

  toJSON(message: SortExprNode): unknown {
    const obj: any = {};
    if (message.expr !== undefined) {
      obj.expr = LogicalExprNode.toJSON(message.expr);
    }
    if (message.asc !== false) {
      obj.asc = message.asc;
    }
    if (message.nullsFirst !== false) {
      obj.nullsFirst = message.nullsFirst;
    }
    return obj;
  },
};

function createBaseWindowFrame(): WindowFrame {
  return { windowFrameUnits: 0, startBound: undefined, bound: undefined };
}

export const WindowFrame: MessageFns<WindowFrame> = {
  encode(message: WindowFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.windowFrameUnits !== 0) {
      writer.uint32(8).int32(message.windowFrameUnits);
    }
    if (message.startBound !== undefined) {
      WindowFrameBound.encode(message.startBound, writer.uint32(18).fork()).join();
    }
    if (message.bound !== undefined) {
      WindowFrameBound.encode(message.bound, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.windowFrameUnits = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startBound = WindowFrameBound.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bound = WindowFrameBound.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowFrame {
    return {
      windowFrameUnits: isSet(object.windowFrameUnits) ? windowFrameUnitsFromJSON(object.windowFrameUnits) : 0,
      startBound: isSet(object.startBound) ? WindowFrameBound.fromJSON(object.startBound) : undefined,
      bound: isSet(object.bound) ? WindowFrameBound.fromJSON(object.bound) : undefined,
    };
  },

  toJSON(message: WindowFrame): unknown {
    const obj: any = {};
    if (message.windowFrameUnits !== 0) {
      obj.windowFrameUnits = windowFrameUnitsToJSON(message.windowFrameUnits);
    }
    if (message.startBound !== undefined) {
      obj.startBound = WindowFrameBound.toJSON(message.startBound);
    }
    if (message.bound !== undefined) {
      obj.bound = WindowFrameBound.toJSON(message.bound);
    }
    return obj;
  },
};

function createBaseWindowFrameBound(): WindowFrameBound {
  return { windowFrameBoundType: 0, boundValue: undefined };
}

export const WindowFrameBound: MessageFns<WindowFrameBound> = {
  encode(message: WindowFrameBound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.windowFrameBoundType !== 0) {
      writer.uint32(8).int32(message.windowFrameBoundType);
    }
    if (message.boundValue !== undefined) {
      ScalarValue.encode(message.boundValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowFrameBound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowFrameBound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.windowFrameBoundType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.boundValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowFrameBound {
    return {
      windowFrameBoundType: isSet(object.windowFrameBoundType)
        ? windowFrameBoundTypeFromJSON(object.windowFrameBoundType)
        : 0,
      boundValue: isSet(object.boundValue) ? ScalarValue.fromJSON(object.boundValue) : undefined,
    };
  },

  toJSON(message: WindowFrameBound): unknown {
    const obj: any = {};
    if (message.windowFrameBoundType !== 0) {
      obj.windowFrameBoundType = windowFrameBoundTypeToJSON(message.windowFrameBoundType);
    }
    if (message.boundValue !== undefined) {
      obj.boundValue = ScalarValue.toJSON(message.boundValue);
    }
    return obj;
  },
};

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
