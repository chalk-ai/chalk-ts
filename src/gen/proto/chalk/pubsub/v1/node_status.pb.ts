// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/pubsub/v1/node_status.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "chalk.pubsub.v1";

/**
 * THIS FILE CONTROLS ALL THE BILLING MONITORING. PLEASE BE VERY CAREFUL.
 *
 * When you update this file, you MUST run terraform apply
 *
 * If `terraform apply` is not run, we will stop censusing the nodes in the
 * clusters that we run, which will impact our revenue.
 *
 * If you're not sure, please ask!
 *
 * PLEASE RUN TERRAFORM APPLY BEFORE MERGING THIS FILE
 */

/** InstanceUsage is a message that represents the usage of a single instance. */
export interface NodeStatusPubSub {
  /** The Chalk team name that incurred the usage. */
  team: string;
  /**
   * node.Name
   * ex. ip-10-33-13-186.us-west-2.compute.internal
   */
  name: string;
  /**
   * A Kubernetes systems-generated string to uniquely identify objects.
   * Every object created over the whole lifetime of a Kubernetes cluster
   * has a distinct UID. It is intended to distinguish between historical
   * occurrences of similar entities. Kubernetes UIDs are UUIDs.
   * ex. f65e1fce-e511-495f-a5af-e5d4ebe79614
   */
  uid: string;
  /**
   * node.kubernetes.io/instance-type
   * ex. t3.medium
   */
  instanceType: string;
  /**
   * topology.kubernetes.io/region
   * ex. us-west-2
   */
  region: string;
  /**
   * topology.kubernetes.io/zone
   * ex. us-west-2a
   */
  zone: string;
  /**
   * The time that the instance was created.
   * node.CreationTimestamp.Unix()
   */
  creationTimestamp: number;
  /**
   * node.DeletionTimestamp.Unix()
   * The time that the instance was deleted. May be 0 if the instance is still running.
   */
  deletionTimestamp: number;
  /** The time that we polled the instance for usage. */
  observedTimestamp: number;
  /** node.Labels */
  labels: { [key: string]: string };
  /** node.Annotations */
  annotations: { [key: string]: string };
  /**
   * MachineID reported by the node. For unique machine identification
   * in the cluster this field is preferred. Learn more from man(5)
   * machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
   * ex. ec2d1437f00e85506a67dc38744731fe
   */
  machineId: string;
  /**
   * SystemUUID reported by the node. For unique machine identification
   * MachineID is preferred. This field is specific to Red Hat hosts
   * https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
   * ex. ec2d1437-f00e-8550-6a67-dc38744731fe
   */
  systemUuid: string;
  /**
   * Boot ID reported by the node.
   * ex. 2c094fc9-b776-4223-9316-c66e70f9f6b9
   */
  bootId: string;
  unschedulable: boolean;
  namespace: string;
  /**
   * Often null.
   * container.googleapis.com/instance_id
   */
  instanceId: string;
  /**
   * The name of the cluster that the node is in.
   * ex. mycompany-prod-eks
   */
  cluster: string;
  totalCpu: string;
  totalMemory: string;
  allocatableCpu: string;
  allocatableMemory: string;
  chalkManaged: boolean;
}

export interface NodeStatusPubSub_LabelsEntry {
  key: string;
  value: string;
}

export interface NodeStatusPubSub_AnnotationsEntry {
  key: string;
  value: string;
}

function createBaseNodeStatusPubSub(): NodeStatusPubSub {
  return {
    team: "",
    name: "",
    uid: "",
    instanceType: "",
    region: "",
    zone: "",
    creationTimestamp: 0,
    deletionTimestamp: 0,
    observedTimestamp: 0,
    labels: {},
    annotations: {},
    machineId: "",
    systemUuid: "",
    bootId: "",
    unschedulable: false,
    namespace: "",
    instanceId: "",
    cluster: "",
    totalCpu: "",
    totalMemory: "",
    allocatableCpu: "",
    allocatableMemory: "",
    chalkManaged: false,
  };
}

export const NodeStatusPubSub: MessageFns<NodeStatusPubSub> = {
  encode(message: NodeStatusPubSub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.team !== "") {
      writer.uint32(10).string(message.team);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.instanceType !== "") {
      writer.uint32(34).string(message.instanceType);
    }
    if (message.region !== "") {
      writer.uint32(42).string(message.region);
    }
    if (message.zone !== "") {
      writer.uint32(50).string(message.zone);
    }
    if (message.creationTimestamp !== 0) {
      writer.uint32(64).int64(message.creationTimestamp);
    }
    if (message.deletionTimestamp !== 0) {
      writer.uint32(72).int64(message.deletionTimestamp);
    }
    if (message.observedTimestamp !== 0) {
      writer.uint32(80).int64(message.observedTimestamp);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NodeStatusPubSub_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      NodeStatusPubSub_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.machineId !== "") {
      writer.uint32(106).string(message.machineId);
    }
    if (message.systemUuid !== "") {
      writer.uint32(114).string(message.systemUuid);
    }
    if (message.bootId !== "") {
      writer.uint32(122).string(message.bootId);
    }
    if (message.unschedulable !== false) {
      writer.uint32(128).bool(message.unschedulable);
    }
    if (message.namespace !== "") {
      writer.uint32(138).string(message.namespace);
    }
    if (message.instanceId !== "") {
      writer.uint32(146).string(message.instanceId);
    }
    if (message.cluster !== "") {
      writer.uint32(154).string(message.cluster);
    }
    if (message.totalCpu !== "") {
      writer.uint32(162).string(message.totalCpu);
    }
    if (message.totalMemory !== "") {
      writer.uint32(170).string(message.totalMemory);
    }
    if (message.allocatableCpu !== "") {
      writer.uint32(178).string(message.allocatableCpu);
    }
    if (message.allocatableMemory !== "") {
      writer.uint32(186).string(message.allocatableMemory);
    }
    if (message.chalkManaged !== false) {
      writer.uint32(192).bool(message.chalkManaged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeStatusPubSub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeStatusPubSub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.team = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instanceType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.creationTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.deletionTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.observedTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = NodeStatusPubSub_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = NodeStatusPubSub_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.annotations[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.machineId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.systemUuid = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.bootId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.unschedulable = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.totalCpu = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.totalMemory = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.allocatableCpu = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.allocatableMemory = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.chalkManaged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeStatusPubSub {
    return {
      team: isSet(object.team) ? globalThis.String(object.team) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      instanceType: isSet(object.instanceType) ? globalThis.String(object.instanceType) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      creationTimestamp: isSet(object.creationTimestamp) ? globalThis.Number(object.creationTimestamp) : 0,
      deletionTimestamp: isSet(object.deletionTimestamp) ? globalThis.Number(object.deletionTimestamp) : 0,
      observedTimestamp: isSet(object.observedTimestamp) ? globalThis.Number(object.observedTimestamp) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      machineId: isSet(object.machineId) ? globalThis.String(object.machineId) : "",
      systemUuid: isSet(object.systemUuid) ? globalThis.String(object.systemUuid) : "",
      bootId: isSet(object.bootId) ? globalThis.String(object.bootId) : "",
      unschedulable: isSet(object.unschedulable) ? globalThis.Boolean(object.unschedulable) : false,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      totalCpu: isSet(object.totalCpu) ? globalThis.String(object.totalCpu) : "",
      totalMemory: isSet(object.totalMemory) ? globalThis.String(object.totalMemory) : "",
      allocatableCpu: isSet(object.allocatableCpu) ? globalThis.String(object.allocatableCpu) : "",
      allocatableMemory: isSet(object.allocatableMemory) ? globalThis.String(object.allocatableMemory) : "",
      chalkManaged: isSet(object.chalkManaged) ? globalThis.Boolean(object.chalkManaged) : false,
    };
  },

  toJSON(message: NodeStatusPubSub): unknown {
    const obj: any = {};
    if (message.team !== "") {
      obj.team = message.team;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.instanceType !== "") {
      obj.instanceType = message.instanceType;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.creationTimestamp !== 0) {
      obj.creationTimestamp = Math.round(message.creationTimestamp);
    }
    if (message.deletionTimestamp !== 0) {
      obj.deletionTimestamp = Math.round(message.deletionTimestamp);
    }
    if (message.observedTimestamp !== 0) {
      obj.observedTimestamp = Math.round(message.observedTimestamp);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.machineId !== "") {
      obj.machineId = message.machineId;
    }
    if (message.systemUuid !== "") {
      obj.systemUuid = message.systemUuid;
    }
    if (message.bootId !== "") {
      obj.bootId = message.bootId;
    }
    if (message.unschedulable !== false) {
      obj.unschedulable = message.unschedulable;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.totalCpu !== "") {
      obj.totalCpu = message.totalCpu;
    }
    if (message.totalMemory !== "") {
      obj.totalMemory = message.totalMemory;
    }
    if (message.allocatableCpu !== "") {
      obj.allocatableCpu = message.allocatableCpu;
    }
    if (message.allocatableMemory !== "") {
      obj.allocatableMemory = message.allocatableMemory;
    }
    if (message.chalkManaged !== false) {
      obj.chalkManaged = message.chalkManaged;
    }
    return obj;
  },
};

function createBaseNodeStatusPubSub_LabelsEntry(): NodeStatusPubSub_LabelsEntry {
  return { key: "", value: "" };
}

export const NodeStatusPubSub_LabelsEntry: MessageFns<NodeStatusPubSub_LabelsEntry> = {
  encode(message: NodeStatusPubSub_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeStatusPubSub_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeStatusPubSub_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeStatusPubSub_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeStatusPubSub_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseNodeStatusPubSub_AnnotationsEntry(): NodeStatusPubSub_AnnotationsEntry {
  return { key: "", value: "" };
}

export const NodeStatusPubSub_AnnotationsEntry: MessageFns<NodeStatusPubSub_AnnotationsEntry> = {
  encode(message: NodeStatusPubSub_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeStatusPubSub_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeStatusPubSub_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeStatusPubSub_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeStatusPubSub_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
