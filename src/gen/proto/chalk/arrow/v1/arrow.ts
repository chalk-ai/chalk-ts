// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/arrow/v1/arrow.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "chalk.arrow.v1";

export enum TimeUnit {
  TIME_UNIT_UNSPECIFIED = 0,
  TIME_UNIT_SECOND = 1,
  TIME_UNIT_MILLISECOND = 2,
  TIME_UNIT_MICROSECOND = 3,
  TIME_UNIT_NANOSECOND = 4,
  UNRECOGNIZED = -1,
}

export function timeUnitFromJSON(object: any): TimeUnit {
  switch (object) {
    case 0:
    case "TIME_UNIT_UNSPECIFIED":
      return TimeUnit.TIME_UNIT_UNSPECIFIED;
    case 1:
    case "TIME_UNIT_SECOND":
      return TimeUnit.TIME_UNIT_SECOND;
    case 2:
    case "TIME_UNIT_MILLISECOND":
      return TimeUnit.TIME_UNIT_MILLISECOND;
    case 3:
    case "TIME_UNIT_MICROSECOND":
      return TimeUnit.TIME_UNIT_MICROSECOND;
    case 4:
    case "TIME_UNIT_NANOSECOND":
      return TimeUnit.TIME_UNIT_NANOSECOND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TimeUnit.UNRECOGNIZED;
  }
}

export function timeUnitToJSON(object: TimeUnit): string {
  switch (object) {
    case TimeUnit.TIME_UNIT_UNSPECIFIED:
      return "TIME_UNIT_UNSPECIFIED";
    case TimeUnit.TIME_UNIT_SECOND:
      return "TIME_UNIT_SECOND";
    case TimeUnit.TIME_UNIT_MILLISECOND:
      return "TIME_UNIT_MILLISECOND";
    case TimeUnit.TIME_UNIT_MICROSECOND:
      return "TIME_UNIT_MICROSECOND";
    case TimeUnit.TIME_UNIT_NANOSECOND:
      return "TIME_UNIT_NANOSECOND";
    case TimeUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FeatherCompression {
  FEATHER_COMPRESSION_UNSPECIFIED = 0,
  FEATHER_COMPRESSION_UNCOMPRESSED = 1,
  FEATHER_COMPRESSION_LZ4 = 2,
  FEATHER_COMPRESSION_ZSTD = 3,
  UNRECOGNIZED = -1,
}

export function featherCompressionFromJSON(object: any): FeatherCompression {
  switch (object) {
    case 0:
    case "FEATHER_COMPRESSION_UNSPECIFIED":
      return FeatherCompression.FEATHER_COMPRESSION_UNSPECIFIED;
    case 1:
    case "FEATHER_COMPRESSION_UNCOMPRESSED":
      return FeatherCompression.FEATHER_COMPRESSION_UNCOMPRESSED;
    case 2:
    case "FEATHER_COMPRESSION_LZ4":
      return FeatherCompression.FEATHER_COMPRESSION_LZ4;
    case 3:
    case "FEATHER_COMPRESSION_ZSTD":
      return FeatherCompression.FEATHER_COMPRESSION_ZSTD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatherCompression.UNRECOGNIZED;
  }
}

export function featherCompressionToJSON(object: FeatherCompression): string {
  switch (object) {
    case FeatherCompression.FEATHER_COMPRESSION_UNSPECIFIED:
      return "FEATHER_COMPRESSION_UNSPECIFIED";
    case FeatherCompression.FEATHER_COMPRESSION_UNCOMPRESSED:
      return "FEATHER_COMPRESSION_UNCOMPRESSED";
    case FeatherCompression.FEATHER_COMPRESSION_LZ4:
      return "FEATHER_COMPRESSION_LZ4";
    case FeatherCompression.FEATHER_COMPRESSION_ZSTD:
      return "FEATHER_COMPRESSION_ZSTD";
    case FeatherCompression.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Schema {
  columns: Field[];
  metadata: { [key: string]: string };
}

export interface Schema_MetadataEntry {
  key: string;
  value: string;
}

export interface Field {
  name: string;
  arrowType: ArrowType | undefined;
  nullable: boolean;
  children: Field[];
  metadata: { [key: string]: string };
}

export interface Field_MetadataEntry {
  key: string;
  value: string;
}

export interface FixedSizeBinary {
  length: number;
}

export interface Timestamp {
  timeUnit: TimeUnit;
  timezone: string;
}

export interface Decimal {
  precision: number;
  scale: number;
}

export interface List {
  fieldType: Field | undefined;
}

export interface FixedSizeList {
  fieldType: Field | undefined;
  listSize: number;
}

export interface Struct {
  subFieldTypes: Field[];
}

export interface Map {
  keyField: Field | undefined;
  itemField: Field | undefined;
  keysSorted: boolean;
}

export interface ScalarListValue {
  arrowData: Uint8Array;
  schema: Schema | undefined;
}

export interface ScalarTime32Value {
  time32SecondValue?: number | undefined;
  time32MillisecondValue?: number | undefined;
}

export interface ScalarTime64Value {
  time64MicrosecondValue?: number | undefined;
  time64NanosecondValue?: number | undefined;
}

export interface ScalarTimestampValue {
  timeMicrosecondValue?: number | undefined;
  timeNanosecondValue?: number | undefined;
  timeSecondValue?: number | undefined;
  timeMillisecondValue?: number | undefined;
  timezone: string;
}

export interface StructValue {
  fieldValues: ScalarValue[];
  fields: Field[];
}

export interface ScalarFixedSizeBinary {
  values: Uint8Array;
  length: number;
}

export interface DecimalValue {
  value: Uint8Array;
  precision: number;
  scale: number;
}

/** Extension is used to */
export interface Extension {
  /**
   * The name of the extension -- e.g. arrow.json. See
   * https://arrow.apache.org/docs/format/CanonicalExtensions.html
   */
  name: string;
  /** The underlying storage type for this extension type. */
  storageType: ArrowType | undefined;
}

export interface ExtensionValue {
  extensionType: Extension | undefined;
  storageValue: ScalarValue | undefined;
}

export interface ScalarValue {
  /**
   * Group popular types at the top
   * to save space in the serialized
   * message.
   */
  nullValue?: ArrowType | undefined;
  boolValue?: boolean | undefined;
  float64Value?: number | undefined;
  int64Value?: number | undefined;
  largeUtf8Value?: string | undefined;
  timestampValue?: ScalarTimestampValue | undefined;
  date64Value?: number | undefined;
  structValue?: StructValue | undefined;
  largeListValue?:
    | ScalarListValue
    | undefined;
  /**
   * Leave placeholders for 11-15 in case
   * we get the most popular types wrong.
   */
  time64Value?: ScalarTime64Value | undefined;
  durationSecondValue?: number | undefined;
  durationMillisecondValue?: number | undefined;
  durationMicrosecondValue?: number | undefined;
  durationNanosecondValue?: number | undefined;
  utf8Value?: string | undefined;
  int8Value?: number | undefined;
  int16Value?: number | undefined;
  int32Value?: number | undefined;
  uint8Value?: number | undefined;
  uint16Value?: number | undefined;
  uint32Value?: number | undefined;
  uint64Value?: number | undefined;
  float16Value?: number | undefined;
  float32Value?: number | undefined;
  date32Value?: number | undefined;
  time32Value?: ScalarTime32Value | undefined;
  listValue?: ScalarListValue | undefined;
  fixedSizeListValue?: ScalarListValue | undefined;
  mapValue?: ScalarListValue | undefined;
  binaryValue?: Uint8Array | undefined;
  largeBinaryValue?: Uint8Array | undefined;
  fixedSizeBinaryValue?: ScalarFixedSizeBinary | undefined;
  decimal128Value?: DecimalValue | undefined;
  decimal256Value?: DecimalValue | undefined;
  extensionValue?: ExtensionValue | undefined;
}

export interface ArrowType {
  /**
   * Group popular types at the top
   * to save space in the serialized
   * message.
   */
  none?: EmptyMessage | undefined;
  bool?: EmptyMessage | undefined;
  float64?: EmptyMessage | undefined;
  int64?: EmptyMessage | undefined;
  largeUtf8?: EmptyMessage | undefined;
  timestamp?: Timestamp | undefined;
  date64?: EmptyMessage | undefined;
  struct?: Struct | undefined;
  largeList?:
    | List
    | undefined;
  /**
   * Leave placeholders for 11-15 in case
   * we get the most popular types wrong.
   */
  time64?: TimeUnit | undefined;
  duration?: TimeUnit | undefined;
  utf8?: EmptyMessage | undefined;
  int8?: EmptyMessage | undefined;
  int16?: EmptyMessage | undefined;
  int32?: EmptyMessage | undefined;
  uint8?: EmptyMessage | undefined;
  uint16?: EmptyMessage | undefined;
  uint32?: EmptyMessage | undefined;
  uint64?: EmptyMessage | undefined;
  float16?: EmptyMessage | undefined;
  float32?: EmptyMessage | undefined;
  date32?: EmptyMessage | undefined;
  time32?: TimeUnit | undefined;
  list?: List | undefined;
  fixedSizeList?: FixedSizeList | undefined;
  binary?: EmptyMessage | undefined;
  largeBinary?: EmptyMessage | undefined;
  fixedSizeBinary?: number | undefined;
  decimal128?: Decimal | undefined;
  decimal256?: Decimal | undefined;
  map?: Map | undefined;
  extension?: Extension | undefined;
}

export interface EmptyMessage {
}

function createBaseSchema(): Schema {
  return { columns: [], metadata: {} };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      Field.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Schema_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.columns.push(Field.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Schema_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => Field.fromJSON(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => Field.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schema>, I>>(base?: I): Schema {
    return Schema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schema>, I>>(object: I): Schema {
    const message = createBaseSchema();
    message.columns = object.columns?.map((e) => Field.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSchema_MetadataEntry(): Schema_MetadataEntry {
  return { key: "", value: "" };
}

export const Schema_MetadataEntry: MessageFns<Schema_MetadataEntry> = {
  encode(message: Schema_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Schema_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schema_MetadataEntry>, I>>(base?: I): Schema_MetadataEntry {
    return Schema_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schema_MetadataEntry>, I>>(object: I): Schema_MetadataEntry {
    const message = createBaseSchema_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseField(): Field {
  return { name: "", arrowType: undefined, nullable: false, children: [], metadata: {} };
}

export const Field: MessageFns<Field> = {
  encode(message: Field, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    if (message.nullable !== false) {
      writer.uint32(24).bool(message.nullable);
    }
    for (const v of message.children) {
      Field.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Field_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Field {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.children.push(Field.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = Field_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Field {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Field.fromJSON(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Field): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Field.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Field>, I>>(base?: I): Field {
    return Field.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Field>, I>>(object: I): Field {
    const message = createBaseField();
    message.name = object.name ?? "";
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    message.nullable = object.nullable ?? false;
    message.children = object.children?.map((e) => Field.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseField_MetadataEntry(): Field_MetadataEntry {
  return { key: "", value: "" };
}

export const Field_MetadataEntry: MessageFns<Field_MetadataEntry> = {
  encode(message: Field_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Field_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseField_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Field_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Field_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Field_MetadataEntry>, I>>(base?: I): Field_MetadataEntry {
    return Field_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Field_MetadataEntry>, I>>(object: I): Field_MetadataEntry {
    const message = createBaseField_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFixedSizeBinary(): FixedSizeBinary {
  return { length: 0 };
}

export const FixedSizeBinary: MessageFns<FixedSizeBinary> = {
  encode(message: FixedSizeBinary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.length !== 0) {
      writer.uint32(8).int32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedSizeBinary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedSizeBinary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedSizeBinary {
    return { length: isSet(object.length) ? globalThis.Number(object.length) : 0 };
  },

  toJSON(message: FixedSizeBinary): unknown {
    const obj: any = {};
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FixedSizeBinary>, I>>(base?: I): FixedSizeBinary {
    return FixedSizeBinary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FixedSizeBinary>, I>>(object: I): FixedSizeBinary {
    const message = createBaseFixedSizeBinary();
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseTimestamp(): Timestamp {
  return { timeUnit: 0, timezone: "" };
}

export const Timestamp: MessageFns<Timestamp> = {
  encode(message: Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeUnit !== 0) {
      writer.uint32(8).int32(message.timeUnit);
    }
    if (message.timezone !== "") {
      writer.uint32(18).string(message.timezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Timestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeUnit = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Timestamp {
    return {
      timeUnit: isSet(object.timeUnit) ? timeUnitFromJSON(object.timeUnit) : 0,
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
    };
  },

  toJSON(message: Timestamp): unknown {
    const obj: any = {};
    if (message.timeUnit !== 0) {
      obj.timeUnit = timeUnitToJSON(message.timeUnit);
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Timestamp>, I>>(base?: I): Timestamp {
    return Timestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(object: I): Timestamp {
    const message = createBaseTimestamp();
    message.timeUnit = object.timeUnit ?? 0;
    message.timezone = object.timezone ?? "";
    return message;
  },
};

function createBaseDecimal(): Decimal {
  return { precision: 0, scale: 0 };
}

export const Decimal: MessageFns<Decimal> = {
  encode(message: Decimal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.precision !== 0) {
      writer.uint32(8).int32(message.precision);
    }
    if (message.scale !== 0) {
      writer.uint32(16).int32(message.scale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Decimal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.precision = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scale = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Decimal {
    return {
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
    };
  },

  toJSON(message: Decimal): unknown {
    const obj: any = {};
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Decimal>, I>>(base?: I): Decimal {
    return Decimal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Decimal>, I>>(object: I): Decimal {
    const message = createBaseDecimal();
    message.precision = object.precision ?? 0;
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseList(): List {
  return { fieldType: undefined };
}

export const List: MessageFns<List> = {
  encode(message: List, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldType !== undefined) {
      Field.encode(message.fieldType, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): List {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fieldType = Field.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): List {
    return { fieldType: isSet(object.fieldType) ? Field.fromJSON(object.fieldType) : undefined };
  },

  toJSON(message: List): unknown {
    const obj: any = {};
    if (message.fieldType !== undefined) {
      obj.fieldType = Field.toJSON(message.fieldType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<List>, I>>(base?: I): List {
    return List.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<List>, I>>(object: I): List {
    const message = createBaseList();
    message.fieldType = (object.fieldType !== undefined && object.fieldType !== null)
      ? Field.fromPartial(object.fieldType)
      : undefined;
    return message;
  },
};

function createBaseFixedSizeList(): FixedSizeList {
  return { fieldType: undefined, listSize: 0 };
}

export const FixedSizeList: MessageFns<FixedSizeList> = {
  encode(message: FixedSizeList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldType !== undefined) {
      Field.encode(message.fieldType, writer.uint32(10).fork()).join();
    }
    if (message.listSize !== 0) {
      writer.uint32(16).int32(message.listSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedSizeList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedSizeList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fieldType = Field.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.listSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedSizeList {
    return {
      fieldType: isSet(object.fieldType) ? Field.fromJSON(object.fieldType) : undefined,
      listSize: isSet(object.listSize) ? globalThis.Number(object.listSize) : 0,
    };
  },

  toJSON(message: FixedSizeList): unknown {
    const obj: any = {};
    if (message.fieldType !== undefined) {
      obj.fieldType = Field.toJSON(message.fieldType);
    }
    if (message.listSize !== 0) {
      obj.listSize = Math.round(message.listSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FixedSizeList>, I>>(base?: I): FixedSizeList {
    return FixedSizeList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FixedSizeList>, I>>(object: I): FixedSizeList {
    const message = createBaseFixedSizeList();
    message.fieldType = (object.fieldType !== undefined && object.fieldType !== null)
      ? Field.fromPartial(object.fieldType)
      : undefined;
    message.listSize = object.listSize ?? 0;
    return message;
  },
};

function createBaseStruct(): Struct {
  return { subFieldTypes: [] };
}

export const Struct: MessageFns<Struct> = {
  encode(message: Struct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subFieldTypes) {
      Field.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Struct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subFieldTypes.push(Field.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Struct {
    return {
      subFieldTypes: globalThis.Array.isArray(object?.subFieldTypes)
        ? object.subFieldTypes.map((e: any) => Field.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Struct): unknown {
    const obj: any = {};
    if (message.subFieldTypes?.length) {
      obj.subFieldTypes = message.subFieldTypes.map((e) => Field.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Struct>, I>>(base?: I): Struct {
    return Struct.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Struct>, I>>(object: I): Struct {
    const message = createBaseStruct();
    message.subFieldTypes = object.subFieldTypes?.map((e) => Field.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMap(): Map {
  return { keyField: undefined, itemField: undefined, keysSorted: false };
}

export const Map: MessageFns<Map> = {
  encode(message: Map, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyField !== undefined) {
      Field.encode(message.keyField, writer.uint32(10).fork()).join();
    }
    if (message.itemField !== undefined) {
      Field.encode(message.itemField, writer.uint32(18).fork()).join();
    }
    if (message.keysSorted !== false) {
      writer.uint32(24).bool(message.keysSorted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Map {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyField = Field.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.itemField = Field.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keysSorted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Map {
    return {
      keyField: isSet(object.keyField) ? Field.fromJSON(object.keyField) : undefined,
      itemField: isSet(object.itemField) ? Field.fromJSON(object.itemField) : undefined,
      keysSorted: isSet(object.keysSorted) ? globalThis.Boolean(object.keysSorted) : false,
    };
  },

  toJSON(message: Map): unknown {
    const obj: any = {};
    if (message.keyField !== undefined) {
      obj.keyField = Field.toJSON(message.keyField);
    }
    if (message.itemField !== undefined) {
      obj.itemField = Field.toJSON(message.itemField);
    }
    if (message.keysSorted !== false) {
      obj.keysSorted = message.keysSorted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Map>, I>>(base?: I): Map {
    return Map.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Map>, I>>(object: I): Map {
    const message = createBaseMap();
    message.keyField = (object.keyField !== undefined && object.keyField !== null)
      ? Field.fromPartial(object.keyField)
      : undefined;
    message.itemField = (object.itemField !== undefined && object.itemField !== null)
      ? Field.fromPartial(object.itemField)
      : undefined;
    message.keysSorted = object.keysSorted ?? false;
    return message;
  },
};

function createBaseScalarListValue(): ScalarListValue {
  return { arrowData: new Uint8Array(0), schema: undefined };
}

export const ScalarListValue: MessageFns<ScalarListValue> = {
  encode(message: ScalarListValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.arrowData.length !== 0) {
      writer.uint32(10).bytes(message.arrowData);
    }
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarListValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arrowData = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarListValue {
    return {
      arrowData: isSet(object.arrowData) ? bytesFromBase64(object.arrowData) : new Uint8Array(0),
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
    };
  },

  toJSON(message: ScalarListValue): unknown {
    const obj: any = {};
    if (message.arrowData.length !== 0) {
      obj.arrowData = base64FromBytes(message.arrowData);
    }
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarListValue>, I>>(base?: I): ScalarListValue {
    return ScalarListValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarListValue>, I>>(object: I): ScalarListValue {
    const message = createBaseScalarListValue();
    message.arrowData = object.arrowData ?? new Uint8Array(0);
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    return message;
  },
};

function createBaseScalarTime32Value(): ScalarTime32Value {
  return { time32SecondValue: undefined, time32MillisecondValue: undefined };
}

export const ScalarTime32Value: MessageFns<ScalarTime32Value> = {
  encode(message: ScalarTime32Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time32SecondValue !== undefined) {
      writer.uint32(8).int32(message.time32SecondValue);
    }
    if (message.time32MillisecondValue !== undefined) {
      writer.uint32(16).int32(message.time32MillisecondValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarTime32Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarTime32Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.time32SecondValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.time32MillisecondValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarTime32Value {
    return {
      time32SecondValue: isSet(object.time32SecondValue) ? globalThis.Number(object.time32SecondValue) : undefined,
      time32MillisecondValue: isSet(object.time32MillisecondValue)
        ? globalThis.Number(object.time32MillisecondValue)
        : undefined,
    };
  },

  toJSON(message: ScalarTime32Value): unknown {
    const obj: any = {};
    if (message.time32SecondValue !== undefined) {
      obj.time32SecondValue = Math.round(message.time32SecondValue);
    }
    if (message.time32MillisecondValue !== undefined) {
      obj.time32MillisecondValue = Math.round(message.time32MillisecondValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarTime32Value>, I>>(base?: I): ScalarTime32Value {
    return ScalarTime32Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarTime32Value>, I>>(object: I): ScalarTime32Value {
    const message = createBaseScalarTime32Value();
    message.time32SecondValue = object.time32SecondValue ?? undefined;
    message.time32MillisecondValue = object.time32MillisecondValue ?? undefined;
    return message;
  },
};

function createBaseScalarTime64Value(): ScalarTime64Value {
  return { time64MicrosecondValue: undefined, time64NanosecondValue: undefined };
}

export const ScalarTime64Value: MessageFns<ScalarTime64Value> = {
  encode(message: ScalarTime64Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time64MicrosecondValue !== undefined) {
      writer.uint32(8).int64(message.time64MicrosecondValue);
    }
    if (message.time64NanosecondValue !== undefined) {
      writer.uint32(16).int64(message.time64NanosecondValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarTime64Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarTime64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.time64MicrosecondValue = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.time64NanosecondValue = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarTime64Value {
    return {
      time64MicrosecondValue: isSet(object.time64MicrosecondValue)
        ? globalThis.Number(object.time64MicrosecondValue)
        : undefined,
      time64NanosecondValue: isSet(object.time64NanosecondValue)
        ? globalThis.Number(object.time64NanosecondValue)
        : undefined,
    };
  },

  toJSON(message: ScalarTime64Value): unknown {
    const obj: any = {};
    if (message.time64MicrosecondValue !== undefined) {
      obj.time64MicrosecondValue = Math.round(message.time64MicrosecondValue);
    }
    if (message.time64NanosecondValue !== undefined) {
      obj.time64NanosecondValue = Math.round(message.time64NanosecondValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarTime64Value>, I>>(base?: I): ScalarTime64Value {
    return ScalarTime64Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarTime64Value>, I>>(object: I): ScalarTime64Value {
    const message = createBaseScalarTime64Value();
    message.time64MicrosecondValue = object.time64MicrosecondValue ?? undefined;
    message.time64NanosecondValue = object.time64NanosecondValue ?? undefined;
    return message;
  },
};

function createBaseScalarTimestampValue(): ScalarTimestampValue {
  return {
    timeMicrosecondValue: undefined,
    timeNanosecondValue: undefined,
    timeSecondValue: undefined,
    timeMillisecondValue: undefined,
    timezone: "",
  };
}

export const ScalarTimestampValue: MessageFns<ScalarTimestampValue> = {
  encode(message: ScalarTimestampValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeMicrosecondValue !== undefined) {
      writer.uint32(8).int64(message.timeMicrosecondValue);
    }
    if (message.timeNanosecondValue !== undefined) {
      writer.uint32(16).int64(message.timeNanosecondValue);
    }
    if (message.timeSecondValue !== undefined) {
      writer.uint32(24).int64(message.timeSecondValue);
    }
    if (message.timeMillisecondValue !== undefined) {
      writer.uint32(32).int64(message.timeMillisecondValue);
    }
    if (message.timezone !== "") {
      writer.uint32(42).string(message.timezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarTimestampValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarTimestampValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeMicrosecondValue = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timeNanosecondValue = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timeSecondValue = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timeMillisecondValue = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarTimestampValue {
    return {
      timeMicrosecondValue: isSet(object.timeMicrosecondValue)
        ? globalThis.Number(object.timeMicrosecondValue)
        : undefined,
      timeNanosecondValue: isSet(object.timeNanosecondValue)
        ? globalThis.Number(object.timeNanosecondValue)
        : undefined,
      timeSecondValue: isSet(object.timeSecondValue) ? globalThis.Number(object.timeSecondValue) : undefined,
      timeMillisecondValue: isSet(object.timeMillisecondValue)
        ? globalThis.Number(object.timeMillisecondValue)
        : undefined,
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
    };
  },

  toJSON(message: ScalarTimestampValue): unknown {
    const obj: any = {};
    if (message.timeMicrosecondValue !== undefined) {
      obj.timeMicrosecondValue = Math.round(message.timeMicrosecondValue);
    }
    if (message.timeNanosecondValue !== undefined) {
      obj.timeNanosecondValue = Math.round(message.timeNanosecondValue);
    }
    if (message.timeSecondValue !== undefined) {
      obj.timeSecondValue = Math.round(message.timeSecondValue);
    }
    if (message.timeMillisecondValue !== undefined) {
      obj.timeMillisecondValue = Math.round(message.timeMillisecondValue);
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarTimestampValue>, I>>(base?: I): ScalarTimestampValue {
    return ScalarTimestampValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarTimestampValue>, I>>(object: I): ScalarTimestampValue {
    const message = createBaseScalarTimestampValue();
    message.timeMicrosecondValue = object.timeMicrosecondValue ?? undefined;
    message.timeNanosecondValue = object.timeNanosecondValue ?? undefined;
    message.timeSecondValue = object.timeSecondValue ?? undefined;
    message.timeMillisecondValue = object.timeMillisecondValue ?? undefined;
    message.timezone = object.timezone ?? "";
    return message;
  },
};

function createBaseStructValue(): StructValue {
  return { fieldValues: [], fields: [] };
}

export const StructValue: MessageFns<StructValue> = {
  encode(message: StructValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fieldValues) {
      ScalarValue.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.fields) {
      Field.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fieldValues.push(ScalarValue.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fields.push(Field.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructValue {
    return {
      fieldValues: globalThis.Array.isArray(object?.fieldValues)
        ? object.fieldValues.map((e: any) => ScalarValue.fromJSON(e))
        : [],
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Field.fromJSON(e)) : [],
    };
  },

  toJSON(message: StructValue): unknown {
    const obj: any = {};
    if (message.fieldValues?.length) {
      obj.fieldValues = message.fieldValues.map((e) => ScalarValue.toJSON(e));
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Field.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StructValue>, I>>(base?: I): StructValue {
    return StructValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StructValue>, I>>(object: I): StructValue {
    const message = createBaseStructValue();
    message.fieldValues = object.fieldValues?.map((e) => ScalarValue.fromPartial(e)) || [];
    message.fields = object.fields?.map((e) => Field.fromPartial(e)) || [];
    return message;
  },
};

function createBaseScalarFixedSizeBinary(): ScalarFixedSizeBinary {
  return { values: new Uint8Array(0), length: 0 };
}

export const ScalarFixedSizeBinary: MessageFns<ScalarFixedSizeBinary> = {
  encode(message: ScalarFixedSizeBinary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.values.length !== 0) {
      writer.uint32(10).bytes(message.values);
    }
    if (message.length !== 0) {
      writer.uint32(16).int32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarFixedSizeBinary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarFixedSizeBinary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarFixedSizeBinary {
    return {
      values: isSet(object.values) ? bytesFromBase64(object.values) : new Uint8Array(0),
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: ScalarFixedSizeBinary): unknown {
    const obj: any = {};
    if (message.values.length !== 0) {
      obj.values = base64FromBytes(message.values);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarFixedSizeBinary>, I>>(base?: I): ScalarFixedSizeBinary {
    return ScalarFixedSizeBinary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarFixedSizeBinary>, I>>(object: I): ScalarFixedSizeBinary {
    const message = createBaseScalarFixedSizeBinary();
    message.values = object.values ?? new Uint8Array(0);
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseDecimalValue(): DecimalValue {
  return { value: new Uint8Array(0), precision: 0, scale: 0 };
}

export const DecimalValue: MessageFns<DecimalValue> = {
  encode(message: DecimalValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message.precision !== 0) {
      writer.uint32(16).int32(message.precision);
    }
    if (message.scale !== 0) {
      writer.uint32(24).int32(message.scale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecimalValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecimalValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.precision = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scale = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecimalValue {
    return {
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
    };
  },

  toJSON(message: DecimalValue): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecimalValue>, I>>(base?: I): DecimalValue {
    return DecimalValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecimalValue>, I>>(object: I): DecimalValue {
    const message = createBaseDecimalValue();
    message.value = object.value ?? new Uint8Array(0);
    message.precision = object.precision ?? 0;
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseExtension(): Extension {
  return { name: "", storageType: undefined };
}

export const Extension: MessageFns<Extension> = {
  encode(message: Extension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.storageType !== undefined) {
      ArrowType.encode(message.storageType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Extension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storageType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Extension {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      storageType: isSet(object.storageType) ? ArrowType.fromJSON(object.storageType) : undefined,
    };
  },

  toJSON(message: Extension): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.storageType !== undefined) {
      obj.storageType = ArrowType.toJSON(message.storageType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Extension>, I>>(base?: I): Extension {
    return Extension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Extension>, I>>(object: I): Extension {
    const message = createBaseExtension();
    message.name = object.name ?? "";
    message.storageType = (object.storageType !== undefined && object.storageType !== null)
      ? ArrowType.fromPartial(object.storageType)
      : undefined;
    return message;
  },
};

function createBaseExtensionValue(): ExtensionValue {
  return { extensionType: undefined, storageValue: undefined };
}

export const ExtensionValue: MessageFns<ExtensionValue> = {
  encode(message: ExtensionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.extensionType !== undefined) {
      Extension.encode(message.extensionType, writer.uint32(10).fork()).join();
    }
    if (message.storageValue !== undefined) {
      ScalarValue.encode(message.storageValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtensionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.extensionType = Extension.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storageValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtensionValue {
    return {
      extensionType: isSet(object.extensionType) ? Extension.fromJSON(object.extensionType) : undefined,
      storageValue: isSet(object.storageValue) ? ScalarValue.fromJSON(object.storageValue) : undefined,
    };
  },

  toJSON(message: ExtensionValue): unknown {
    const obj: any = {};
    if (message.extensionType !== undefined) {
      obj.extensionType = Extension.toJSON(message.extensionType);
    }
    if (message.storageValue !== undefined) {
      obj.storageValue = ScalarValue.toJSON(message.storageValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtensionValue>, I>>(base?: I): ExtensionValue {
    return ExtensionValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtensionValue>, I>>(object: I): ExtensionValue {
    const message = createBaseExtensionValue();
    message.extensionType = (object.extensionType !== undefined && object.extensionType !== null)
      ? Extension.fromPartial(object.extensionType)
      : undefined;
    message.storageValue = (object.storageValue !== undefined && object.storageValue !== null)
      ? ScalarValue.fromPartial(object.storageValue)
      : undefined;
    return message;
  },
};

function createBaseScalarValue(): ScalarValue {
  return {
    nullValue: undefined,
    boolValue: undefined,
    float64Value: undefined,
    int64Value: undefined,
    largeUtf8Value: undefined,
    timestampValue: undefined,
    date64Value: undefined,
    structValue: undefined,
    largeListValue: undefined,
    time64Value: undefined,
    durationSecondValue: undefined,
    durationMillisecondValue: undefined,
    durationMicrosecondValue: undefined,
    durationNanosecondValue: undefined,
    utf8Value: undefined,
    int8Value: undefined,
    int16Value: undefined,
    int32Value: undefined,
    uint8Value: undefined,
    uint16Value: undefined,
    uint32Value: undefined,
    uint64Value: undefined,
    float16Value: undefined,
    float32Value: undefined,
    date32Value: undefined,
    time32Value: undefined,
    listValue: undefined,
    fixedSizeListValue: undefined,
    mapValue: undefined,
    binaryValue: undefined,
    largeBinaryValue: undefined,
    fixedSizeBinaryValue: undefined,
    decimal128Value: undefined,
    decimal256Value: undefined,
    extensionValue: undefined,
  };
}

export const ScalarValue: MessageFns<ScalarValue> = {
  encode(message: ScalarValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nullValue !== undefined) {
      ArrowType.encode(message.nullValue, writer.uint32(10).fork()).join();
    }
    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue);
    }
    if (message.float64Value !== undefined) {
      writer.uint32(25).double(message.float64Value);
    }
    if (message.int64Value !== undefined) {
      writer.uint32(32).int64(message.int64Value);
    }
    if (message.largeUtf8Value !== undefined) {
      writer.uint32(42).string(message.largeUtf8Value);
    }
    if (message.timestampValue !== undefined) {
      ScalarTimestampValue.encode(message.timestampValue, writer.uint32(50).fork()).join();
    }
    if (message.date64Value !== undefined) {
      writer.uint32(56).int64(message.date64Value);
    }
    if (message.structValue !== undefined) {
      StructValue.encode(message.structValue, writer.uint32(66).fork()).join();
    }
    if (message.largeListValue !== undefined) {
      ScalarListValue.encode(message.largeListValue, writer.uint32(74).fork()).join();
    }
    if (message.time64Value !== undefined) {
      ScalarTime64Value.encode(message.time64Value, writer.uint32(82).fork()).join();
    }
    if (message.durationSecondValue !== undefined) {
      writer.uint32(128).int64(message.durationSecondValue);
    }
    if (message.durationMillisecondValue !== undefined) {
      writer.uint32(136).int64(message.durationMillisecondValue);
    }
    if (message.durationMicrosecondValue !== undefined) {
      writer.uint32(144).int64(message.durationMicrosecondValue);
    }
    if (message.durationNanosecondValue !== undefined) {
      writer.uint32(152).int64(message.durationNanosecondValue);
    }
    if (message.utf8Value !== undefined) {
      writer.uint32(162).string(message.utf8Value);
    }
    if (message.int8Value !== undefined) {
      writer.uint32(168).int32(message.int8Value);
    }
    if (message.int16Value !== undefined) {
      writer.uint32(176).int32(message.int16Value);
    }
    if (message.int32Value !== undefined) {
      writer.uint32(184).int32(message.int32Value);
    }
    if (message.uint8Value !== undefined) {
      writer.uint32(192).uint32(message.uint8Value);
    }
    if (message.uint16Value !== undefined) {
      writer.uint32(200).uint32(message.uint16Value);
    }
    if (message.uint32Value !== undefined) {
      writer.uint32(208).uint32(message.uint32Value);
    }
    if (message.uint64Value !== undefined) {
      writer.uint32(216).uint64(message.uint64Value);
    }
    if (message.float16Value !== undefined) {
      writer.uint32(229).float(message.float16Value);
    }
    if (message.float32Value !== undefined) {
      writer.uint32(237).float(message.float32Value);
    }
    if (message.date32Value !== undefined) {
      writer.uint32(240).int32(message.date32Value);
    }
    if (message.time32Value !== undefined) {
      ScalarTime32Value.encode(message.time32Value, writer.uint32(250).fork()).join();
    }
    if (message.listValue !== undefined) {
      ScalarListValue.encode(message.listValue, writer.uint32(258).fork()).join();
    }
    if (message.fixedSizeListValue !== undefined) {
      ScalarListValue.encode(message.fixedSizeListValue, writer.uint32(266).fork()).join();
    }
    if (message.mapValue !== undefined) {
      ScalarListValue.encode(message.mapValue, writer.uint32(274).fork()).join();
    }
    if (message.binaryValue !== undefined) {
      writer.uint32(282).bytes(message.binaryValue);
    }
    if (message.largeBinaryValue !== undefined) {
      writer.uint32(290).bytes(message.largeBinaryValue);
    }
    if (message.fixedSizeBinaryValue !== undefined) {
      ScalarFixedSizeBinary.encode(message.fixedSizeBinaryValue, writer.uint32(298).fork()).join();
    }
    if (message.decimal128Value !== undefined) {
      DecimalValue.encode(message.decimal128Value, writer.uint32(306).fork()).join();
    }
    if (message.decimal256Value !== undefined) {
      DecimalValue.encode(message.decimal256Value, writer.uint32(314).fork()).join();
    }
    if (message.extensionValue !== undefined) {
      ExtensionValue.encode(message.extensionValue, writer.uint32(322).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nullValue = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.float64Value = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.int64Value = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.largeUtf8Value = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestampValue = ScalarTimestampValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.date64Value = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.structValue = StructValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.largeListValue = ScalarListValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.time64Value = ScalarTime64Value.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.durationSecondValue = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.durationMillisecondValue = longToNumber(reader.int64());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.durationMicrosecondValue = longToNumber(reader.int64());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.durationNanosecondValue = longToNumber(reader.int64());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.utf8Value = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.int8Value = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.int16Value = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.int32Value = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.uint8Value = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.uint16Value = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.uint32Value = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.uint64Value = longToNumber(reader.uint64());
          continue;
        }
        case 28: {
          if (tag !== 229) {
            break;
          }

          message.float16Value = reader.float();
          continue;
        }
        case 29: {
          if (tag !== 237) {
            break;
          }

          message.float32Value = reader.float();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.date32Value = reader.int32();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.time32Value = ScalarTime32Value.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.listValue = ScalarListValue.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.fixedSizeListValue = ScalarListValue.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.mapValue = ScalarListValue.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.binaryValue = reader.bytes();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.largeBinaryValue = reader.bytes();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.fixedSizeBinaryValue = ScalarFixedSizeBinary.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.decimal128Value = DecimalValue.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.decimal256Value = DecimalValue.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.extensionValue = ExtensionValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarValue {
    return {
      nullValue: isSet(object.nullValue) ? ArrowType.fromJSON(object.nullValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      float64Value: isSet(object.float64Value) ? globalThis.Number(object.float64Value) : undefined,
      int64Value: isSet(object.int64Value) ? globalThis.Number(object.int64Value) : undefined,
      largeUtf8Value: isSet(object.largeUtf8Value) ? globalThis.String(object.largeUtf8Value) : undefined,
      timestampValue: isSet(object.timestampValue) ? ScalarTimestampValue.fromJSON(object.timestampValue) : undefined,
      date64Value: isSet(object.date64Value) ? globalThis.Number(object.date64Value) : undefined,
      structValue: isSet(object.structValue) ? StructValue.fromJSON(object.structValue) : undefined,
      largeListValue: isSet(object.largeListValue) ? ScalarListValue.fromJSON(object.largeListValue) : undefined,
      time64Value: isSet(object.time64Value) ? ScalarTime64Value.fromJSON(object.time64Value) : undefined,
      durationSecondValue: isSet(object.durationSecondValue)
        ? globalThis.Number(object.durationSecondValue)
        : undefined,
      durationMillisecondValue: isSet(object.durationMillisecondValue)
        ? globalThis.Number(object.durationMillisecondValue)
        : undefined,
      durationMicrosecondValue: isSet(object.durationMicrosecondValue)
        ? globalThis.Number(object.durationMicrosecondValue)
        : undefined,
      durationNanosecondValue: isSet(object.durationNanosecondValue)
        ? globalThis.Number(object.durationNanosecondValue)
        : undefined,
      utf8Value: isSet(object.utf8Value) ? globalThis.String(object.utf8Value) : undefined,
      int8Value: isSet(object.int8Value) ? globalThis.Number(object.int8Value) : undefined,
      int16Value: isSet(object.int16Value) ? globalThis.Number(object.int16Value) : undefined,
      int32Value: isSet(object.int32Value) ? globalThis.Number(object.int32Value) : undefined,
      uint8Value: isSet(object.uint8Value) ? globalThis.Number(object.uint8Value) : undefined,
      uint16Value: isSet(object.uint16Value) ? globalThis.Number(object.uint16Value) : undefined,
      uint32Value: isSet(object.uint32Value) ? globalThis.Number(object.uint32Value) : undefined,
      uint64Value: isSet(object.uint64Value) ? globalThis.Number(object.uint64Value) : undefined,
      float16Value: isSet(object.float16Value) ? globalThis.Number(object.float16Value) : undefined,
      float32Value: isSet(object.float32Value) ? globalThis.Number(object.float32Value) : undefined,
      date32Value: isSet(object.date32Value) ? globalThis.Number(object.date32Value) : undefined,
      time32Value: isSet(object.time32Value) ? ScalarTime32Value.fromJSON(object.time32Value) : undefined,
      listValue: isSet(object.listValue) ? ScalarListValue.fromJSON(object.listValue) : undefined,
      fixedSizeListValue: isSet(object.fixedSizeListValue)
        ? ScalarListValue.fromJSON(object.fixedSizeListValue)
        : undefined,
      mapValue: isSet(object.mapValue) ? ScalarListValue.fromJSON(object.mapValue) : undefined,
      binaryValue: isSet(object.binaryValue) ? bytesFromBase64(object.binaryValue) : undefined,
      largeBinaryValue: isSet(object.largeBinaryValue) ? bytesFromBase64(object.largeBinaryValue) : undefined,
      fixedSizeBinaryValue: isSet(object.fixedSizeBinaryValue)
        ? ScalarFixedSizeBinary.fromJSON(object.fixedSizeBinaryValue)
        : undefined,
      decimal128Value: isSet(object.decimal128Value) ? DecimalValue.fromJSON(object.decimal128Value) : undefined,
      decimal256Value: isSet(object.decimal256Value) ? DecimalValue.fromJSON(object.decimal256Value) : undefined,
      extensionValue: isSet(object.extensionValue) ? ExtensionValue.fromJSON(object.extensionValue) : undefined,
    };
  },

  toJSON(message: ScalarValue): unknown {
    const obj: any = {};
    if (message.nullValue !== undefined) {
      obj.nullValue = ArrowType.toJSON(message.nullValue);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.float64Value !== undefined) {
      obj.float64Value = message.float64Value;
    }
    if (message.int64Value !== undefined) {
      obj.int64Value = Math.round(message.int64Value);
    }
    if (message.largeUtf8Value !== undefined) {
      obj.largeUtf8Value = message.largeUtf8Value;
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = ScalarTimestampValue.toJSON(message.timestampValue);
    }
    if (message.date64Value !== undefined) {
      obj.date64Value = Math.round(message.date64Value);
    }
    if (message.structValue !== undefined) {
      obj.structValue = StructValue.toJSON(message.structValue);
    }
    if (message.largeListValue !== undefined) {
      obj.largeListValue = ScalarListValue.toJSON(message.largeListValue);
    }
    if (message.time64Value !== undefined) {
      obj.time64Value = ScalarTime64Value.toJSON(message.time64Value);
    }
    if (message.durationSecondValue !== undefined) {
      obj.durationSecondValue = Math.round(message.durationSecondValue);
    }
    if (message.durationMillisecondValue !== undefined) {
      obj.durationMillisecondValue = Math.round(message.durationMillisecondValue);
    }
    if (message.durationMicrosecondValue !== undefined) {
      obj.durationMicrosecondValue = Math.round(message.durationMicrosecondValue);
    }
    if (message.durationNanosecondValue !== undefined) {
      obj.durationNanosecondValue = Math.round(message.durationNanosecondValue);
    }
    if (message.utf8Value !== undefined) {
      obj.utf8Value = message.utf8Value;
    }
    if (message.int8Value !== undefined) {
      obj.int8Value = Math.round(message.int8Value);
    }
    if (message.int16Value !== undefined) {
      obj.int16Value = Math.round(message.int16Value);
    }
    if (message.int32Value !== undefined) {
      obj.int32Value = Math.round(message.int32Value);
    }
    if (message.uint8Value !== undefined) {
      obj.uint8Value = Math.round(message.uint8Value);
    }
    if (message.uint16Value !== undefined) {
      obj.uint16Value = Math.round(message.uint16Value);
    }
    if (message.uint32Value !== undefined) {
      obj.uint32Value = Math.round(message.uint32Value);
    }
    if (message.uint64Value !== undefined) {
      obj.uint64Value = Math.round(message.uint64Value);
    }
    if (message.float16Value !== undefined) {
      obj.float16Value = message.float16Value;
    }
    if (message.float32Value !== undefined) {
      obj.float32Value = message.float32Value;
    }
    if (message.date32Value !== undefined) {
      obj.date32Value = Math.round(message.date32Value);
    }
    if (message.time32Value !== undefined) {
      obj.time32Value = ScalarTime32Value.toJSON(message.time32Value);
    }
    if (message.listValue !== undefined) {
      obj.listValue = ScalarListValue.toJSON(message.listValue);
    }
    if (message.fixedSizeListValue !== undefined) {
      obj.fixedSizeListValue = ScalarListValue.toJSON(message.fixedSizeListValue);
    }
    if (message.mapValue !== undefined) {
      obj.mapValue = ScalarListValue.toJSON(message.mapValue);
    }
    if (message.binaryValue !== undefined) {
      obj.binaryValue = base64FromBytes(message.binaryValue);
    }
    if (message.largeBinaryValue !== undefined) {
      obj.largeBinaryValue = base64FromBytes(message.largeBinaryValue);
    }
    if (message.fixedSizeBinaryValue !== undefined) {
      obj.fixedSizeBinaryValue = ScalarFixedSizeBinary.toJSON(message.fixedSizeBinaryValue);
    }
    if (message.decimal128Value !== undefined) {
      obj.decimal128Value = DecimalValue.toJSON(message.decimal128Value);
    }
    if (message.decimal256Value !== undefined) {
      obj.decimal256Value = DecimalValue.toJSON(message.decimal256Value);
    }
    if (message.extensionValue !== undefined) {
      obj.extensionValue = ExtensionValue.toJSON(message.extensionValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarValue>, I>>(base?: I): ScalarValue {
    return ScalarValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarValue>, I>>(object: I): ScalarValue {
    const message = createBaseScalarValue();
    message.nullValue = (object.nullValue !== undefined && object.nullValue !== null)
      ? ArrowType.fromPartial(object.nullValue)
      : undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.float64Value = object.float64Value ?? undefined;
    message.int64Value = object.int64Value ?? undefined;
    message.largeUtf8Value = object.largeUtf8Value ?? undefined;
    message.timestampValue = (object.timestampValue !== undefined && object.timestampValue !== null)
      ? ScalarTimestampValue.fromPartial(object.timestampValue)
      : undefined;
    message.date64Value = object.date64Value ?? undefined;
    message.structValue = (object.structValue !== undefined && object.structValue !== null)
      ? StructValue.fromPartial(object.structValue)
      : undefined;
    message.largeListValue = (object.largeListValue !== undefined && object.largeListValue !== null)
      ? ScalarListValue.fromPartial(object.largeListValue)
      : undefined;
    message.time64Value = (object.time64Value !== undefined && object.time64Value !== null)
      ? ScalarTime64Value.fromPartial(object.time64Value)
      : undefined;
    message.durationSecondValue = object.durationSecondValue ?? undefined;
    message.durationMillisecondValue = object.durationMillisecondValue ?? undefined;
    message.durationMicrosecondValue = object.durationMicrosecondValue ?? undefined;
    message.durationNanosecondValue = object.durationNanosecondValue ?? undefined;
    message.utf8Value = object.utf8Value ?? undefined;
    message.int8Value = object.int8Value ?? undefined;
    message.int16Value = object.int16Value ?? undefined;
    message.int32Value = object.int32Value ?? undefined;
    message.uint8Value = object.uint8Value ?? undefined;
    message.uint16Value = object.uint16Value ?? undefined;
    message.uint32Value = object.uint32Value ?? undefined;
    message.uint64Value = object.uint64Value ?? undefined;
    message.float16Value = object.float16Value ?? undefined;
    message.float32Value = object.float32Value ?? undefined;
    message.date32Value = object.date32Value ?? undefined;
    message.time32Value = (object.time32Value !== undefined && object.time32Value !== null)
      ? ScalarTime32Value.fromPartial(object.time32Value)
      : undefined;
    message.listValue = (object.listValue !== undefined && object.listValue !== null)
      ? ScalarListValue.fromPartial(object.listValue)
      : undefined;
    message.fixedSizeListValue = (object.fixedSizeListValue !== undefined && object.fixedSizeListValue !== null)
      ? ScalarListValue.fromPartial(object.fixedSizeListValue)
      : undefined;
    message.mapValue = (object.mapValue !== undefined && object.mapValue !== null)
      ? ScalarListValue.fromPartial(object.mapValue)
      : undefined;
    message.binaryValue = object.binaryValue ?? undefined;
    message.largeBinaryValue = object.largeBinaryValue ?? undefined;
    message.fixedSizeBinaryValue = (object.fixedSizeBinaryValue !== undefined && object.fixedSizeBinaryValue !== null)
      ? ScalarFixedSizeBinary.fromPartial(object.fixedSizeBinaryValue)
      : undefined;
    message.decimal128Value = (object.decimal128Value !== undefined && object.decimal128Value !== null)
      ? DecimalValue.fromPartial(object.decimal128Value)
      : undefined;
    message.decimal256Value = (object.decimal256Value !== undefined && object.decimal256Value !== null)
      ? DecimalValue.fromPartial(object.decimal256Value)
      : undefined;
    message.extensionValue = (object.extensionValue !== undefined && object.extensionValue !== null)
      ? ExtensionValue.fromPartial(object.extensionValue)
      : undefined;
    return message;
  },
};

function createBaseArrowType(): ArrowType {
  return {
    none: undefined,
    bool: undefined,
    float64: undefined,
    int64: undefined,
    largeUtf8: undefined,
    timestamp: undefined,
    date64: undefined,
    struct: undefined,
    largeList: undefined,
    time64: undefined,
    duration: undefined,
    utf8: undefined,
    int8: undefined,
    int16: undefined,
    int32: undefined,
    uint8: undefined,
    uint16: undefined,
    uint32: undefined,
    uint64: undefined,
    float16: undefined,
    float32: undefined,
    date32: undefined,
    time32: undefined,
    list: undefined,
    fixedSizeList: undefined,
    binary: undefined,
    largeBinary: undefined,
    fixedSizeBinary: undefined,
    decimal128: undefined,
    decimal256: undefined,
    map: undefined,
    extension: undefined,
  };
}

export const ArrowType: MessageFns<ArrowType> = {
  encode(message: ArrowType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.none !== undefined) {
      EmptyMessage.encode(message.none, writer.uint32(10).fork()).join();
    }
    if (message.bool !== undefined) {
      EmptyMessage.encode(message.bool, writer.uint32(18).fork()).join();
    }
    if (message.float64 !== undefined) {
      EmptyMessage.encode(message.float64, writer.uint32(26).fork()).join();
    }
    if (message.int64 !== undefined) {
      EmptyMessage.encode(message.int64, writer.uint32(34).fork()).join();
    }
    if (message.largeUtf8 !== undefined) {
      EmptyMessage.encode(message.largeUtf8, writer.uint32(42).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(message.timestamp, writer.uint32(50).fork()).join();
    }
    if (message.date64 !== undefined) {
      EmptyMessage.encode(message.date64, writer.uint32(58).fork()).join();
    }
    if (message.struct !== undefined) {
      Struct.encode(message.struct, writer.uint32(66).fork()).join();
    }
    if (message.largeList !== undefined) {
      List.encode(message.largeList, writer.uint32(74).fork()).join();
    }
    if (message.time64 !== undefined) {
      writer.uint32(80).int32(message.time64);
    }
    if (message.duration !== undefined) {
      writer.uint32(128).int32(message.duration);
    }
    if (message.utf8 !== undefined) {
      EmptyMessage.encode(message.utf8, writer.uint32(138).fork()).join();
    }
    if (message.int8 !== undefined) {
      EmptyMessage.encode(message.int8, writer.uint32(146).fork()).join();
    }
    if (message.int16 !== undefined) {
      EmptyMessage.encode(message.int16, writer.uint32(154).fork()).join();
    }
    if (message.int32 !== undefined) {
      EmptyMessage.encode(message.int32, writer.uint32(162).fork()).join();
    }
    if (message.uint8 !== undefined) {
      EmptyMessage.encode(message.uint8, writer.uint32(170).fork()).join();
    }
    if (message.uint16 !== undefined) {
      EmptyMessage.encode(message.uint16, writer.uint32(178).fork()).join();
    }
    if (message.uint32 !== undefined) {
      EmptyMessage.encode(message.uint32, writer.uint32(186).fork()).join();
    }
    if (message.uint64 !== undefined) {
      EmptyMessage.encode(message.uint64, writer.uint32(194).fork()).join();
    }
    if (message.float16 !== undefined) {
      EmptyMessage.encode(message.float16, writer.uint32(202).fork()).join();
    }
    if (message.float32 !== undefined) {
      EmptyMessage.encode(message.float32, writer.uint32(210).fork()).join();
    }
    if (message.date32 !== undefined) {
      EmptyMessage.encode(message.date32, writer.uint32(218).fork()).join();
    }
    if (message.time32 !== undefined) {
      writer.uint32(224).int32(message.time32);
    }
    if (message.list !== undefined) {
      List.encode(message.list, writer.uint32(234).fork()).join();
    }
    if (message.fixedSizeList !== undefined) {
      FixedSizeList.encode(message.fixedSizeList, writer.uint32(242).fork()).join();
    }
    if (message.binary !== undefined) {
      EmptyMessage.encode(message.binary, writer.uint32(250).fork()).join();
    }
    if (message.largeBinary !== undefined) {
      EmptyMessage.encode(message.largeBinary, writer.uint32(258).fork()).join();
    }
    if (message.fixedSizeBinary !== undefined) {
      writer.uint32(264).int32(message.fixedSizeBinary);
    }
    if (message.decimal128 !== undefined) {
      Decimal.encode(message.decimal128, writer.uint32(274).fork()).join();
    }
    if (message.decimal256 !== undefined) {
      Decimal.encode(message.decimal256, writer.uint32(282).fork()).join();
    }
    if (message.map !== undefined) {
      Map.encode(message.map, writer.uint32(290).fork()).join();
    }
    if (message.extension !== undefined) {
      Extension.encode(message.extension, writer.uint32(298).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArrowType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArrowType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.none = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bool = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.float64 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.int64 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.largeUtf8 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.date64 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.struct = Struct.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.largeList = List.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.time64 = reader.int32() as any;
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.duration = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.utf8 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.int8 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.int16 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.int32 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.uint8 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.uint16 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.uint32 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.uint64 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.float16 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.float32 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.date32 = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.time32 = reader.int32() as any;
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.list = List.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.fixedSizeList = FixedSizeList.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.binary = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.largeBinary = EmptyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.fixedSizeBinary = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.decimal128 = Decimal.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.decimal256 = Decimal.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.map = Map.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.extension = Extension.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArrowType {
    return {
      none: isSet(object.none) ? EmptyMessage.fromJSON(object.none) : undefined,
      bool: isSet(object.bool) ? EmptyMessage.fromJSON(object.bool) : undefined,
      float64: isSet(object.float64) ? EmptyMessage.fromJSON(object.float64) : undefined,
      int64: isSet(object.int64) ? EmptyMessage.fromJSON(object.int64) : undefined,
      largeUtf8: isSet(object.largeUtf8) ? EmptyMessage.fromJSON(object.largeUtf8) : undefined,
      timestamp: isSet(object.timestamp) ? Timestamp.fromJSON(object.timestamp) : undefined,
      date64: isSet(object.date64) ? EmptyMessage.fromJSON(object.date64) : undefined,
      struct: isSet(object.struct) ? Struct.fromJSON(object.struct) : undefined,
      largeList: isSet(object.largeList) ? List.fromJSON(object.largeList) : undefined,
      time64: isSet(object.time64) ? timeUnitFromJSON(object.time64) : undefined,
      duration: isSet(object.duration) ? timeUnitFromJSON(object.duration) : undefined,
      utf8: isSet(object.utf8) ? EmptyMessage.fromJSON(object.utf8) : undefined,
      int8: isSet(object.int8) ? EmptyMessage.fromJSON(object.int8) : undefined,
      int16: isSet(object.int16) ? EmptyMessage.fromJSON(object.int16) : undefined,
      int32: isSet(object.int32) ? EmptyMessage.fromJSON(object.int32) : undefined,
      uint8: isSet(object.uint8) ? EmptyMessage.fromJSON(object.uint8) : undefined,
      uint16: isSet(object.uint16) ? EmptyMessage.fromJSON(object.uint16) : undefined,
      uint32: isSet(object.uint32) ? EmptyMessage.fromJSON(object.uint32) : undefined,
      uint64: isSet(object.uint64) ? EmptyMessage.fromJSON(object.uint64) : undefined,
      float16: isSet(object.float16) ? EmptyMessage.fromJSON(object.float16) : undefined,
      float32: isSet(object.float32) ? EmptyMessage.fromJSON(object.float32) : undefined,
      date32: isSet(object.date32) ? EmptyMessage.fromJSON(object.date32) : undefined,
      time32: isSet(object.time32) ? timeUnitFromJSON(object.time32) : undefined,
      list: isSet(object.list) ? List.fromJSON(object.list) : undefined,
      fixedSizeList: isSet(object.fixedSizeList) ? FixedSizeList.fromJSON(object.fixedSizeList) : undefined,
      binary: isSet(object.binary) ? EmptyMessage.fromJSON(object.binary) : undefined,
      largeBinary: isSet(object.largeBinary) ? EmptyMessage.fromJSON(object.largeBinary) : undefined,
      fixedSizeBinary: isSet(object.fixedSizeBinary) ? globalThis.Number(object.fixedSizeBinary) : undefined,
      decimal128: isSet(object.decimal128) ? Decimal.fromJSON(object.decimal128) : undefined,
      decimal256: isSet(object.decimal256) ? Decimal.fromJSON(object.decimal256) : undefined,
      map: isSet(object.map) ? Map.fromJSON(object.map) : undefined,
      extension: isSet(object.extension) ? Extension.fromJSON(object.extension) : undefined,
    };
  },

  toJSON(message: ArrowType): unknown {
    const obj: any = {};
    if (message.none !== undefined) {
      obj.none = EmptyMessage.toJSON(message.none);
    }
    if (message.bool !== undefined) {
      obj.bool = EmptyMessage.toJSON(message.bool);
    }
    if (message.float64 !== undefined) {
      obj.float64 = EmptyMessage.toJSON(message.float64);
    }
    if (message.int64 !== undefined) {
      obj.int64 = EmptyMessage.toJSON(message.int64);
    }
    if (message.largeUtf8 !== undefined) {
      obj.largeUtf8 = EmptyMessage.toJSON(message.largeUtf8);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = Timestamp.toJSON(message.timestamp);
    }
    if (message.date64 !== undefined) {
      obj.date64 = EmptyMessage.toJSON(message.date64);
    }
    if (message.struct !== undefined) {
      obj.struct = Struct.toJSON(message.struct);
    }
    if (message.largeList !== undefined) {
      obj.largeList = List.toJSON(message.largeList);
    }
    if (message.time64 !== undefined) {
      obj.time64 = timeUnitToJSON(message.time64);
    }
    if (message.duration !== undefined) {
      obj.duration = timeUnitToJSON(message.duration);
    }
    if (message.utf8 !== undefined) {
      obj.utf8 = EmptyMessage.toJSON(message.utf8);
    }
    if (message.int8 !== undefined) {
      obj.int8 = EmptyMessage.toJSON(message.int8);
    }
    if (message.int16 !== undefined) {
      obj.int16 = EmptyMessage.toJSON(message.int16);
    }
    if (message.int32 !== undefined) {
      obj.int32 = EmptyMessage.toJSON(message.int32);
    }
    if (message.uint8 !== undefined) {
      obj.uint8 = EmptyMessage.toJSON(message.uint8);
    }
    if (message.uint16 !== undefined) {
      obj.uint16 = EmptyMessage.toJSON(message.uint16);
    }
    if (message.uint32 !== undefined) {
      obj.uint32 = EmptyMessage.toJSON(message.uint32);
    }
    if (message.uint64 !== undefined) {
      obj.uint64 = EmptyMessage.toJSON(message.uint64);
    }
    if (message.float16 !== undefined) {
      obj.float16 = EmptyMessage.toJSON(message.float16);
    }
    if (message.float32 !== undefined) {
      obj.float32 = EmptyMessage.toJSON(message.float32);
    }
    if (message.date32 !== undefined) {
      obj.date32 = EmptyMessage.toJSON(message.date32);
    }
    if (message.time32 !== undefined) {
      obj.time32 = timeUnitToJSON(message.time32);
    }
    if (message.list !== undefined) {
      obj.list = List.toJSON(message.list);
    }
    if (message.fixedSizeList !== undefined) {
      obj.fixedSizeList = FixedSizeList.toJSON(message.fixedSizeList);
    }
    if (message.binary !== undefined) {
      obj.binary = EmptyMessage.toJSON(message.binary);
    }
    if (message.largeBinary !== undefined) {
      obj.largeBinary = EmptyMessage.toJSON(message.largeBinary);
    }
    if (message.fixedSizeBinary !== undefined) {
      obj.fixedSizeBinary = Math.round(message.fixedSizeBinary);
    }
    if (message.decimal128 !== undefined) {
      obj.decimal128 = Decimal.toJSON(message.decimal128);
    }
    if (message.decimal256 !== undefined) {
      obj.decimal256 = Decimal.toJSON(message.decimal256);
    }
    if (message.map !== undefined) {
      obj.map = Map.toJSON(message.map);
    }
    if (message.extension !== undefined) {
      obj.extension = Extension.toJSON(message.extension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArrowType>, I>>(base?: I): ArrowType {
    return ArrowType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArrowType>, I>>(object: I): ArrowType {
    const message = createBaseArrowType();
    message.none = (object.none !== undefined && object.none !== null)
      ? EmptyMessage.fromPartial(object.none)
      : undefined;
    message.bool = (object.bool !== undefined && object.bool !== null)
      ? EmptyMessage.fromPartial(object.bool)
      : undefined;
    message.float64 = (object.float64 !== undefined && object.float64 !== null)
      ? EmptyMessage.fromPartial(object.float64)
      : undefined;
    message.int64 = (object.int64 !== undefined && object.int64 !== null)
      ? EmptyMessage.fromPartial(object.int64)
      : undefined;
    message.largeUtf8 = (object.largeUtf8 !== undefined && object.largeUtf8 !== null)
      ? EmptyMessage.fromPartial(object.largeUtf8)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Timestamp.fromPartial(object.timestamp)
      : undefined;
    message.date64 = (object.date64 !== undefined && object.date64 !== null)
      ? EmptyMessage.fromPartial(object.date64)
      : undefined;
    message.struct = (object.struct !== undefined && object.struct !== null)
      ? Struct.fromPartial(object.struct)
      : undefined;
    message.largeList = (object.largeList !== undefined && object.largeList !== null)
      ? List.fromPartial(object.largeList)
      : undefined;
    message.time64 = object.time64 ?? undefined;
    message.duration = object.duration ?? undefined;
    message.utf8 = (object.utf8 !== undefined && object.utf8 !== null)
      ? EmptyMessage.fromPartial(object.utf8)
      : undefined;
    message.int8 = (object.int8 !== undefined && object.int8 !== null)
      ? EmptyMessage.fromPartial(object.int8)
      : undefined;
    message.int16 = (object.int16 !== undefined && object.int16 !== null)
      ? EmptyMessage.fromPartial(object.int16)
      : undefined;
    message.int32 = (object.int32 !== undefined && object.int32 !== null)
      ? EmptyMessage.fromPartial(object.int32)
      : undefined;
    message.uint8 = (object.uint8 !== undefined && object.uint8 !== null)
      ? EmptyMessage.fromPartial(object.uint8)
      : undefined;
    message.uint16 = (object.uint16 !== undefined && object.uint16 !== null)
      ? EmptyMessage.fromPartial(object.uint16)
      : undefined;
    message.uint32 = (object.uint32 !== undefined && object.uint32 !== null)
      ? EmptyMessage.fromPartial(object.uint32)
      : undefined;
    message.uint64 = (object.uint64 !== undefined && object.uint64 !== null)
      ? EmptyMessage.fromPartial(object.uint64)
      : undefined;
    message.float16 = (object.float16 !== undefined && object.float16 !== null)
      ? EmptyMessage.fromPartial(object.float16)
      : undefined;
    message.float32 = (object.float32 !== undefined && object.float32 !== null)
      ? EmptyMessage.fromPartial(object.float32)
      : undefined;
    message.date32 = (object.date32 !== undefined && object.date32 !== null)
      ? EmptyMessage.fromPartial(object.date32)
      : undefined;
    message.time32 = object.time32 ?? undefined;
    message.list = (object.list !== undefined && object.list !== null) ? List.fromPartial(object.list) : undefined;
    message.fixedSizeList = (object.fixedSizeList !== undefined && object.fixedSizeList !== null)
      ? FixedSizeList.fromPartial(object.fixedSizeList)
      : undefined;
    message.binary = (object.binary !== undefined && object.binary !== null)
      ? EmptyMessage.fromPartial(object.binary)
      : undefined;
    message.largeBinary = (object.largeBinary !== undefined && object.largeBinary !== null)
      ? EmptyMessage.fromPartial(object.largeBinary)
      : undefined;
    message.fixedSizeBinary = object.fixedSizeBinary ?? undefined;
    message.decimal128 = (object.decimal128 !== undefined && object.decimal128 !== null)
      ? Decimal.fromPartial(object.decimal128)
      : undefined;
    message.decimal256 = (object.decimal256 !== undefined && object.decimal256 !== null)
      ? Decimal.fromPartial(object.decimal256)
      : undefined;
    message.map = (object.map !== undefined && object.map !== null) ? Map.fromPartial(object.map) : undefined;
    message.extension = (object.extension !== undefined && object.extension !== null)
      ? Extension.fromPartial(object.extension)
      : undefined;
    return message;
  },
};

function createBaseEmptyMessage(): EmptyMessage {
  return {};
}

export const EmptyMessage: MessageFns<EmptyMessage> = {
  encode(_: EmptyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EmptyMessage {
    return {};
  },

  toJSON(_: EmptyMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyMessage>, I>>(base?: I): EmptyMessage {
    return EmptyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyMessage>, I>>(_: I): EmptyMessage {
    const message = createBaseEmptyMessage();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
