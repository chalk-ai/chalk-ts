// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/graph/v1/graph.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { ArrowType, ScalarValue } from "../../arrow/v1/arrow";
import { LogicalExprNode } from "../../expression/v1/expression";
import { Range } from "../../lsp/v1/lsp";
import {
  DatabaseSource as DatabaseSource1,
  DatabaseSourceGroup,
  DatabaseSourceReference as DatabaseSourceReference3,
  StreamSource as StreamSource2,
  StreamSourceReference as StreamSourceReference4,
} from "../v2/sources";
import { DatabaseSource, DatabaseSourceReference, StreamSource, StreamSourceReference } from "./sources";

export const protobufPackage = "chalk.graph.v1";

export enum CacheStrategy {
  CACHE_STRATEGY_UNSPECIFIED = 0,
  CACHE_STRATEGY_ALL = 1,
  CACHE_STRATEGY_NO_NULLS = 2,
  CACHE_STRATEGY_EVICT_NULLS = 3,
  CACHE_STRATEGY_NO_DEFAULTS = 4,
  CACHE_STRATEGY_EVICT_DEFAULTS = 5,
  CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS = 6,
  CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS = 7,
  UNRECOGNIZED = -1,
}

export function cacheStrategyFromJSON(object: any): CacheStrategy {
  switch (object) {
    case 0:
    case "CACHE_STRATEGY_UNSPECIFIED":
      return CacheStrategy.CACHE_STRATEGY_UNSPECIFIED;
    case 1:
    case "CACHE_STRATEGY_ALL":
      return CacheStrategy.CACHE_STRATEGY_ALL;
    case 2:
    case "CACHE_STRATEGY_NO_NULLS":
      return CacheStrategy.CACHE_STRATEGY_NO_NULLS;
    case 3:
    case "CACHE_STRATEGY_EVICT_NULLS":
      return CacheStrategy.CACHE_STRATEGY_EVICT_NULLS;
    case 4:
    case "CACHE_STRATEGY_NO_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_NO_DEFAULTS;
    case 5:
    case "CACHE_STRATEGY_EVICT_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_EVICT_DEFAULTS;
    case 6:
    case "CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS;
    case 7:
    case "CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CacheStrategy.UNRECOGNIZED;
  }
}

export function cacheStrategyToJSON(object: CacheStrategy): string {
  switch (object) {
    case CacheStrategy.CACHE_STRATEGY_UNSPECIFIED:
      return "CACHE_STRATEGY_UNSPECIFIED";
    case CacheStrategy.CACHE_STRATEGY_ALL:
      return "CACHE_STRATEGY_ALL";
    case CacheStrategy.CACHE_STRATEGY_NO_NULLS:
      return "CACHE_STRATEGY_NO_NULLS";
    case CacheStrategy.CACHE_STRATEGY_EVICT_NULLS:
      return "CACHE_STRATEGY_EVICT_NULLS";
    case CacheStrategy.CACHE_STRATEGY_NO_DEFAULTS:
      return "CACHE_STRATEGY_NO_DEFAULTS";
    case CacheStrategy.CACHE_STRATEGY_EVICT_DEFAULTS:
      return "CACHE_STRATEGY_EVICT_DEFAULTS";
    case CacheStrategy.CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS:
      return "CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS";
    case CacheStrategy.CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS:
      return "CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS";
    case CacheStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResolverKind {
  RESOLVER_KIND_UNSPECIFIED = 0,
  RESOLVER_KIND_ONLINE = 1,
  RESOLVER_KIND_OFFLINE = 2,
  UNRECOGNIZED = -1,
}

export function resolverKindFromJSON(object: any): ResolverKind {
  switch (object) {
    case 0:
    case "RESOLVER_KIND_UNSPECIFIED":
      return ResolverKind.RESOLVER_KIND_UNSPECIFIED;
    case 1:
    case "RESOLVER_KIND_ONLINE":
      return ResolverKind.RESOLVER_KIND_ONLINE;
    case 2:
    case "RESOLVER_KIND_OFFLINE":
      return ResolverKind.RESOLVER_KIND_OFFLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResolverKind.UNRECOGNIZED;
  }
}

export function resolverKindToJSON(object: ResolverKind): string {
  switch (object) {
    case ResolverKind.RESOLVER_KIND_UNSPECIFIED:
      return "RESOLVER_KIND_UNSPECIFIED";
    case ResolverKind.RESOLVER_KIND_ONLINE:
      return "RESOLVER_KIND_ONLINE";
    case ResolverKind.RESOLVER_KIND_OFFLINE:
      return "RESOLVER_KIND_OFFLINE";
    case ResolverKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResourceHint {
  RESOURCE_HINT_UNSPECIFIED = 0,
  RESOURCE_HINT_CPU = 1,
  RESOURCE_HINT_IO = 2,
  UNRECOGNIZED = -1,
}

export function resourceHintFromJSON(object: any): ResourceHint {
  switch (object) {
    case 0:
    case "RESOURCE_HINT_UNSPECIFIED":
      return ResourceHint.RESOURCE_HINT_UNSPECIFIED;
    case 1:
    case "RESOURCE_HINT_CPU":
      return ResourceHint.RESOURCE_HINT_CPU;
    case 2:
    case "RESOURCE_HINT_IO":
      return ResourceHint.RESOURCE_HINT_IO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResourceHint.UNRECOGNIZED;
  }
}

export function resourceHintToJSON(object: ResourceHint): string {
  switch (object) {
    case ResourceHint.RESOURCE_HINT_UNSPECIFIED:
      return "RESOURCE_HINT_UNSPECIFIED";
    case ResourceHint.RESOURCE_HINT_CPU:
      return "RESOURCE_HINT_CPU";
    case ResourceHint.RESOURCE_HINT_IO:
      return "RESOURCE_HINT_IO";
    case ResourceHint.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Finalizer {
  FINALIZER_UNSPECIFIED = 0,
  FINALIZER_ONE_OR_NONE = 1,
  FINALIZER_ONE = 2,
  FINALIZER_FIRST = 3,
  FINALIZER_ALL = 4,
  UNRECOGNIZED = -1,
}

export function finalizerFromJSON(object: any): Finalizer {
  switch (object) {
    case 0:
    case "FINALIZER_UNSPECIFIED":
      return Finalizer.FINALIZER_UNSPECIFIED;
    case 1:
    case "FINALIZER_ONE_OR_NONE":
      return Finalizer.FINALIZER_ONE_OR_NONE;
    case 2:
    case "FINALIZER_ONE":
      return Finalizer.FINALIZER_ONE;
    case 3:
    case "FINALIZER_FIRST":
      return Finalizer.FINALIZER_FIRST;
    case 4:
    case "FINALIZER_ALL":
      return Finalizer.FINALIZER_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Finalizer.UNRECOGNIZED;
  }
}

export function finalizerToJSON(object: Finalizer): string {
  switch (object) {
    case Finalizer.FINALIZER_UNSPECIFIED:
      return "FINALIZER_UNSPECIFIED";
    case Finalizer.FINALIZER_ONE_OR_NONE:
      return "FINALIZER_ONE_OR_NONE";
    case Finalizer.FINALIZER_ONE:
      return "FINALIZER_ONE";
    case Finalizer.FINALIZER_FIRST:
      return "FINALIZER_FIRST";
    case Finalizer.FINALIZER_ALL:
      return "FINALIZER_ALL";
    case Finalizer.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncrementalMode {
  INCREMENTAL_MODE_UNSPECIFIED = 0,
  INCREMENTAL_MODE_ROW = 1,
  INCREMENTAL_MODE_GROUP = 2,
  INCREMENTAL_MODE_PARAMETER = 3,
  UNRECOGNIZED = -1,
}

export function incrementalModeFromJSON(object: any): IncrementalMode {
  switch (object) {
    case 0:
    case "INCREMENTAL_MODE_UNSPECIFIED":
      return IncrementalMode.INCREMENTAL_MODE_UNSPECIFIED;
    case 1:
    case "INCREMENTAL_MODE_ROW":
      return IncrementalMode.INCREMENTAL_MODE_ROW;
    case 2:
    case "INCREMENTAL_MODE_GROUP":
      return IncrementalMode.INCREMENTAL_MODE_GROUP;
    case 3:
    case "INCREMENTAL_MODE_PARAMETER":
      return IncrementalMode.INCREMENTAL_MODE_PARAMETER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncrementalMode.UNRECOGNIZED;
  }
}

export function incrementalModeToJSON(object: IncrementalMode): string {
  switch (object) {
    case IncrementalMode.INCREMENTAL_MODE_UNSPECIFIED:
      return "INCREMENTAL_MODE_UNSPECIFIED";
    case IncrementalMode.INCREMENTAL_MODE_ROW:
      return "INCREMENTAL_MODE_ROW";
    case IncrementalMode.INCREMENTAL_MODE_GROUP:
      return "INCREMENTAL_MODE_GROUP";
    case IncrementalMode.INCREMENTAL_MODE_PARAMETER:
      return "INCREMENTAL_MODE_PARAMETER";
    case IncrementalMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncrementalTimestampMode {
  INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED = 0,
  INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME = 1,
  INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME = 2,
  UNRECOGNIZED = -1,
}

export function incrementalTimestampModeFromJSON(object: any): IncrementalTimestampMode {
  switch (object) {
    case 0:
    case "INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED":
      return IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED;
    case 1:
    case "INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME":
      return IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME;
    case 2:
    case "INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME":
      return IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncrementalTimestampMode.UNRECOGNIZED;
  }
}

export function incrementalTimestampModeToJSON(object: IncrementalTimestampMode): string {
  switch (object) {
    case IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED:
      return "INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED";
    case IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME:
      return "INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME";
    case IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME:
      return "INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME";
    case IncrementalTimestampMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WindowMode {
  WINDOW_MODE_UNSPECIFIED = 0,
  WINDOW_MODE_CONTINUOUS = 1,
  WINDOW_MODE_TUMBLING = 2,
  WINDOW_MODE_CDC = 3,
  UNRECOGNIZED = -1,
}

export function windowModeFromJSON(object: any): WindowMode {
  switch (object) {
    case 0:
    case "WINDOW_MODE_UNSPECIFIED":
      return WindowMode.WINDOW_MODE_UNSPECIFIED;
    case 1:
    case "WINDOW_MODE_CONTINUOUS":
      return WindowMode.WINDOW_MODE_CONTINUOUS;
    case 2:
    case "WINDOW_MODE_TUMBLING":
      return WindowMode.WINDOW_MODE_TUMBLING;
    case 3:
    case "WINDOW_MODE_CDC":
      return WindowMode.WINDOW_MODE_CDC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowMode.UNRECOGNIZED;
  }
}

export function windowModeToJSON(object: WindowMode): string {
  switch (object) {
    case WindowMode.WINDOW_MODE_UNSPECIFIED:
      return "WINDOW_MODE_UNSPECIFIED";
    case WindowMode.WINDOW_MODE_CONTINUOUS:
      return "WINDOW_MODE_CONTINUOUS";
    case WindowMode.WINDOW_MODE_TUMBLING:
      return "WINDOW_MODE_TUMBLING";
    case WindowMode.WINDOW_MODE_CDC:
      return "WINDOW_MODE_CDC";
    case WindowMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Graph {
  featureSets: FeatureSet[];
  resolvers: Resolver[];
  streamResolvers: StreamResolver[];
  sinkResolvers: SinkResolver[];
  /**
   * database_sources is deprecated; see database_sources_v2
   *
   * @deprecated
   */
  databaseSources: DatabaseSource[];
  /**
   * stream_sources is deprecated; see stream_sources_v2
   *
   * @deprecated
   */
  streamSources: StreamSource[];
  namedQueries: NamedQuery[];
  databaseSourcesV2: DatabaseSource1[];
  databaseSourceGroups: DatabaseSourceGroup[];
  streamSourcesV2: StreamSource2[];
}

export interface NamedQuery {
  name: string;
  queryVersion?: string | undefined;
  input: string[];
  output: string[];
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  meta: { [key: string]: string };
  staleness: { [key: string]: Duration };
  plannerOptions: { [key: string]: string };
  fileName: string;
  /** required */
  deploymentId?: string | undefined;
  sourceFileReference?: SourceFileReference | undefined;
  additionalLoggedFeatures: string[];
  validPlanNotRequired?: boolean | undefined;
}

export interface NamedQuery_MetaEntry {
  key: string;
  value: string;
}

export interface NamedQuery_StalenessEntry {
  key: string;
  value: Duration | undefined;
}

export interface NamedQuery_PlannerOptionsEntry {
  key: string;
  value: string;
}

export interface FeatureSet {
  name: string;
  features: FeatureType[];
  maxStalenessDuration: Duration | undefined;
  isSingleton: boolean;
  tags: string[];
  owner?:
    | string
    | undefined;
  /** The docstring of the class on which the features are defined. */
  doc?: string | undefined;
  etlOfflineToOnline?: boolean | undefined;
  classPath?: string | undefined;
}

export interface FeatureType {
  scalar?: ScalarFeatureType | undefined;
  hasOne?: HasOneFeatureType | undefined;
  hasMany?: HasManyFeatureType | undefined;
  featureTime?: FeatureTimeFeatureType | undefined;
  windowed?: WindowedFeatureType | undefined;
  groupBy?: GroupByFeatureType | undefined;
}

export interface FeatureReference {
  name: string;
  namespace: string;
  path: FeatureReference[];
  df: DataFrameType | undefined;
}

export interface DataFrameType {
  rootNamespace: string;
  requiredColumns: FeatureReference[];
  optionalColumns: FeatureReference[];
  filter: LogicalExprNode | undefined;
  limit?: number | undefined;
}

export interface GroupByFeatureType {
  name: string;
  namespace: string;
  isNullable: boolean;
  internalVersion?: number | undefined;
  arrowType: ArrowType | undefined;
  aggregation: WindowAggregation | undefined;
  windowDurations: Duration[];
  expression: LogicalExprNode | undefined;
  defaultValue: ScalarValue | undefined;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  validations: FeatureValidation[];
  attributeName: string;
}

export interface ScalarFeatureType {
  name: string;
  namespace: string;
  isAutogenerated: boolean;
  noDisplay: boolean;
  isPrimary: boolean;
  isNullable: boolean;
  internalVersion?:
    | number
    | undefined;
  /**
   * This represents whatever arg the user passed into the `feature()` call.
   * If both set, this should take precedence over the value in `FeatureSet`.
   * If unset here, the value in `FeatureSet` should be used.
   */
  maxStalenessDuration: Duration | undefined;
  offlineTtlDuration: Duration | undefined;
  arrowType: ArrowType | undefined;
  version: VersionInfo | undefined;
  windowInfo: WindowInfo | undefined;
  defaultValue: ScalarValue | undefined;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  expression: LogicalExprNode | undefined;
  validations: FeatureValidation[];
  lastFor:
    | FeatureReference
    | undefined;
  /**
   * This represents whatever arg the user passed into the `feature()` call.
   * If both set, this should take precedence over the value in `FeatureSet`.
   * If unset here, the value in `FeatureSet` should be used.
   */
  etlOfflineToOnline?: boolean | undefined;
  isDistancePseudofeature: boolean;
  attributeName: string;
  /** Whether the user marked the feature as deprecated. */
  isDeprecated: boolean;
  cacheStrategy: CacheStrategy;
  /** optional because proto default is false, but chalk defaults to true */
  storeOnline?:
    | boolean
    | undefined;
  /** optional because proto default is false, but chalk defaults to true */
  storeOffline?: boolean | undefined;
}

export interface HasOneFeatureType {
  name: string;
  namespace: string;
  foreignNamespace: string;
  join: LogicalExprNode | undefined;
  isNullable: boolean;
  isAutogenerated: boolean;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  attributeName: string;
}

export interface HasManyFeatureType {
  name: string;
  namespace: string;
  foreignNamespace: string;
  join: LogicalExprNode | undefined;
  isAutogenerated: boolean;
  maxStalenessDuration: Duration | undefined;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  attributeName: string;
}

export interface FeatureTimeFeatureType {
  name: string;
  namespace: string;
  isAutogenerated: boolean;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  attributeName: string;
}

export interface WindowedFeatureType {
  name: string;
  namespace: string;
  isAutogenerated: boolean;
  windowDurations: Duration[];
  attributeName: string;
}

export interface WindowAggregation {
  namespace: string;
  groupBy: FeatureReference[];
  bucketDuration: Duration | undefined;
  aggregation: string;
  aggregateOn?: FeatureReference | undefined;
  arrowType: ArrowType | undefined;
  filters: LogicalExprNode[];
  /**
   * The resolver to use for back-filling the materialized aggregate.
   * If not provided, the data will be back filled using the resolver
   * that would run for an offline query.
   */
  backfillResolver?:
    | string
    | undefined;
  /**
   * The amount of time before the start of the previous backfill
   * to consider when running the backfill resolver. Set this parameter
   * to the be equal to the latest arriving data in the backfill window.
   */
  backfillLookbackDuration?:
    | Duration
    | undefined;
  /**
   * The time at which to start back filling the materialized aggregate.
   * If not provided, the backfill consider the earliest available data returned
   * by the `backfill_resolver`.
   */
  backfillStartTime?:
    | Date
    | undefined;
  /**
   * The resolver to use for continuous updates to the materialized aggregate.
   * If not provided, the data will be updated using the resolver that would run
   * for an online query.
   */
  continuousResolver?:
    | string
    | undefined;
  /**
   * The period for which to use the continuous resolver, instead
   * of relying upon the last backfill. If not provided, and a continuous
   * resolver is provided, this will be set to backfill_lookback_duration.
   */
  continuousBufferDuration?:
    | Duration
    | undefined;
  /**
   * A crontab or duration string to specify the schedule for back filling the
   * materialized aggregate.
   */
  backfillSchedule?:
    | string
    | undefined;
  /** The lower bound of the first bucket. All buckets are aligned to this time. */
  bucketStart: Date | undefined;
}

export interface WindowInfo {
  duration: Duration | undefined;
  aggregation?: WindowAggregation | undefined;
}

export interface FeatureInput {
  feature: FeatureReference | undefined;
  defaultValue: ScalarValue | undefined;
}

export interface ResolverInput {
  feature?: FeatureInput | undefined;
  df?: DataFrameType | undefined;
  state?: ResolverState | undefined;
}

export interface ResolverOutput {
  feature?: FeatureReference | undefined;
  df?: DataFrameType | undefined;
}

export interface Resolver {
  fqn: string;
  kind: ResolverKind;
  inputs: ResolverInput[];
  outputs: ResolverOutput[];
  isGenerator: boolean;
  /**
   * data_sources is deprecated; see data_sources_v2
   *
   * @deprecated
   */
  dataSources: DatabaseSourceReference[];
  machineType?: string | undefined;
  tags: string[];
  owner?:
    | string
    | undefined;
  /** The docstring of the python function */
  doc?: string | undefined;
  environments: string[];
  timeoutDuration: Duration | undefined;
  schedule: Schedule | undefined;
  when: LogicalExprNode | undefined;
  cronFilter: CronFilterWithFeatureArgs | undefined;
  function: FunctionReference | undefined;
  resourceHint: ResourceHint;
  isStatic: boolean;
  isTotal?: boolean | undefined;
  uniqueOn: string[];
  partitionedBy: string[];
  dataSourcesV2: DatabaseSourceReference3[];
  staticOperation: LogicalExprNode | undefined;
  sqlSettings?: SQLResolverSettings | undefined;
}

export interface SinkResolver {
  fqn: string;
  inputs: ResolverInput[];
  bufferSize?: number | undefined;
  debounceDuration: Duration | undefined;
  maxDelayDuration: Duration | undefined;
  upsert: boolean;
  /**
   * stream_source is deprecated; see stream_source_v2
   *
   * @deprecated
   */
  streamSource?:
    | StreamSourceReference
    | undefined;
  /**
   * database_source is deprecated; see database_source_v2
   *
   * @deprecated
   */
  databaseSource?: DatabaseSourceReference | undefined;
  streamSourceV2?: StreamSourceReference4 | undefined;
  databaseSourceV2?: DatabaseSourceReference3 | undefined;
  machineType?: string | undefined;
  doc?: string | undefined;
  owner?: string | undefined;
  environments: string[];
  timeoutDuration: Duration | undefined;
  function: FunctionReference | undefined;
}

export interface ParseInfo {
  parseFunction: FunctionReference | undefined;
  parseFunctionInputType: ArrowType | undefined;
  parseFunctionOutputType: ArrowType | undefined;
  isParseFunctionOutputOptional: boolean;
}

export interface StreamResolver {
  fqn: string;
  params: StreamResolverParam[];
  outputs: ResolverOutput[];
  explicitSchema: ArrowType | undefined;
  keys: StreamKey[];
  /** @deprecated */
  source: StreamSourceReference | undefined;
  parseInfo: ParseInfo | undefined;
  mode: WindowMode;
  environments: string[];
  timeoutDuration: Duration | undefined;
  timestampAttributeName?: string | undefined;
  owner?: string | undefined;
  doc?: string | undefined;
  machineType?: string | undefined;
  function: FunctionReference | undefined;
  sourceV2: StreamSourceReference4 | undefined;
}

export interface ResolverState {
  initial: ScalarValue | undefined;
  arrowType: ArrowType | undefined;
}

export interface StreamResolverParam {
  message?: StreamResolverParamMessage | undefined;
  messageWindow?: StreamResolverParamMessageWindow | undefined;
  state?: ResolverState | undefined;
}

export interface StreamResolverParamMessageWindow {
  name: string;
  arrowType: ArrowType | undefined;
}

export interface StreamResolverParamMessage {
  name: string;
  arrowType: ArrowType | undefined;
}

export interface FunctionReference {
  name: string;
  module: string;
  fileName: string;
  functionDefinition: string;
  sourceLine?: number | undefined;
  capturedGlobals: FunctionReferenceCapturedGlobal[];
}

export interface FunctionReferenceCapturedGlobal {
  globalName: string;
  builtin?: FunctionGlobalCapturedBuiltin | undefined;
  featureClass?: FunctionGlobalCapturedFeatureClass | undefined;
  enum?: FunctionGlobalCapturedEnum | undefined;
  module?: FunctionGlobalCapturedModule | undefined;
  moduleMember?: FunctionGlobalCapturedModuleMember | undefined;
  function?: FunctionGlobalCapturedFunction | undefined;
  struct?: FunctionGlobalCapturedStruct | undefined;
  variable?: FunctionGlobalCapturedVariable | undefined;
  sourceReference?: SourceFileReference | undefined;
}

export interface FunctionGlobalCapturedBuiltin {
  builtinName: string;
}

export interface FunctionGlobalCapturedVariable {
  module: string;
  name: string;
}

export interface FunctionGlobalCapturedStruct {
  module: string;
  name: string;
  paDtype: ArrowType | undefined;
}

export interface FunctionGlobalCapturedEnum {
  module: string;
  name: string;
  memberMap: { [key: string]: ScalarValue };
  bases: ArrowType[];
}

export interface FunctionGlobalCapturedEnum_MemberMapEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface FunctionGlobalCapturedFeatureClass {
  featureClassName: string;
}

export interface FunctionGlobalCapturedModule {
  name: string;
}

export interface FunctionGlobalCapturedModuleMember {
  /** Imported classes/functions, e.g. json.encoder.JSONEncoder */
  moduleName: string;
  /** name of the class or function, e.g. `JSONEncoder``. Not present for modules. */
  qualname: string;
}

export interface FunctionGlobalCapturedFunction {
  source: string;
  capturedGlobals: FunctionReferenceCapturedGlobal[];
  module?: string | undefined;
  name: string;
}

export interface SourceFileReference {
  range: Range | undefined;
  code?: string | undefined;
  fileName: string;
}

export interface StreamKey {
  key: string;
  feature: FeatureReference | undefined;
}

export interface SQLResolverSettings {
  finalizer: Finalizer;
  incrementalSettings?: IncrementalSettings | undefined;
  fieldsRootFqn: { [key: string]: string };
}

export interface SQLResolverSettings_FieldsRootFqnEntry {
  key: string;
  value: string;
}

export interface IncrementalSettings {
  mode: IncrementalMode;
  lookbackPeriod?: Duration | undefined;
  incrementalColumn?: string | undefined;
  timestampMode: IncrementalTimestampMode;
}

export interface CronFilterWithFeatureArgs {
  filter: FunctionReference | undefined;
  args: FeatureReference[];
}

export interface Schedule {
  crontab?: string | undefined;
  duration?: Duration | undefined;
  filter: FunctionReference | undefined;
  sample: FunctionReference | undefined;
}

export interface FeatureValidation {
  /**
   * Deprecated since they don't store the full type information (e.g. different numeric types)
   * Use the *_arrow fields (6-9) instead.
   *
   * @deprecated
   */
  min?:
    | number
    | undefined;
  /** @deprecated */
  max?:
    | number
    | undefined;
  /** @deprecated */
  minLength?:
    | number
    | undefined;
  /** @deprecated */
  maxLength?: number | undefined;
  minArrow?: ScalarValue | undefined;
  maxArrow?: ScalarValue | undefined;
  minLengthArrow?: ScalarValue | undefined;
  maxLengthArrow?: ScalarValue | undefined;
  contains?: ScalarValue | undefined;
  strict: boolean;
}

export interface VersionInfo {
  default: number;
  maximum: number;
}

export interface StrictValidation {
  feature: FeatureReference | undefined;
  validations: FeatureValidation[];
}

function createBaseGraph(): Graph {
  return {
    featureSets: [],
    resolvers: [],
    streamResolvers: [],
    sinkResolvers: [],
    databaseSources: [],
    streamSources: [],
    namedQueries: [],
    databaseSourcesV2: [],
    databaseSourceGroups: [],
    streamSourcesV2: [],
  };
}

export const Graph: MessageFns<Graph> = {
  encode(message: Graph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.featureSets) {
      FeatureSet.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.resolvers) {
      Resolver.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.streamResolvers) {
      StreamResolver.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.sinkResolvers) {
      SinkResolver.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.databaseSources) {
      DatabaseSource.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.streamSources) {
      StreamSource.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.namedQueries) {
      NamedQuery.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.databaseSourcesV2) {
      DatabaseSource1.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.databaseSourceGroups) {
      DatabaseSourceGroup.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.streamSourcesV2) {
      StreamSource2.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Graph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureSets.push(FeatureSet.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resolvers.push(Resolver.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.streamResolvers.push(StreamResolver.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sinkResolvers.push(SinkResolver.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.databaseSources.push(DatabaseSource.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streamSources.push(StreamSource.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.namedQueries.push(NamedQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.databaseSourcesV2.push(DatabaseSource1.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.databaseSourceGroups.push(DatabaseSourceGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.streamSourcesV2.push(StreamSource2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Graph {
    return {
      featureSets: globalThis.Array.isArray(object?.featureSets)
        ? object.featureSets.map((e: any) => FeatureSet.fromJSON(e))
        : [],
      resolvers: globalThis.Array.isArray(object?.resolvers)
        ? object.resolvers.map((e: any) => Resolver.fromJSON(e))
        : [],
      streamResolvers: globalThis.Array.isArray(object?.streamResolvers)
        ? object.streamResolvers.map((e: any) => StreamResolver.fromJSON(e))
        : [],
      sinkResolvers: globalThis.Array.isArray(object?.sinkResolvers)
        ? object.sinkResolvers.map((e: any) => SinkResolver.fromJSON(e))
        : [],
      databaseSources: globalThis.Array.isArray(object?.databaseSources)
        ? object.databaseSources.map((e: any) => DatabaseSource.fromJSON(e))
        : [],
      streamSources: globalThis.Array.isArray(object?.streamSources)
        ? object.streamSources.map((e: any) => StreamSource.fromJSON(e))
        : [],
      namedQueries: globalThis.Array.isArray(object?.namedQueries)
        ? object.namedQueries.map((e: any) => NamedQuery.fromJSON(e))
        : [],
      databaseSourcesV2: globalThis.Array.isArray(object?.databaseSourcesV2)
        ? object.databaseSourcesV2.map((e: any) => DatabaseSource1.fromJSON(e))
        : [],
      databaseSourceGroups: globalThis.Array.isArray(object?.databaseSourceGroups)
        ? object.databaseSourceGroups.map((e: any) => DatabaseSourceGroup.fromJSON(e))
        : [],
      streamSourcesV2: globalThis.Array.isArray(object?.streamSourcesV2)
        ? object.streamSourcesV2.map((e: any) => StreamSource2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Graph): unknown {
    const obj: any = {};
    if (message.featureSets?.length) {
      obj.featureSets = message.featureSets.map((e) => FeatureSet.toJSON(e));
    }
    if (message.resolvers?.length) {
      obj.resolvers = message.resolvers.map((e) => Resolver.toJSON(e));
    }
    if (message.streamResolvers?.length) {
      obj.streamResolvers = message.streamResolvers.map((e) => StreamResolver.toJSON(e));
    }
    if (message.sinkResolvers?.length) {
      obj.sinkResolvers = message.sinkResolvers.map((e) => SinkResolver.toJSON(e));
    }
    if (message.databaseSources?.length) {
      obj.databaseSources = message.databaseSources.map((e) => DatabaseSource.toJSON(e));
    }
    if (message.streamSources?.length) {
      obj.streamSources = message.streamSources.map((e) => StreamSource.toJSON(e));
    }
    if (message.namedQueries?.length) {
      obj.namedQueries = message.namedQueries.map((e) => NamedQuery.toJSON(e));
    }
    if (message.databaseSourcesV2?.length) {
      obj.databaseSourcesV2 = message.databaseSourcesV2.map((e) => DatabaseSource1.toJSON(e));
    }
    if (message.databaseSourceGroups?.length) {
      obj.databaseSourceGroups = message.databaseSourceGroups.map((e) => DatabaseSourceGroup.toJSON(e));
    }
    if (message.streamSourcesV2?.length) {
      obj.streamSourcesV2 = message.streamSourcesV2.map((e) => StreamSource2.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Graph>, I>>(base?: I): Graph {
    return Graph.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Graph>, I>>(object: I): Graph {
    const message = createBaseGraph();
    message.featureSets = object.featureSets?.map((e) => FeatureSet.fromPartial(e)) || [];
    message.resolvers = object.resolvers?.map((e) => Resolver.fromPartial(e)) || [];
    message.streamResolvers = object.streamResolvers?.map((e) => StreamResolver.fromPartial(e)) || [];
    message.sinkResolvers = object.sinkResolvers?.map((e) => SinkResolver.fromPartial(e)) || [];
    message.databaseSources = object.databaseSources?.map((e) => DatabaseSource.fromPartial(e)) || [];
    message.streamSources = object.streamSources?.map((e) => StreamSource.fromPartial(e)) || [];
    message.namedQueries = object.namedQueries?.map((e) => NamedQuery.fromPartial(e)) || [];
    message.databaseSourcesV2 = object.databaseSourcesV2?.map((e) => DatabaseSource1.fromPartial(e)) || [];
    message.databaseSourceGroups = object.databaseSourceGroups?.map((e) => DatabaseSourceGroup.fromPartial(e)) || [];
    message.streamSourcesV2 = object.streamSourcesV2?.map((e) => StreamSource2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNamedQuery(): NamedQuery {
  return {
    name: "",
    queryVersion: undefined,
    input: [],
    output: [],
    tags: [],
    description: undefined,
    owner: undefined,
    meta: {},
    staleness: {},
    plannerOptions: {},
    fileName: "",
    deploymentId: undefined,
    sourceFileReference: undefined,
    additionalLoggedFeatures: [],
    validPlanNotRequired: undefined,
  };
}

export const NamedQuery: MessageFns<NamedQuery> = {
  encode(message: NamedQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.queryVersion !== undefined) {
      writer.uint32(18).string(message.queryVersion);
    }
    for (const v of message.input) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.output) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(58).string(message.owner);
    }
    Object.entries(message.meta).forEach(([key, value]) => {
      NamedQuery_MetaEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    Object.entries(message.staleness).forEach(([key, value]) => {
      NamedQuery_StalenessEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.plannerOptions).forEach(([key, value]) => {
      NamedQuery_PlannerOptionsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.fileName !== "") {
      writer.uint32(90).string(message.fileName);
    }
    if (message.deploymentId !== undefined) {
      writer.uint32(98).string(message.deploymentId);
    }
    if (message.sourceFileReference !== undefined) {
      SourceFileReference.encode(message.sourceFileReference, writer.uint32(106).fork()).join();
    }
    for (const v of message.additionalLoggedFeatures) {
      writer.uint32(114).string(v!);
    }
    if (message.validPlanNotRequired !== undefined) {
      writer.uint32(120).bool(message.validPlanNotRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queryVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = NamedQuery_MetaEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.meta[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = NamedQuery_StalenessEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.staleness[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = NamedQuery_PlannerOptionsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.plannerOptions[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sourceFileReference = SourceFileReference.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.additionalLoggedFeatures.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.validPlanNotRequired = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      queryVersion: isSet(object.queryVersion) ? globalThis.String(object.queryVersion) : undefined,
      input: globalThis.Array.isArray(object?.input) ? object.input.map((e: any) => globalThis.String(e)) : [],
      output: globalThis.Array.isArray(object?.output) ? object.output.map((e: any) => globalThis.String(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      meta: isObject(object.meta)
        ? Object.entries(object.meta).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      staleness: isObject(object.staleness)
        ? Object.entries(object.staleness).reduce<{ [key: string]: Duration }>((acc, [key, value]) => {
          acc[key] = Duration.fromJSON(value);
          return acc;
        }, {})
        : {},
      plannerOptions: isObject(object.plannerOptions)
        ? Object.entries(object.plannerOptions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      sourceFileReference: isSet(object.sourceFileReference)
        ? SourceFileReference.fromJSON(object.sourceFileReference)
        : undefined,
      additionalLoggedFeatures: globalThis.Array.isArray(object?.additionalLoggedFeatures)
        ? object.additionalLoggedFeatures.map((e: any) => globalThis.String(e))
        : [],
      validPlanNotRequired: isSet(object.validPlanNotRequired)
        ? globalThis.Boolean(object.validPlanNotRequired)
        : undefined,
    };
  },

  toJSON(message: NamedQuery): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.queryVersion !== undefined) {
      obj.queryVersion = message.queryVersion;
    }
    if (message.input?.length) {
      obj.input = message.input;
    }
    if (message.output?.length) {
      obj.output = message.output;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.meta) {
      const entries = Object.entries(message.meta);
      if (entries.length > 0) {
        obj.meta = {};
        entries.forEach(([k, v]) => {
          obj.meta[k] = v;
        });
      }
    }
    if (message.staleness) {
      const entries = Object.entries(message.staleness);
      if (entries.length > 0) {
        obj.staleness = {};
        entries.forEach(([k, v]) => {
          obj.staleness[k] = Duration.toJSON(v);
        });
      }
    }
    if (message.plannerOptions) {
      const entries = Object.entries(message.plannerOptions);
      if (entries.length > 0) {
        obj.plannerOptions = {};
        entries.forEach(([k, v]) => {
          obj.plannerOptions[k] = v;
        });
      }
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.sourceFileReference !== undefined) {
      obj.sourceFileReference = SourceFileReference.toJSON(message.sourceFileReference);
    }
    if (message.additionalLoggedFeatures?.length) {
      obj.additionalLoggedFeatures = message.additionalLoggedFeatures;
    }
    if (message.validPlanNotRequired !== undefined) {
      obj.validPlanNotRequired = message.validPlanNotRequired;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedQuery>, I>>(base?: I): NamedQuery {
    return NamedQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedQuery>, I>>(object: I): NamedQuery {
    const message = createBaseNamedQuery();
    message.name = object.name ?? "";
    message.queryVersion = object.queryVersion ?? undefined;
    message.input = object.input?.map((e) => e) || [];
    message.output = object.output?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.meta = Object.entries(object.meta ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.staleness = Object.entries(object.staleness ?? {}).reduce<{ [key: string]: Duration }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Duration.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.plannerOptions = Object.entries(object.plannerOptions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.fileName = object.fileName ?? "";
    message.deploymentId = object.deploymentId ?? undefined;
    message.sourceFileReference = (object.sourceFileReference !== undefined && object.sourceFileReference !== null)
      ? SourceFileReference.fromPartial(object.sourceFileReference)
      : undefined;
    message.additionalLoggedFeatures = object.additionalLoggedFeatures?.map((e) => e) || [];
    message.validPlanNotRequired = object.validPlanNotRequired ?? undefined;
    return message;
  },
};

function createBaseNamedQuery_MetaEntry(): NamedQuery_MetaEntry {
  return { key: "", value: "" };
}

export const NamedQuery_MetaEntry: MessageFns<NamedQuery_MetaEntry> = {
  encode(message: NamedQuery_MetaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery_MetaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery_MetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery_MetaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NamedQuery_MetaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedQuery_MetaEntry>, I>>(base?: I): NamedQuery_MetaEntry {
    return NamedQuery_MetaEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedQuery_MetaEntry>, I>>(object: I): NamedQuery_MetaEntry {
    const message = createBaseNamedQuery_MetaEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNamedQuery_StalenessEntry(): NamedQuery_StalenessEntry {
  return { key: "", value: undefined };
}

export const NamedQuery_StalenessEntry: MessageFns<NamedQuery_StalenessEntry> = {
  encode(message: NamedQuery_StalenessEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Duration.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery_StalenessEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery_StalenessEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery_StalenessEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Duration.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NamedQuery_StalenessEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Duration.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedQuery_StalenessEntry>, I>>(base?: I): NamedQuery_StalenessEntry {
    return NamedQuery_StalenessEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedQuery_StalenessEntry>, I>>(object: I): NamedQuery_StalenessEntry {
    const message = createBaseNamedQuery_StalenessEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Duration.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNamedQuery_PlannerOptionsEntry(): NamedQuery_PlannerOptionsEntry {
  return { key: "", value: "" };
}

export const NamedQuery_PlannerOptionsEntry: MessageFns<NamedQuery_PlannerOptionsEntry> = {
  encode(message: NamedQuery_PlannerOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery_PlannerOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery_PlannerOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery_PlannerOptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NamedQuery_PlannerOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedQuery_PlannerOptionsEntry>, I>>(base?: I): NamedQuery_PlannerOptionsEntry {
    return NamedQuery_PlannerOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedQuery_PlannerOptionsEntry>, I>>(
    object: I,
  ): NamedQuery_PlannerOptionsEntry {
    const message = createBaseNamedQuery_PlannerOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFeatureSet(): FeatureSet {
  return {
    name: "",
    features: [],
    maxStalenessDuration: undefined,
    isSingleton: false,
    tags: [],
    owner: undefined,
    doc: undefined,
    etlOfflineToOnline: undefined,
    classPath: undefined,
  };
}

export const FeatureSet: MessageFns<FeatureSet> = {
  encode(message: FeatureSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.features) {
      FeatureType.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.maxStalenessDuration !== undefined) {
      Duration.encode(message.maxStalenessDuration, writer.uint32(26).fork()).join();
    }
    if (message.isSingleton !== false) {
      writer.uint32(32).bool(message.isSingleton);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.owner !== undefined) {
      writer.uint32(50).string(message.owner);
    }
    if (message.doc !== undefined) {
      writer.uint32(58).string(message.doc);
    }
    if (message.etlOfflineToOnline !== undefined) {
      writer.uint32(64).bool(message.etlOfflineToOnline);
    }
    if (message.classPath !== undefined) {
      writer.uint32(74).string(message.classPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.features.push(FeatureType.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxStalenessDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSingleton = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.classPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => FeatureType.fromJSON(e))
        : [],
      maxStalenessDuration: isSet(object.maxStalenessDuration)
        ? Duration.fromJSON(object.maxStalenessDuration)
        : undefined,
      isSingleton: isSet(object.isSingleton) ? globalThis.Boolean(object.isSingleton) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : undefined,
      classPath: isSet(object.classPath) ? globalThis.String(object.classPath) : undefined,
    };
  },

  toJSON(message: FeatureSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.features?.length) {
      obj.features = message.features.map((e) => FeatureType.toJSON(e));
    }
    if (message.maxStalenessDuration !== undefined) {
      obj.maxStalenessDuration = Duration.toJSON(message.maxStalenessDuration);
    }
    if (message.isSingleton !== false) {
      obj.isSingleton = message.isSingleton;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.etlOfflineToOnline !== undefined) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.classPath !== undefined) {
      obj.classPath = message.classPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureSet>, I>>(base?: I): FeatureSet {
    return FeatureSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureSet>, I>>(object: I): FeatureSet {
    const message = createBaseFeatureSet();
    message.name = object.name ?? "";
    message.features = object.features?.map((e) => FeatureType.fromPartial(e)) || [];
    message.maxStalenessDuration = (object.maxStalenessDuration !== undefined && object.maxStalenessDuration !== null)
      ? Duration.fromPartial(object.maxStalenessDuration)
      : undefined;
    message.isSingleton = object.isSingleton ?? false;
    message.tags = object.tags?.map((e) => e) || [];
    message.owner = object.owner ?? undefined;
    message.doc = object.doc ?? undefined;
    message.etlOfflineToOnline = object.etlOfflineToOnline ?? undefined;
    message.classPath = object.classPath ?? undefined;
    return message;
  },
};

function createBaseFeatureType(): FeatureType {
  return {
    scalar: undefined,
    hasOne: undefined,
    hasMany: undefined,
    featureTime: undefined,
    windowed: undefined,
    groupBy: undefined,
  };
}

export const FeatureType: MessageFns<FeatureType> = {
  encode(message: FeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scalar !== undefined) {
      ScalarFeatureType.encode(message.scalar, writer.uint32(10).fork()).join();
    }
    if (message.hasOne !== undefined) {
      HasOneFeatureType.encode(message.hasOne, writer.uint32(18).fork()).join();
    }
    if (message.hasMany !== undefined) {
      HasManyFeatureType.encode(message.hasMany, writer.uint32(26).fork()).join();
    }
    if (message.featureTime !== undefined) {
      FeatureTimeFeatureType.encode(message.featureTime, writer.uint32(34).fork()).join();
    }
    if (message.windowed !== undefined) {
      WindowedFeatureType.encode(message.windowed, writer.uint32(42).fork()).join();
    }
    if (message.groupBy !== undefined) {
      GroupByFeatureType.encode(message.groupBy, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scalar = ScalarFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hasOne = HasOneFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hasMany = HasManyFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.featureTime = FeatureTimeFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.windowed = WindowedFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.groupBy = GroupByFeatureType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureType {
    return {
      scalar: isSet(object.scalar) ? ScalarFeatureType.fromJSON(object.scalar) : undefined,
      hasOne: isSet(object.hasOne) ? HasOneFeatureType.fromJSON(object.hasOne) : undefined,
      hasMany: isSet(object.hasMany) ? HasManyFeatureType.fromJSON(object.hasMany) : undefined,
      featureTime: isSet(object.featureTime) ? FeatureTimeFeatureType.fromJSON(object.featureTime) : undefined,
      windowed: isSet(object.windowed) ? WindowedFeatureType.fromJSON(object.windowed) : undefined,
      groupBy: isSet(object.groupBy) ? GroupByFeatureType.fromJSON(object.groupBy) : undefined,
    };
  },

  toJSON(message: FeatureType): unknown {
    const obj: any = {};
    if (message.scalar !== undefined) {
      obj.scalar = ScalarFeatureType.toJSON(message.scalar);
    }
    if (message.hasOne !== undefined) {
      obj.hasOne = HasOneFeatureType.toJSON(message.hasOne);
    }
    if (message.hasMany !== undefined) {
      obj.hasMany = HasManyFeatureType.toJSON(message.hasMany);
    }
    if (message.featureTime !== undefined) {
      obj.featureTime = FeatureTimeFeatureType.toJSON(message.featureTime);
    }
    if (message.windowed !== undefined) {
      obj.windowed = WindowedFeatureType.toJSON(message.windowed);
    }
    if (message.groupBy !== undefined) {
      obj.groupBy = GroupByFeatureType.toJSON(message.groupBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureType>, I>>(base?: I): FeatureType {
    return FeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureType>, I>>(object: I): FeatureType {
    const message = createBaseFeatureType();
    message.scalar = (object.scalar !== undefined && object.scalar !== null)
      ? ScalarFeatureType.fromPartial(object.scalar)
      : undefined;
    message.hasOne = (object.hasOne !== undefined && object.hasOne !== null)
      ? HasOneFeatureType.fromPartial(object.hasOne)
      : undefined;
    message.hasMany = (object.hasMany !== undefined && object.hasMany !== null)
      ? HasManyFeatureType.fromPartial(object.hasMany)
      : undefined;
    message.featureTime = (object.featureTime !== undefined && object.featureTime !== null)
      ? FeatureTimeFeatureType.fromPartial(object.featureTime)
      : undefined;
    message.windowed = (object.windowed !== undefined && object.windowed !== null)
      ? WindowedFeatureType.fromPartial(object.windowed)
      : undefined;
    message.groupBy = (object.groupBy !== undefined && object.groupBy !== null)
      ? GroupByFeatureType.fromPartial(object.groupBy)
      : undefined;
    return message;
  },
};

function createBaseFeatureReference(): FeatureReference {
  return { name: "", namespace: "", path: [], df: undefined };
}

export const FeatureReference: MessageFns<FeatureReference> = {
  encode(message: FeatureReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    for (const v of message.path) {
      FeatureReference.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.df !== undefined) {
      DataFrameType.encode(message.df, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.df = DataFrameType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => FeatureReference.fromJSON(e)) : [],
      df: isSet(object.df) ? DataFrameType.fromJSON(object.df) : undefined,
    };
  },

  toJSON(message: FeatureReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => FeatureReference.toJSON(e));
    }
    if (message.df !== undefined) {
      obj.df = DataFrameType.toJSON(message.df);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureReference>, I>>(base?: I): FeatureReference {
    return FeatureReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureReference>, I>>(object: I): FeatureReference {
    const message = createBaseFeatureReference();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.path = object.path?.map((e) => FeatureReference.fromPartial(e)) || [];
    message.df = (object.df !== undefined && object.df !== null) ? DataFrameType.fromPartial(object.df) : undefined;
    return message;
  },
};

function createBaseDataFrameType(): DataFrameType {
  return { rootNamespace: "", requiredColumns: [], optionalColumns: [], filter: undefined, limit: undefined };
}

export const DataFrameType: MessageFns<DataFrameType> = {
  encode(message: DataFrameType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootNamespace !== "") {
      writer.uint32(10).string(message.rootNamespace);
    }
    for (const v of message.requiredColumns) {
      FeatureReference.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.optionalColumns) {
      FeatureReference.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.filter !== undefined) {
      LogicalExprNode.encode(message.filter, writer.uint32(34).fork()).join();
    }
    if (message.limit !== undefined) {
      writer.uint32(40).uint64(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataFrameType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataFrameType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootNamespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requiredColumns.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.optionalColumns.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataFrameType {
    return {
      rootNamespace: isSet(object.rootNamespace) ? globalThis.String(object.rootNamespace) : "",
      requiredColumns: globalThis.Array.isArray(object?.requiredColumns)
        ? object.requiredColumns.map((e: any) => FeatureReference.fromJSON(e))
        : [],
      optionalColumns: globalThis.Array.isArray(object?.optionalColumns)
        ? object.optionalColumns.map((e: any) => FeatureReference.fromJSON(e))
        : [],
      filter: isSet(object.filter) ? LogicalExprNode.fromJSON(object.filter) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: DataFrameType): unknown {
    const obj: any = {};
    if (message.rootNamespace !== "") {
      obj.rootNamespace = message.rootNamespace;
    }
    if (message.requiredColumns?.length) {
      obj.requiredColumns = message.requiredColumns.map((e) => FeatureReference.toJSON(e));
    }
    if (message.optionalColumns?.length) {
      obj.optionalColumns = message.optionalColumns.map((e) => FeatureReference.toJSON(e));
    }
    if (message.filter !== undefined) {
      obj.filter = LogicalExprNode.toJSON(message.filter);
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataFrameType>, I>>(base?: I): DataFrameType {
    return DataFrameType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataFrameType>, I>>(object: I): DataFrameType {
    const message = createBaseDataFrameType();
    message.rootNamespace = object.rootNamespace ?? "";
    message.requiredColumns = object.requiredColumns?.map((e) => FeatureReference.fromPartial(e)) || [];
    message.optionalColumns = object.optionalColumns?.map((e) => FeatureReference.fromPartial(e)) || [];
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? LogicalExprNode.fromPartial(object.filter)
      : undefined;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseGroupByFeatureType(): GroupByFeatureType {
  return {
    name: "",
    namespace: "",
    isNullable: false,
    internalVersion: undefined,
    arrowType: undefined,
    aggregation: undefined,
    windowDurations: [],
    expression: undefined,
    defaultValue: undefined,
    tags: [],
    description: undefined,
    owner: undefined,
    validations: [],
    attributeName: "",
  };
}

export const GroupByFeatureType: MessageFns<GroupByFeatureType> = {
  encode(message: GroupByFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isNullable !== false) {
      writer.uint32(24).bool(message.isNullable);
    }
    if (message.internalVersion !== undefined) {
      writer.uint32(32).uint64(message.internalVersion);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(42).fork()).join();
    }
    if (message.aggregation !== undefined) {
      WindowAggregation.encode(message.aggregation, writer.uint32(50).fork()).join();
    }
    for (const v of message.windowDurations) {
      Duration.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.expression !== undefined) {
      LogicalExprNode.encode(message.expression, writer.uint32(66).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      ScalarValue.encode(message.defaultValue, writer.uint32(74).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(82).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(90).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(98).string(message.owner);
    }
    for (const v of message.validations) {
      FeatureValidation.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.attributeName !== "") {
      writer.uint32(114).string(message.attributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupByFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupByFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isNullable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.internalVersion = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.aggregation = WindowAggregation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.windowDurations.push(Duration.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expression = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.defaultValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.validations.push(FeatureValidation.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupByFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isNullable: isSet(object.isNullable) ? globalThis.Boolean(object.isNullable) : false,
      internalVersion: isSet(object.internalVersion) ? globalThis.Number(object.internalVersion) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      aggregation: isSet(object.aggregation) ? WindowAggregation.fromJSON(object.aggregation) : undefined,
      windowDurations: globalThis.Array.isArray(object?.windowDurations)
        ? object.windowDurations.map((e: any) => Duration.fromJSON(e))
        : [],
      expression: isSet(object.expression) ? LogicalExprNode.fromJSON(object.expression) : undefined,
      defaultValue: isSet(object.defaultValue) ? ScalarValue.fromJSON(object.defaultValue) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => FeatureValidation.fromJSON(e))
        : [],
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
    };
  },

  toJSON(message: GroupByFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isNullable !== false) {
      obj.isNullable = message.isNullable;
    }
    if (message.internalVersion !== undefined) {
      obj.internalVersion = Math.round(message.internalVersion);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.aggregation !== undefined) {
      obj.aggregation = WindowAggregation.toJSON(message.aggregation);
    }
    if (message.windowDurations?.length) {
      obj.windowDurations = message.windowDurations.map((e) => Duration.toJSON(e));
    }
    if (message.expression !== undefined) {
      obj.expression = LogicalExprNode.toJSON(message.expression);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = ScalarValue.toJSON(message.defaultValue);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => FeatureValidation.toJSON(e));
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupByFeatureType>, I>>(base?: I): GroupByFeatureType {
    return GroupByFeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupByFeatureType>, I>>(object: I): GroupByFeatureType {
    const message = createBaseGroupByFeatureType();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.isNullable = object.isNullable ?? false;
    message.internalVersion = object.internalVersion ?? undefined;
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    message.aggregation = (object.aggregation !== undefined && object.aggregation !== null)
      ? WindowAggregation.fromPartial(object.aggregation)
      : undefined;
    message.windowDurations = object.windowDurations?.map((e) => Duration.fromPartial(e)) || [];
    message.expression = (object.expression !== undefined && object.expression !== null)
      ? LogicalExprNode.fromPartial(object.expression)
      : undefined;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? ScalarValue.fromPartial(object.defaultValue)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.validations = object.validations?.map((e) => FeatureValidation.fromPartial(e)) || [];
    message.attributeName = object.attributeName ?? "";
    return message;
  },
};

function createBaseScalarFeatureType(): ScalarFeatureType {
  return {
    name: "",
    namespace: "",
    isAutogenerated: false,
    noDisplay: false,
    isPrimary: false,
    isNullable: false,
    internalVersion: undefined,
    maxStalenessDuration: undefined,
    offlineTtlDuration: undefined,
    arrowType: undefined,
    version: undefined,
    windowInfo: undefined,
    defaultValue: undefined,
    tags: [],
    description: undefined,
    owner: undefined,
    expression: undefined,
    validations: [],
    lastFor: undefined,
    etlOfflineToOnline: undefined,
    isDistancePseudofeature: false,
    attributeName: "",
    isDeprecated: false,
    cacheStrategy: 0,
    storeOnline: undefined,
    storeOffline: undefined,
  };
}

export const ScalarFeatureType: MessageFns<ScalarFeatureType> = {
  encode(message: ScalarFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(24).bool(message.isAutogenerated);
    }
    if (message.noDisplay !== false) {
      writer.uint32(32).bool(message.noDisplay);
    }
    if (message.isPrimary !== false) {
      writer.uint32(40).bool(message.isPrimary);
    }
    if (message.isNullable !== false) {
      writer.uint32(48).bool(message.isNullable);
    }
    if (message.internalVersion !== undefined) {
      writer.uint32(56).uint64(message.internalVersion);
    }
    if (message.maxStalenessDuration !== undefined) {
      Duration.encode(message.maxStalenessDuration, writer.uint32(66).fork()).join();
    }
    if (message.offlineTtlDuration !== undefined) {
      Duration.encode(message.offlineTtlDuration, writer.uint32(82).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(90).fork()).join();
    }
    if (message.version !== undefined) {
      VersionInfo.encode(message.version, writer.uint32(98).fork()).join();
    }
    if (message.windowInfo !== undefined) {
      WindowInfo.encode(message.windowInfo, writer.uint32(106).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      ScalarValue.encode(message.defaultValue, writer.uint32(114).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(122).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(130).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(138).string(message.owner);
    }
    if (message.expression !== undefined) {
      LogicalExprNode.encode(message.expression, writer.uint32(146).fork()).join();
    }
    for (const v of message.validations) {
      FeatureValidation.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.lastFor !== undefined) {
      FeatureReference.encode(message.lastFor, writer.uint32(162).fork()).join();
    }
    if (message.etlOfflineToOnline !== undefined) {
      writer.uint32(168).bool(message.etlOfflineToOnline);
    }
    if (message.isDistancePseudofeature !== false) {
      writer.uint32(176).bool(message.isDistancePseudofeature);
    }
    if (message.attributeName !== "") {
      writer.uint32(186).string(message.attributeName);
    }
    if (message.isDeprecated !== false) {
      writer.uint32(192).bool(message.isDeprecated);
    }
    if (message.cacheStrategy !== 0) {
      writer.uint32(200).int32(message.cacheStrategy);
    }
    if (message.storeOnline !== undefined) {
      writer.uint32(208).bool(message.storeOnline);
    }
    if (message.storeOffline !== undefined) {
      writer.uint32(216).bool(message.storeOffline);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noDisplay = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isPrimary = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isNullable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.internalVersion = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.maxStalenessDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.offlineTtlDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.version = VersionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.windowInfo = WindowInfo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.defaultValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.expression = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.validations.push(FeatureValidation.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.lastFor = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.isDistancePseudofeature = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.isDeprecated = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.cacheStrategy = reader.int32() as any;
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.storeOnline = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.storeOffline = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      noDisplay: isSet(object.noDisplay) ? globalThis.Boolean(object.noDisplay) : false,
      isPrimary: isSet(object.isPrimary) ? globalThis.Boolean(object.isPrimary) : false,
      isNullable: isSet(object.isNullable) ? globalThis.Boolean(object.isNullable) : false,
      internalVersion: isSet(object.internalVersion) ? globalThis.Number(object.internalVersion) : undefined,
      maxStalenessDuration: isSet(object.maxStalenessDuration)
        ? Duration.fromJSON(object.maxStalenessDuration)
        : undefined,
      offlineTtlDuration: isSet(object.offlineTtlDuration) ? Duration.fromJSON(object.offlineTtlDuration) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      version: isSet(object.version) ? VersionInfo.fromJSON(object.version) : undefined,
      windowInfo: isSet(object.windowInfo) ? WindowInfo.fromJSON(object.windowInfo) : undefined,
      defaultValue: isSet(object.defaultValue) ? ScalarValue.fromJSON(object.defaultValue) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      expression: isSet(object.expression) ? LogicalExprNode.fromJSON(object.expression) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => FeatureValidation.fromJSON(e))
        : [],
      lastFor: isSet(object.lastFor) ? FeatureReference.fromJSON(object.lastFor) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : undefined,
      isDistancePseudofeature: isSet(object.isDistancePseudofeature)
        ? globalThis.Boolean(object.isDistancePseudofeature)
        : false,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      isDeprecated: isSet(object.isDeprecated) ? globalThis.Boolean(object.isDeprecated) : false,
      cacheStrategy: isSet(object.cacheStrategy) ? cacheStrategyFromJSON(object.cacheStrategy) : 0,
      storeOnline: isSet(object.storeOnline) ? globalThis.Boolean(object.storeOnline) : undefined,
      storeOffline: isSet(object.storeOffline) ? globalThis.Boolean(object.storeOffline) : undefined,
    };
  },

  toJSON(message: ScalarFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.noDisplay !== false) {
      obj.noDisplay = message.noDisplay;
    }
    if (message.isPrimary !== false) {
      obj.isPrimary = message.isPrimary;
    }
    if (message.isNullable !== false) {
      obj.isNullable = message.isNullable;
    }
    if (message.internalVersion !== undefined) {
      obj.internalVersion = Math.round(message.internalVersion);
    }
    if (message.maxStalenessDuration !== undefined) {
      obj.maxStalenessDuration = Duration.toJSON(message.maxStalenessDuration);
    }
    if (message.offlineTtlDuration !== undefined) {
      obj.offlineTtlDuration = Duration.toJSON(message.offlineTtlDuration);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.version !== undefined) {
      obj.version = VersionInfo.toJSON(message.version);
    }
    if (message.windowInfo !== undefined) {
      obj.windowInfo = WindowInfo.toJSON(message.windowInfo);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = ScalarValue.toJSON(message.defaultValue);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.expression !== undefined) {
      obj.expression = LogicalExprNode.toJSON(message.expression);
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => FeatureValidation.toJSON(e));
    }
    if (message.lastFor !== undefined) {
      obj.lastFor = FeatureReference.toJSON(message.lastFor);
    }
    if (message.etlOfflineToOnline !== undefined) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.isDistancePseudofeature !== false) {
      obj.isDistancePseudofeature = message.isDistancePseudofeature;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.isDeprecated !== false) {
      obj.isDeprecated = message.isDeprecated;
    }
    if (message.cacheStrategy !== 0) {
      obj.cacheStrategy = cacheStrategyToJSON(message.cacheStrategy);
    }
    if (message.storeOnline !== undefined) {
      obj.storeOnline = message.storeOnline;
    }
    if (message.storeOffline !== undefined) {
      obj.storeOffline = message.storeOffline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalarFeatureType>, I>>(base?: I): ScalarFeatureType {
    return ScalarFeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalarFeatureType>, I>>(object: I): ScalarFeatureType {
    const message = createBaseScalarFeatureType();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.isAutogenerated = object.isAutogenerated ?? false;
    message.noDisplay = object.noDisplay ?? false;
    message.isPrimary = object.isPrimary ?? false;
    message.isNullable = object.isNullable ?? false;
    message.internalVersion = object.internalVersion ?? undefined;
    message.maxStalenessDuration = (object.maxStalenessDuration !== undefined && object.maxStalenessDuration !== null)
      ? Duration.fromPartial(object.maxStalenessDuration)
      : undefined;
    message.offlineTtlDuration = (object.offlineTtlDuration !== undefined && object.offlineTtlDuration !== null)
      ? Duration.fromPartial(object.offlineTtlDuration)
      : undefined;
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? VersionInfo.fromPartial(object.version)
      : undefined;
    message.windowInfo = (object.windowInfo !== undefined && object.windowInfo !== null)
      ? WindowInfo.fromPartial(object.windowInfo)
      : undefined;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? ScalarValue.fromPartial(object.defaultValue)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.expression = (object.expression !== undefined && object.expression !== null)
      ? LogicalExprNode.fromPartial(object.expression)
      : undefined;
    message.validations = object.validations?.map((e) => FeatureValidation.fromPartial(e)) || [];
    message.lastFor = (object.lastFor !== undefined && object.lastFor !== null)
      ? FeatureReference.fromPartial(object.lastFor)
      : undefined;
    message.etlOfflineToOnline = object.etlOfflineToOnline ?? undefined;
    message.isDistancePseudofeature = object.isDistancePseudofeature ?? false;
    message.attributeName = object.attributeName ?? "";
    message.isDeprecated = object.isDeprecated ?? false;
    message.cacheStrategy = object.cacheStrategy ?? 0;
    message.storeOnline = object.storeOnline ?? undefined;
    message.storeOffline = object.storeOffline ?? undefined;
    return message;
  },
};

function createBaseHasOneFeatureType(): HasOneFeatureType {
  return {
    name: "",
    namespace: "",
    foreignNamespace: "",
    join: undefined,
    isNullable: false,
    isAutogenerated: false,
    tags: [],
    description: undefined,
    owner: undefined,
    attributeName: "",
  };
}

export const HasOneFeatureType: MessageFns<HasOneFeatureType> = {
  encode(message: HasOneFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.foreignNamespace !== "") {
      writer.uint32(26).string(message.foreignNamespace);
    }
    if (message.join !== undefined) {
      LogicalExprNode.encode(message.join, writer.uint32(34).fork()).join();
    }
    if (message.isNullable !== false) {
      writer.uint32(40).bool(message.isNullable);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(48).bool(message.isAutogenerated);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(74).string(message.owner);
    }
    if (message.attributeName !== "") {
      writer.uint32(82).string(message.attributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HasOneFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHasOneFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.foreignNamespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.join = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isNullable = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HasOneFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      foreignNamespace: isSet(object.foreignNamespace) ? globalThis.String(object.foreignNamespace) : "",
      join: isSet(object.join) ? LogicalExprNode.fromJSON(object.join) : undefined,
      isNullable: isSet(object.isNullable) ? globalThis.Boolean(object.isNullable) : false,
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
    };
  },

  toJSON(message: HasOneFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.foreignNamespace !== "") {
      obj.foreignNamespace = message.foreignNamespace;
    }
    if (message.join !== undefined) {
      obj.join = LogicalExprNode.toJSON(message.join);
    }
    if (message.isNullable !== false) {
      obj.isNullable = message.isNullable;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HasOneFeatureType>, I>>(base?: I): HasOneFeatureType {
    return HasOneFeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HasOneFeatureType>, I>>(object: I): HasOneFeatureType {
    const message = createBaseHasOneFeatureType();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.foreignNamespace = object.foreignNamespace ?? "";
    message.join = (object.join !== undefined && object.join !== null)
      ? LogicalExprNode.fromPartial(object.join)
      : undefined;
    message.isNullable = object.isNullable ?? false;
    message.isAutogenerated = object.isAutogenerated ?? false;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.attributeName = object.attributeName ?? "";
    return message;
  },
};

function createBaseHasManyFeatureType(): HasManyFeatureType {
  return {
    name: "",
    namespace: "",
    foreignNamespace: "",
    join: undefined,
    isAutogenerated: false,
    maxStalenessDuration: undefined,
    tags: [],
    description: undefined,
    owner: undefined,
    attributeName: "",
  };
}

export const HasManyFeatureType: MessageFns<HasManyFeatureType> = {
  encode(message: HasManyFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.foreignNamespace !== "") {
      writer.uint32(26).string(message.foreignNamespace);
    }
    if (message.join !== undefined) {
      LogicalExprNode.encode(message.join, writer.uint32(34).fork()).join();
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(40).bool(message.isAutogenerated);
    }
    if (message.maxStalenessDuration !== undefined) {
      Duration.encode(message.maxStalenessDuration, writer.uint32(50).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(74).string(message.owner);
    }
    if (message.attributeName !== "") {
      writer.uint32(82).string(message.attributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HasManyFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHasManyFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.foreignNamespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.join = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.maxStalenessDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HasManyFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      foreignNamespace: isSet(object.foreignNamespace) ? globalThis.String(object.foreignNamespace) : "",
      join: isSet(object.join) ? LogicalExprNode.fromJSON(object.join) : undefined,
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      maxStalenessDuration: isSet(object.maxStalenessDuration)
        ? Duration.fromJSON(object.maxStalenessDuration)
        : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
    };
  },

  toJSON(message: HasManyFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.foreignNamespace !== "") {
      obj.foreignNamespace = message.foreignNamespace;
    }
    if (message.join !== undefined) {
      obj.join = LogicalExprNode.toJSON(message.join);
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.maxStalenessDuration !== undefined) {
      obj.maxStalenessDuration = Duration.toJSON(message.maxStalenessDuration);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HasManyFeatureType>, I>>(base?: I): HasManyFeatureType {
    return HasManyFeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HasManyFeatureType>, I>>(object: I): HasManyFeatureType {
    const message = createBaseHasManyFeatureType();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.foreignNamespace = object.foreignNamespace ?? "";
    message.join = (object.join !== undefined && object.join !== null)
      ? LogicalExprNode.fromPartial(object.join)
      : undefined;
    message.isAutogenerated = object.isAutogenerated ?? false;
    message.maxStalenessDuration = (object.maxStalenessDuration !== undefined && object.maxStalenessDuration !== null)
      ? Duration.fromPartial(object.maxStalenessDuration)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.attributeName = object.attributeName ?? "";
    return message;
  },
};

function createBaseFeatureTimeFeatureType(): FeatureTimeFeatureType {
  return {
    name: "",
    namespace: "",
    isAutogenerated: false,
    tags: [],
    description: undefined,
    owner: undefined,
    attributeName: "",
  };
}

export const FeatureTimeFeatureType: MessageFns<FeatureTimeFeatureType> = {
  encode(message: FeatureTimeFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(24).bool(message.isAutogenerated);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(50).string(message.owner);
    }
    if (message.attributeName !== "") {
      writer.uint32(58).string(message.attributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureTimeFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureTimeFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureTimeFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
    };
  },

  toJSON(message: FeatureTimeFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureTimeFeatureType>, I>>(base?: I): FeatureTimeFeatureType {
    return FeatureTimeFeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureTimeFeatureType>, I>>(object: I): FeatureTimeFeatureType {
    const message = createBaseFeatureTimeFeatureType();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.isAutogenerated = object.isAutogenerated ?? false;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.attributeName = object.attributeName ?? "";
    return message;
  },
};

function createBaseWindowedFeatureType(): WindowedFeatureType {
  return { name: "", namespace: "", isAutogenerated: false, windowDurations: [], attributeName: "" };
}

export const WindowedFeatureType: MessageFns<WindowedFeatureType> = {
  encode(message: WindowedFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(24).bool(message.isAutogenerated);
    }
    for (const v of message.windowDurations) {
      Duration.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.attributeName !== "") {
      writer.uint32(42).string(message.attributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowedFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowedFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowDurations.push(Duration.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowedFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      windowDurations: globalThis.Array.isArray(object?.windowDurations)
        ? object.windowDurations.map((e: any) => Duration.fromJSON(e))
        : [],
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
    };
  },

  toJSON(message: WindowedFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.windowDurations?.length) {
      obj.windowDurations = message.windowDurations.map((e) => Duration.toJSON(e));
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowedFeatureType>, I>>(base?: I): WindowedFeatureType {
    return WindowedFeatureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowedFeatureType>, I>>(object: I): WindowedFeatureType {
    const message = createBaseWindowedFeatureType();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.isAutogenerated = object.isAutogenerated ?? false;
    message.windowDurations = object.windowDurations?.map((e) => Duration.fromPartial(e)) || [];
    message.attributeName = object.attributeName ?? "";
    return message;
  },
};

function createBaseWindowAggregation(): WindowAggregation {
  return {
    namespace: "",
    groupBy: [],
    bucketDuration: undefined,
    aggregation: "",
    aggregateOn: undefined,
    arrowType: undefined,
    filters: [],
    backfillResolver: undefined,
    backfillLookbackDuration: undefined,
    backfillStartTime: undefined,
    continuousResolver: undefined,
    continuousBufferDuration: undefined,
    backfillSchedule: undefined,
    bucketStart: undefined,
  };
}

export const WindowAggregation: MessageFns<WindowAggregation> = {
  encode(message: WindowAggregation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    for (const v of message.groupBy) {
      FeatureReference.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.bucketDuration !== undefined) {
      Duration.encode(message.bucketDuration, writer.uint32(26).fork()).join();
    }
    if (message.aggregation !== "") {
      writer.uint32(34).string(message.aggregation);
    }
    if (message.aggregateOn !== undefined) {
      FeatureReference.encode(message.aggregateOn, writer.uint32(42).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(50).fork()).join();
    }
    for (const v of message.filters) {
      LogicalExprNode.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.backfillResolver !== undefined) {
      writer.uint32(66).string(message.backfillResolver);
    }
    if (message.backfillLookbackDuration !== undefined) {
      Duration.encode(message.backfillLookbackDuration, writer.uint32(74).fork()).join();
    }
    if (message.backfillStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.backfillStartTime), writer.uint32(82).fork()).join();
    }
    if (message.continuousResolver !== undefined) {
      writer.uint32(90).string(message.continuousResolver);
    }
    if (message.continuousBufferDuration !== undefined) {
      Duration.encode(message.continuousBufferDuration, writer.uint32(98).fork()).join();
    }
    if (message.backfillSchedule !== undefined) {
      writer.uint32(106).string(message.backfillSchedule);
    }
    if (message.bucketStart !== undefined) {
      Timestamp.encode(toTimestamp(message.bucketStart), writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowAggregation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowAggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupBy.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bucketDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.aggregation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aggregateOn = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.filters.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.backfillResolver = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.backfillLookbackDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.backfillStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.continuousResolver = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.continuousBufferDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.backfillSchedule = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bucketStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowAggregation {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      groupBy: globalThis.Array.isArray(object?.groupBy)
        ? object.groupBy.map((e: any) => FeatureReference.fromJSON(e))
        : [],
      bucketDuration: isSet(object.bucketDuration) ? Duration.fromJSON(object.bucketDuration) : undefined,
      aggregation: isSet(object.aggregation) ? globalThis.String(object.aggregation) : "",
      aggregateOn: isSet(object.aggregateOn) ? FeatureReference.fromJSON(object.aggregateOn) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      backfillResolver: isSet(object.backfillResolver) ? globalThis.String(object.backfillResolver) : undefined,
      backfillLookbackDuration: isSet(object.backfillLookbackDuration)
        ? Duration.fromJSON(object.backfillLookbackDuration)
        : undefined,
      backfillStartTime: isSet(object.backfillStartTime) ? fromJsonTimestamp(object.backfillStartTime) : undefined,
      continuousResolver: isSet(object.continuousResolver) ? globalThis.String(object.continuousResolver) : undefined,
      continuousBufferDuration: isSet(object.continuousBufferDuration)
        ? Duration.fromJSON(object.continuousBufferDuration)
        : undefined,
      backfillSchedule: isSet(object.backfillSchedule) ? globalThis.String(object.backfillSchedule) : undefined,
      bucketStart: isSet(object.bucketStart) ? fromJsonTimestamp(object.bucketStart) : undefined,
    };
  },

  toJSON(message: WindowAggregation): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.groupBy?.length) {
      obj.groupBy = message.groupBy.map((e) => FeatureReference.toJSON(e));
    }
    if (message.bucketDuration !== undefined) {
      obj.bucketDuration = Duration.toJSON(message.bucketDuration);
    }
    if (message.aggregation !== "") {
      obj.aggregation = message.aggregation;
    }
    if (message.aggregateOn !== undefined) {
      obj.aggregateOn = FeatureReference.toJSON(message.aggregateOn);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.backfillResolver !== undefined) {
      obj.backfillResolver = message.backfillResolver;
    }
    if (message.backfillLookbackDuration !== undefined) {
      obj.backfillLookbackDuration = Duration.toJSON(message.backfillLookbackDuration);
    }
    if (message.backfillStartTime !== undefined) {
      obj.backfillStartTime = message.backfillStartTime.toISOString();
    }
    if (message.continuousResolver !== undefined) {
      obj.continuousResolver = message.continuousResolver;
    }
    if (message.continuousBufferDuration !== undefined) {
      obj.continuousBufferDuration = Duration.toJSON(message.continuousBufferDuration);
    }
    if (message.backfillSchedule !== undefined) {
      obj.backfillSchedule = message.backfillSchedule;
    }
    if (message.bucketStart !== undefined) {
      obj.bucketStart = message.bucketStart.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowAggregation>, I>>(base?: I): WindowAggregation {
    return WindowAggregation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowAggregation>, I>>(object: I): WindowAggregation {
    const message = createBaseWindowAggregation();
    message.namespace = object.namespace ?? "";
    message.groupBy = object.groupBy?.map((e) => FeatureReference.fromPartial(e)) || [];
    message.bucketDuration = (object.bucketDuration !== undefined && object.bucketDuration !== null)
      ? Duration.fromPartial(object.bucketDuration)
      : undefined;
    message.aggregation = object.aggregation ?? "";
    message.aggregateOn = (object.aggregateOn !== undefined && object.aggregateOn !== null)
      ? FeatureReference.fromPartial(object.aggregateOn)
      : undefined;
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    message.filters = object.filters?.map((e) => LogicalExprNode.fromPartial(e)) || [];
    message.backfillResolver = object.backfillResolver ?? undefined;
    message.backfillLookbackDuration =
      (object.backfillLookbackDuration !== undefined && object.backfillLookbackDuration !== null)
        ? Duration.fromPartial(object.backfillLookbackDuration)
        : undefined;
    message.backfillStartTime = object.backfillStartTime ?? undefined;
    message.continuousResolver = object.continuousResolver ?? undefined;
    message.continuousBufferDuration =
      (object.continuousBufferDuration !== undefined && object.continuousBufferDuration !== null)
        ? Duration.fromPartial(object.continuousBufferDuration)
        : undefined;
    message.backfillSchedule = object.backfillSchedule ?? undefined;
    message.bucketStart = object.bucketStart ?? undefined;
    return message;
  },
};

function createBaseWindowInfo(): WindowInfo {
  return { duration: undefined, aggregation: undefined };
}

export const WindowInfo: MessageFns<WindowInfo> = {
  encode(message: WindowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    if (message.aggregation !== undefined) {
      WindowAggregation.encode(message.aggregation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aggregation = WindowAggregation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowInfo {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      aggregation: isSet(object.aggregation) ? WindowAggregation.fromJSON(object.aggregation) : undefined,
    };
  },

  toJSON(message: WindowInfo): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.aggregation !== undefined) {
      obj.aggregation = WindowAggregation.toJSON(message.aggregation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowInfo>, I>>(base?: I): WindowInfo {
    return WindowInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowInfo>, I>>(object: I): WindowInfo {
    const message = createBaseWindowInfo();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.aggregation = (object.aggregation !== undefined && object.aggregation !== null)
      ? WindowAggregation.fromPartial(object.aggregation)
      : undefined;
    return message;
  },
};

function createBaseFeatureInput(): FeatureInput {
  return { feature: undefined, defaultValue: undefined };
}

export const FeatureInput: MessageFns<FeatureInput> = {
  encode(message: FeatureInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      ScalarValue.encode(message.defaultValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureInput {
    return {
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
      defaultValue: isSet(object.defaultValue) ? ScalarValue.fromJSON(object.defaultValue) : undefined,
    };
  },

  toJSON(message: FeatureInput): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = ScalarValue.toJSON(message.defaultValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureInput>, I>>(base?: I): FeatureInput {
    return FeatureInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureInput>, I>>(object: I): FeatureInput {
    const message = createBaseFeatureInput();
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? FeatureReference.fromPartial(object.feature)
      : undefined;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? ScalarValue.fromPartial(object.defaultValue)
      : undefined;
    return message;
  },
};

function createBaseResolverInput(): ResolverInput {
  return { feature: undefined, df: undefined, state: undefined };
}

export const ResolverInput: MessageFns<ResolverInput> = {
  encode(message: ResolverInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureInput.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.df !== undefined) {
      DataFrameType.encode(message.df, writer.uint32(18).fork()).join();
    }
    if (message.state !== undefined) {
      ResolverState.encode(message.state, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolverInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolverInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureInput.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.df = DataFrameType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = ResolverState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolverInput {
    return {
      feature: isSet(object.feature) ? FeatureInput.fromJSON(object.feature) : undefined,
      df: isSet(object.df) ? DataFrameType.fromJSON(object.df) : undefined,
      state: isSet(object.state) ? ResolverState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: ResolverInput): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureInput.toJSON(message.feature);
    }
    if (message.df !== undefined) {
      obj.df = DataFrameType.toJSON(message.df);
    }
    if (message.state !== undefined) {
      obj.state = ResolverState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolverInput>, I>>(base?: I): ResolverInput {
    return ResolverInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolverInput>, I>>(object: I): ResolverInput {
    const message = createBaseResolverInput();
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? FeatureInput.fromPartial(object.feature)
      : undefined;
    message.df = (object.df !== undefined && object.df !== null) ? DataFrameType.fromPartial(object.df) : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ResolverState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseResolverOutput(): ResolverOutput {
  return { feature: undefined, df: undefined };
}

export const ResolverOutput: MessageFns<ResolverOutput> = {
  encode(message: ResolverOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.df !== undefined) {
      DataFrameType.encode(message.df, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolverOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolverOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.df = DataFrameType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolverOutput {
    return {
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
      df: isSet(object.df) ? DataFrameType.fromJSON(object.df) : undefined,
    };
  },

  toJSON(message: ResolverOutput): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    if (message.df !== undefined) {
      obj.df = DataFrameType.toJSON(message.df);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolverOutput>, I>>(base?: I): ResolverOutput {
    return ResolverOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolverOutput>, I>>(object: I): ResolverOutput {
    const message = createBaseResolverOutput();
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? FeatureReference.fromPartial(object.feature)
      : undefined;
    message.df = (object.df !== undefined && object.df !== null) ? DataFrameType.fromPartial(object.df) : undefined;
    return message;
  },
};

function createBaseResolver(): Resolver {
  return {
    fqn: "",
    kind: 0,
    inputs: [],
    outputs: [],
    isGenerator: false,
    dataSources: [],
    machineType: undefined,
    tags: [],
    owner: undefined,
    doc: undefined,
    environments: [],
    timeoutDuration: undefined,
    schedule: undefined,
    when: undefined,
    cronFilter: undefined,
    function: undefined,
    resourceHint: 0,
    isStatic: false,
    isTotal: undefined,
    uniqueOn: [],
    partitionedBy: [],
    dataSourcesV2: [],
    staticOperation: undefined,
    sqlSettings: undefined,
  };
}

export const Resolver: MessageFns<Resolver> = {
  encode(message: Resolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    if (message.kind !== 0) {
      writer.uint32(16).int32(message.kind);
    }
    for (const v of message.inputs) {
      ResolverInput.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.outputs) {
      ResolverOutput.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.isGenerator !== false) {
      writer.uint32(40).bool(message.isGenerator);
    }
    for (const v of message.dataSources) {
      DatabaseSourceReference.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.machineType !== undefined) {
      writer.uint32(58).string(message.machineType);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.owner !== undefined) {
      writer.uint32(74).string(message.owner);
    }
    if (message.doc !== undefined) {
      writer.uint32(82).string(message.doc);
    }
    for (const v of message.environments) {
      writer.uint32(90).string(v!);
    }
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(98).fork()).join();
    }
    if (message.schedule !== undefined) {
      Schedule.encode(message.schedule, writer.uint32(106).fork()).join();
    }
    if (message.when !== undefined) {
      LogicalExprNode.encode(message.when, writer.uint32(114).fork()).join();
    }
    if (message.cronFilter !== undefined) {
      CronFilterWithFeatureArgs.encode(message.cronFilter, writer.uint32(122).fork()).join();
    }
    if (message.function !== undefined) {
      FunctionReference.encode(message.function, writer.uint32(130).fork()).join();
    }
    if (message.resourceHint !== 0) {
      writer.uint32(136).int32(message.resourceHint);
    }
    if (message.isStatic !== false) {
      writer.uint32(144).bool(message.isStatic);
    }
    if (message.isTotal !== undefined) {
      writer.uint32(152).bool(message.isTotal);
    }
    for (const v of message.uniqueOn) {
      writer.uint32(162).string(v!);
    }
    for (const v of message.partitionedBy) {
      writer.uint32(170).string(v!);
    }
    for (const v of message.dataSourcesV2) {
      DatabaseSourceReference3.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.staticOperation !== undefined) {
      LogicalExprNode.encode(message.staticOperation, writer.uint32(186).fork()).join();
    }
    if (message.sqlSettings !== undefined) {
      SQLResolverSettings.encode(message.sqlSettings, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(ResolverInput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputs.push(ResolverOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isGenerator = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dataSources.push(DatabaseSourceReference.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.environments.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.schedule = Schedule.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.when = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.cronFilter = CronFilterWithFeatureArgs.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.function = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.resourceHint = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isStatic = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isTotal = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.uniqueOn.push(reader.string());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.partitionedBy.push(reader.string());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.dataSourcesV2.push(DatabaseSourceReference3.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.staticOperation = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.sqlSettings = SQLResolverSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resolver {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      kind: isSet(object.kind) ? resolverKindFromJSON(object.kind) : 0,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ResolverInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => ResolverOutput.fromJSON(e))
        : [],
      isGenerator: isSet(object.isGenerator) ? globalThis.Boolean(object.isGenerator) : false,
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DatabaseSourceReference.fromJSON(e))
        : [],
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => globalThis.String(e))
        : [],
      timeoutDuration: isSet(object.timeoutDuration) ? Duration.fromJSON(object.timeoutDuration) : undefined,
      schedule: isSet(object.schedule) ? Schedule.fromJSON(object.schedule) : undefined,
      when: isSet(object.when) ? LogicalExprNode.fromJSON(object.when) : undefined,
      cronFilter: isSet(object.cronFilter) ? CronFilterWithFeatureArgs.fromJSON(object.cronFilter) : undefined,
      function: isSet(object.function) ? FunctionReference.fromJSON(object.function) : undefined,
      resourceHint: isSet(object.resourceHint) ? resourceHintFromJSON(object.resourceHint) : 0,
      isStatic: isSet(object.isStatic) ? globalThis.Boolean(object.isStatic) : false,
      isTotal: isSet(object.isTotal) ? globalThis.Boolean(object.isTotal) : undefined,
      uniqueOn: globalThis.Array.isArray(object?.uniqueOn) ? object.uniqueOn.map((e: any) => globalThis.String(e)) : [],
      partitionedBy: globalThis.Array.isArray(object?.partitionedBy)
        ? object.partitionedBy.map((e: any) => globalThis.String(e))
        : [],
      dataSourcesV2: globalThis.Array.isArray(object?.dataSourcesV2)
        ? object.dataSourcesV2.map((e: any) => DatabaseSourceReference3.fromJSON(e))
        : [],
      staticOperation: isSet(object.staticOperation) ? LogicalExprNode.fromJSON(object.staticOperation) : undefined,
      sqlSettings: isSet(object.sqlSettings) ? SQLResolverSettings.fromJSON(object.sqlSettings) : undefined,
    };
  },

  toJSON(message: Resolver): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.kind !== 0) {
      obj.kind = resolverKindToJSON(message.kind);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ResolverInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => ResolverOutput.toJSON(e));
    }
    if (message.isGenerator !== false) {
      obj.isGenerator = message.isGenerator;
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DatabaseSourceReference.toJSON(e));
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.environments?.length) {
      obj.environments = message.environments;
    }
    if (message.timeoutDuration !== undefined) {
      obj.timeoutDuration = Duration.toJSON(message.timeoutDuration);
    }
    if (message.schedule !== undefined) {
      obj.schedule = Schedule.toJSON(message.schedule);
    }
    if (message.when !== undefined) {
      obj.when = LogicalExprNode.toJSON(message.when);
    }
    if (message.cronFilter !== undefined) {
      obj.cronFilter = CronFilterWithFeatureArgs.toJSON(message.cronFilter);
    }
    if (message.function !== undefined) {
      obj.function = FunctionReference.toJSON(message.function);
    }
    if (message.resourceHint !== 0) {
      obj.resourceHint = resourceHintToJSON(message.resourceHint);
    }
    if (message.isStatic !== false) {
      obj.isStatic = message.isStatic;
    }
    if (message.isTotal !== undefined) {
      obj.isTotal = message.isTotal;
    }
    if (message.uniqueOn?.length) {
      obj.uniqueOn = message.uniqueOn;
    }
    if (message.partitionedBy?.length) {
      obj.partitionedBy = message.partitionedBy;
    }
    if (message.dataSourcesV2?.length) {
      obj.dataSourcesV2 = message.dataSourcesV2.map((e) => DatabaseSourceReference3.toJSON(e));
    }
    if (message.staticOperation !== undefined) {
      obj.staticOperation = LogicalExprNode.toJSON(message.staticOperation);
    }
    if (message.sqlSettings !== undefined) {
      obj.sqlSettings = SQLResolverSettings.toJSON(message.sqlSettings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resolver>, I>>(base?: I): Resolver {
    return Resolver.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resolver>, I>>(object: I): Resolver {
    const message = createBaseResolver();
    message.fqn = object.fqn ?? "";
    message.kind = object.kind ?? 0;
    message.inputs = object.inputs?.map((e) => ResolverInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => ResolverOutput.fromPartial(e)) || [];
    message.isGenerator = object.isGenerator ?? false;
    message.dataSources = object.dataSources?.map((e) => DatabaseSourceReference.fromPartial(e)) || [];
    message.machineType = object.machineType ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.owner = object.owner ?? undefined;
    message.doc = object.doc ?? undefined;
    message.environments = object.environments?.map((e) => e) || [];
    message.timeoutDuration = (object.timeoutDuration !== undefined && object.timeoutDuration !== null)
      ? Duration.fromPartial(object.timeoutDuration)
      : undefined;
    message.schedule = (object.schedule !== undefined && object.schedule !== null)
      ? Schedule.fromPartial(object.schedule)
      : undefined;
    message.when = (object.when !== undefined && object.when !== null)
      ? LogicalExprNode.fromPartial(object.when)
      : undefined;
    message.cronFilter = (object.cronFilter !== undefined && object.cronFilter !== null)
      ? CronFilterWithFeatureArgs.fromPartial(object.cronFilter)
      : undefined;
    message.function = (object.function !== undefined && object.function !== null)
      ? FunctionReference.fromPartial(object.function)
      : undefined;
    message.resourceHint = object.resourceHint ?? 0;
    message.isStatic = object.isStatic ?? false;
    message.isTotal = object.isTotal ?? undefined;
    message.uniqueOn = object.uniqueOn?.map((e) => e) || [];
    message.partitionedBy = object.partitionedBy?.map((e) => e) || [];
    message.dataSourcesV2 = object.dataSourcesV2?.map((e) => DatabaseSourceReference3.fromPartial(e)) || [];
    message.staticOperation = (object.staticOperation !== undefined && object.staticOperation !== null)
      ? LogicalExprNode.fromPartial(object.staticOperation)
      : undefined;
    message.sqlSettings = (object.sqlSettings !== undefined && object.sqlSettings !== null)
      ? SQLResolverSettings.fromPartial(object.sqlSettings)
      : undefined;
    return message;
  },
};

function createBaseSinkResolver(): SinkResolver {
  return {
    fqn: "",
    inputs: [],
    bufferSize: undefined,
    debounceDuration: undefined,
    maxDelayDuration: undefined,
    upsert: false,
    streamSource: undefined,
    databaseSource: undefined,
    streamSourceV2: undefined,
    databaseSourceV2: undefined,
    machineType: undefined,
    doc: undefined,
    owner: undefined,
    environments: [],
    timeoutDuration: undefined,
    function: undefined,
  };
}

export const SinkResolver: MessageFns<SinkResolver> = {
  encode(message: SinkResolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    for (const v of message.inputs) {
      ResolverInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.bufferSize !== undefined) {
      writer.uint32(24).uint64(message.bufferSize);
    }
    if (message.debounceDuration !== undefined) {
      Duration.encode(message.debounceDuration, writer.uint32(34).fork()).join();
    }
    if (message.maxDelayDuration !== undefined) {
      Duration.encode(message.maxDelayDuration, writer.uint32(42).fork()).join();
    }
    if (message.upsert !== false) {
      writer.uint32(48).bool(message.upsert);
    }
    if (message.streamSource !== undefined) {
      StreamSourceReference.encode(message.streamSource, writer.uint32(58).fork()).join();
    }
    if (message.databaseSource !== undefined) {
      DatabaseSourceReference.encode(message.databaseSource, writer.uint32(66).fork()).join();
    }
    if (message.streamSourceV2 !== undefined) {
      StreamSourceReference4.encode(message.streamSourceV2, writer.uint32(122).fork()).join();
    }
    if (message.databaseSourceV2 !== undefined) {
      DatabaseSourceReference3.encode(message.databaseSourceV2, writer.uint32(130).fork()).join();
    }
    if (message.machineType !== undefined) {
      writer.uint32(74).string(message.machineType);
    }
    if (message.doc !== undefined) {
      writer.uint32(82).string(message.doc);
    }
    if (message.owner !== undefined) {
      writer.uint32(90).string(message.owner);
    }
    for (const v of message.environments) {
      writer.uint32(98).string(v!);
    }
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(106).fork()).join();
    }
    if (message.function !== undefined) {
      FunctionReference.encode(message.function, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinkResolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinkResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ResolverInput.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bufferSize = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.debounceDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxDelayDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.upsert = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.streamSource = StreamSourceReference.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.databaseSource = DatabaseSourceReference.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.streamSourceV2 = StreamSourceReference4.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.databaseSourceV2 = DatabaseSourceReference3.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.environments.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.function = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinkResolver {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ResolverInput.fromJSON(e)) : [],
      bufferSize: isSet(object.bufferSize) ? globalThis.Number(object.bufferSize) : undefined,
      debounceDuration: isSet(object.debounceDuration) ? Duration.fromJSON(object.debounceDuration) : undefined,
      maxDelayDuration: isSet(object.maxDelayDuration) ? Duration.fromJSON(object.maxDelayDuration) : undefined,
      upsert: isSet(object.upsert) ? globalThis.Boolean(object.upsert) : false,
      streamSource: isSet(object.streamSource) ? StreamSourceReference.fromJSON(object.streamSource) : undefined,
      databaseSource: isSet(object.databaseSource)
        ? DatabaseSourceReference.fromJSON(object.databaseSource)
        : undefined,
      streamSourceV2: isSet(object.streamSourceV2) ? StreamSourceReference4.fromJSON(object.streamSourceV2) : undefined,
      databaseSourceV2: isSet(object.databaseSourceV2)
        ? DatabaseSourceReference3.fromJSON(object.databaseSourceV2)
        : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => globalThis.String(e))
        : [],
      timeoutDuration: isSet(object.timeoutDuration) ? Duration.fromJSON(object.timeoutDuration) : undefined,
      function: isSet(object.function) ? FunctionReference.fromJSON(object.function) : undefined,
    };
  },

  toJSON(message: SinkResolver): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ResolverInput.toJSON(e));
    }
    if (message.bufferSize !== undefined) {
      obj.bufferSize = Math.round(message.bufferSize);
    }
    if (message.debounceDuration !== undefined) {
      obj.debounceDuration = Duration.toJSON(message.debounceDuration);
    }
    if (message.maxDelayDuration !== undefined) {
      obj.maxDelayDuration = Duration.toJSON(message.maxDelayDuration);
    }
    if (message.upsert !== false) {
      obj.upsert = message.upsert;
    }
    if (message.streamSource !== undefined) {
      obj.streamSource = StreamSourceReference.toJSON(message.streamSource);
    }
    if (message.databaseSource !== undefined) {
      obj.databaseSource = DatabaseSourceReference.toJSON(message.databaseSource);
    }
    if (message.streamSourceV2 !== undefined) {
      obj.streamSourceV2 = StreamSourceReference4.toJSON(message.streamSourceV2);
    }
    if (message.databaseSourceV2 !== undefined) {
      obj.databaseSourceV2 = DatabaseSourceReference3.toJSON(message.databaseSourceV2);
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.environments?.length) {
      obj.environments = message.environments;
    }
    if (message.timeoutDuration !== undefined) {
      obj.timeoutDuration = Duration.toJSON(message.timeoutDuration);
    }
    if (message.function !== undefined) {
      obj.function = FunctionReference.toJSON(message.function);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SinkResolver>, I>>(base?: I): SinkResolver {
    return SinkResolver.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SinkResolver>, I>>(object: I): SinkResolver {
    const message = createBaseSinkResolver();
    message.fqn = object.fqn ?? "";
    message.inputs = object.inputs?.map((e) => ResolverInput.fromPartial(e)) || [];
    message.bufferSize = object.bufferSize ?? undefined;
    message.debounceDuration = (object.debounceDuration !== undefined && object.debounceDuration !== null)
      ? Duration.fromPartial(object.debounceDuration)
      : undefined;
    message.maxDelayDuration = (object.maxDelayDuration !== undefined && object.maxDelayDuration !== null)
      ? Duration.fromPartial(object.maxDelayDuration)
      : undefined;
    message.upsert = object.upsert ?? false;
    message.streamSource = (object.streamSource !== undefined && object.streamSource !== null)
      ? StreamSourceReference.fromPartial(object.streamSource)
      : undefined;
    message.databaseSource = (object.databaseSource !== undefined && object.databaseSource !== null)
      ? DatabaseSourceReference.fromPartial(object.databaseSource)
      : undefined;
    message.streamSourceV2 = (object.streamSourceV2 !== undefined && object.streamSourceV2 !== null)
      ? StreamSourceReference4.fromPartial(object.streamSourceV2)
      : undefined;
    message.databaseSourceV2 = (object.databaseSourceV2 !== undefined && object.databaseSourceV2 !== null)
      ? DatabaseSourceReference3.fromPartial(object.databaseSourceV2)
      : undefined;
    message.machineType = object.machineType ?? undefined;
    message.doc = object.doc ?? undefined;
    message.owner = object.owner ?? undefined;
    message.environments = object.environments?.map((e) => e) || [];
    message.timeoutDuration = (object.timeoutDuration !== undefined && object.timeoutDuration !== null)
      ? Duration.fromPartial(object.timeoutDuration)
      : undefined;
    message.function = (object.function !== undefined && object.function !== null)
      ? FunctionReference.fromPartial(object.function)
      : undefined;
    return message;
  },
};

function createBaseParseInfo(): ParseInfo {
  return {
    parseFunction: undefined,
    parseFunctionInputType: undefined,
    parseFunctionOutputType: undefined,
    isParseFunctionOutputOptional: false,
  };
}

export const ParseInfo: MessageFns<ParseInfo> = {
  encode(message: ParseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parseFunction !== undefined) {
      FunctionReference.encode(message.parseFunction, writer.uint32(10).fork()).join();
    }
    if (message.parseFunctionInputType !== undefined) {
      ArrowType.encode(message.parseFunctionInputType, writer.uint32(18).fork()).join();
    }
    if (message.parseFunctionOutputType !== undefined) {
      ArrowType.encode(message.parseFunctionOutputType, writer.uint32(26).fork()).join();
    }
    if (message.isParseFunctionOutputOptional !== false) {
      writer.uint32(32).bool(message.isParseFunctionOutputOptional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parseFunction = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parseFunctionInputType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parseFunctionOutputType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isParseFunctionOutputOptional = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseInfo {
    return {
      parseFunction: isSet(object.parseFunction) ? FunctionReference.fromJSON(object.parseFunction) : undefined,
      parseFunctionInputType: isSet(object.parseFunctionInputType)
        ? ArrowType.fromJSON(object.parseFunctionInputType)
        : undefined,
      parseFunctionOutputType: isSet(object.parseFunctionOutputType)
        ? ArrowType.fromJSON(object.parseFunctionOutputType)
        : undefined,
      isParseFunctionOutputOptional: isSet(object.isParseFunctionOutputOptional)
        ? globalThis.Boolean(object.isParseFunctionOutputOptional)
        : false,
    };
  },

  toJSON(message: ParseInfo): unknown {
    const obj: any = {};
    if (message.parseFunction !== undefined) {
      obj.parseFunction = FunctionReference.toJSON(message.parseFunction);
    }
    if (message.parseFunctionInputType !== undefined) {
      obj.parseFunctionInputType = ArrowType.toJSON(message.parseFunctionInputType);
    }
    if (message.parseFunctionOutputType !== undefined) {
      obj.parseFunctionOutputType = ArrowType.toJSON(message.parseFunctionOutputType);
    }
    if (message.isParseFunctionOutputOptional !== false) {
      obj.isParseFunctionOutputOptional = message.isParseFunctionOutputOptional;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseInfo>, I>>(base?: I): ParseInfo {
    return ParseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseInfo>, I>>(object: I): ParseInfo {
    const message = createBaseParseInfo();
    message.parseFunction = (object.parseFunction !== undefined && object.parseFunction !== null)
      ? FunctionReference.fromPartial(object.parseFunction)
      : undefined;
    message.parseFunctionInputType =
      (object.parseFunctionInputType !== undefined && object.parseFunctionInputType !== null)
        ? ArrowType.fromPartial(object.parseFunctionInputType)
        : undefined;
    message.parseFunctionOutputType =
      (object.parseFunctionOutputType !== undefined && object.parseFunctionOutputType !== null)
        ? ArrowType.fromPartial(object.parseFunctionOutputType)
        : undefined;
    message.isParseFunctionOutputOptional = object.isParseFunctionOutputOptional ?? false;
    return message;
  },
};

function createBaseStreamResolver(): StreamResolver {
  return {
    fqn: "",
    params: [],
    outputs: [],
    explicitSchema: undefined,
    keys: [],
    source: undefined,
    parseInfo: undefined,
    mode: 0,
    environments: [],
    timeoutDuration: undefined,
    timestampAttributeName: undefined,
    owner: undefined,
    doc: undefined,
    machineType: undefined,
    function: undefined,
    sourceV2: undefined,
  };
}

export const StreamResolver: MessageFns<StreamResolver> = {
  encode(message: StreamResolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    for (const v of message.params) {
      StreamResolverParam.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.outputs) {
      ResolverOutput.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.explicitSchema !== undefined) {
      ArrowType.encode(message.explicitSchema, writer.uint32(34).fork()).join();
    }
    for (const v of message.keys) {
      StreamKey.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.source !== undefined) {
      StreamSourceReference.encode(message.source, writer.uint32(50).fork()).join();
    }
    if (message.parseInfo !== undefined) {
      ParseInfo.encode(message.parseInfo, writer.uint32(58).fork()).join();
    }
    if (message.mode !== 0) {
      writer.uint32(64).int32(message.mode);
    }
    for (const v of message.environments) {
      writer.uint32(74).string(v!);
    }
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(82).fork()).join();
    }
    if (message.timestampAttributeName !== undefined) {
      writer.uint32(90).string(message.timestampAttributeName);
    }
    if (message.owner !== undefined) {
      writer.uint32(98).string(message.owner);
    }
    if (message.doc !== undefined) {
      writer.uint32(106).string(message.doc);
    }
    if (message.machineType !== undefined) {
      writer.uint32(114).string(message.machineType);
    }
    if (message.function !== undefined) {
      FunctionReference.encode(message.function, writer.uint32(122).fork()).join();
    }
    if (message.sourceV2 !== undefined) {
      StreamSourceReference4.encode(message.sourceV2, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params.push(StreamResolverParam.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputs.push(ResolverOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.explicitSchema = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.keys.push(StreamKey.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.source = StreamSourceReference.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.parseInfo = ParseInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.environments.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.timestampAttributeName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.function = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sourceV2 = StreamSourceReference4.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolver {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => StreamResolverParam.fromJSON(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => ResolverOutput.fromJSON(e))
        : [],
      explicitSchema: isSet(object.explicitSchema) ? ArrowType.fromJSON(object.explicitSchema) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => StreamKey.fromJSON(e)) : [],
      source: isSet(object.source) ? StreamSourceReference.fromJSON(object.source) : undefined,
      parseInfo: isSet(object.parseInfo) ? ParseInfo.fromJSON(object.parseInfo) : undefined,
      mode: isSet(object.mode) ? windowModeFromJSON(object.mode) : 0,
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => globalThis.String(e))
        : [],
      timeoutDuration: isSet(object.timeoutDuration) ? Duration.fromJSON(object.timeoutDuration) : undefined,
      timestampAttributeName: isSet(object.timestampAttributeName)
        ? globalThis.String(object.timestampAttributeName)
        : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      function: isSet(object.function) ? FunctionReference.fromJSON(object.function) : undefined,
      sourceV2: isSet(object.sourceV2) ? StreamSourceReference4.fromJSON(object.sourceV2) : undefined,
    };
  },

  toJSON(message: StreamResolver): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => StreamResolverParam.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => ResolverOutput.toJSON(e));
    }
    if (message.explicitSchema !== undefined) {
      obj.explicitSchema = ArrowType.toJSON(message.explicitSchema);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => StreamKey.toJSON(e));
    }
    if (message.source !== undefined) {
      obj.source = StreamSourceReference.toJSON(message.source);
    }
    if (message.parseInfo !== undefined) {
      obj.parseInfo = ParseInfo.toJSON(message.parseInfo);
    }
    if (message.mode !== 0) {
      obj.mode = windowModeToJSON(message.mode);
    }
    if (message.environments?.length) {
      obj.environments = message.environments;
    }
    if (message.timeoutDuration !== undefined) {
      obj.timeoutDuration = Duration.toJSON(message.timeoutDuration);
    }
    if (message.timestampAttributeName !== undefined) {
      obj.timestampAttributeName = message.timestampAttributeName;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.function !== undefined) {
      obj.function = FunctionReference.toJSON(message.function);
    }
    if (message.sourceV2 !== undefined) {
      obj.sourceV2 = StreamSourceReference4.toJSON(message.sourceV2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamResolver>, I>>(base?: I): StreamResolver {
    return StreamResolver.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamResolver>, I>>(object: I): StreamResolver {
    const message = createBaseStreamResolver();
    message.fqn = object.fqn ?? "";
    message.params = object.params?.map((e) => StreamResolverParam.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => ResolverOutput.fromPartial(e)) || [];
    message.explicitSchema = (object.explicitSchema !== undefined && object.explicitSchema !== null)
      ? ArrowType.fromPartial(object.explicitSchema)
      : undefined;
    message.keys = object.keys?.map((e) => StreamKey.fromPartial(e)) || [];
    message.source = (object.source !== undefined && object.source !== null)
      ? StreamSourceReference.fromPartial(object.source)
      : undefined;
    message.parseInfo = (object.parseInfo !== undefined && object.parseInfo !== null)
      ? ParseInfo.fromPartial(object.parseInfo)
      : undefined;
    message.mode = object.mode ?? 0;
    message.environments = object.environments?.map((e) => e) || [];
    message.timeoutDuration = (object.timeoutDuration !== undefined && object.timeoutDuration !== null)
      ? Duration.fromPartial(object.timeoutDuration)
      : undefined;
    message.timestampAttributeName = object.timestampAttributeName ?? undefined;
    message.owner = object.owner ?? undefined;
    message.doc = object.doc ?? undefined;
    message.machineType = object.machineType ?? undefined;
    message.function = (object.function !== undefined && object.function !== null)
      ? FunctionReference.fromPartial(object.function)
      : undefined;
    message.sourceV2 = (object.sourceV2 !== undefined && object.sourceV2 !== null)
      ? StreamSourceReference4.fromPartial(object.sourceV2)
      : undefined;
    return message;
  },
};

function createBaseResolverState(): ResolverState {
  return { initial: undefined, arrowType: undefined };
}

export const ResolverState: MessageFns<ResolverState> = {
  encode(message: ResolverState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial !== undefined) {
      ScalarValue.encode(message.initial, writer.uint32(10).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolverState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolverState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initial = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolverState {
    return {
      initial: isSet(object.initial) ? ScalarValue.fromJSON(object.initial) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: ResolverState): unknown {
    const obj: any = {};
    if (message.initial !== undefined) {
      obj.initial = ScalarValue.toJSON(message.initial);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolverState>, I>>(base?: I): ResolverState {
    return ResolverState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolverState>, I>>(object: I): ResolverState {
    const message = createBaseResolverState();
    message.initial = (object.initial !== undefined && object.initial !== null)
      ? ScalarValue.fromPartial(object.initial)
      : undefined;
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    return message;
  },
};

function createBaseStreamResolverParam(): StreamResolverParam {
  return { message: undefined, messageWindow: undefined, state: undefined };
}

export const StreamResolverParam: MessageFns<StreamResolverParam> = {
  encode(message: StreamResolverParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      StreamResolverParamMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    if (message.messageWindow !== undefined) {
      StreamResolverParamMessageWindow.encode(message.messageWindow, writer.uint32(18).fork()).join();
    }
    if (message.state !== undefined) {
      ResolverState.encode(message.state, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolverParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolverParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = StreamResolverParamMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageWindow = StreamResolverParamMessageWindow.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = ResolverState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolverParam {
    return {
      message: isSet(object.message) ? StreamResolverParamMessage.fromJSON(object.message) : undefined,
      messageWindow: isSet(object.messageWindow)
        ? StreamResolverParamMessageWindow.fromJSON(object.messageWindow)
        : undefined,
      state: isSet(object.state) ? ResolverState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: StreamResolverParam): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = StreamResolverParamMessage.toJSON(message.message);
    }
    if (message.messageWindow !== undefined) {
      obj.messageWindow = StreamResolverParamMessageWindow.toJSON(message.messageWindow);
    }
    if (message.state !== undefined) {
      obj.state = ResolverState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamResolverParam>, I>>(base?: I): StreamResolverParam {
    return StreamResolverParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamResolverParam>, I>>(object: I): StreamResolverParam {
    const message = createBaseStreamResolverParam();
    message.message = (object.message !== undefined && object.message !== null)
      ? StreamResolverParamMessage.fromPartial(object.message)
      : undefined;
    message.messageWindow = (object.messageWindow !== undefined && object.messageWindow !== null)
      ? StreamResolverParamMessageWindow.fromPartial(object.messageWindow)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ResolverState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseStreamResolverParamMessageWindow(): StreamResolverParamMessageWindow {
  return { name: "", arrowType: undefined };
}

export const StreamResolverParamMessageWindow: MessageFns<StreamResolverParamMessageWindow> = {
  encode(message: StreamResolverParamMessageWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolverParamMessageWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolverParamMessageWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolverParamMessageWindow {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: StreamResolverParamMessageWindow): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamResolverParamMessageWindow>, I>>(
    base?: I,
  ): StreamResolverParamMessageWindow {
    return StreamResolverParamMessageWindow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamResolverParamMessageWindow>, I>>(
    object: I,
  ): StreamResolverParamMessageWindow {
    const message = createBaseStreamResolverParamMessageWindow();
    message.name = object.name ?? "";
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    return message;
  },
};

function createBaseStreamResolverParamMessage(): StreamResolverParamMessage {
  return { name: "", arrowType: undefined };
}

export const StreamResolverParamMessage: MessageFns<StreamResolverParamMessage> = {
  encode(message: StreamResolverParamMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolverParamMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolverParamMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolverParamMessage {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: StreamResolverParamMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamResolverParamMessage>, I>>(base?: I): StreamResolverParamMessage {
    return StreamResolverParamMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamResolverParamMessage>, I>>(object: I): StreamResolverParamMessage {
    const message = createBaseStreamResolverParamMessage();
    message.name = object.name ?? "";
    message.arrowType = (object.arrowType !== undefined && object.arrowType !== null)
      ? ArrowType.fromPartial(object.arrowType)
      : undefined;
    return message;
  },
};

function createBaseFunctionReference(): FunctionReference {
  return { name: "", module: "", fileName: "", functionDefinition: "", sourceLine: undefined, capturedGlobals: [] };
}

export const FunctionReference: MessageFns<FunctionReference> = {
  encode(message: FunctionReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.module !== "") {
      writer.uint32(18).string(message.module);
    }
    if (message.fileName !== "") {
      writer.uint32(26).string(message.fileName);
    }
    if (message.functionDefinition !== "") {
      writer.uint32(34).string(message.functionDefinition);
    }
    if (message.sourceLine !== undefined) {
      writer.uint32(40).int32(message.sourceLine);
    }
    for (const v of message.capturedGlobals) {
      FunctionReferenceCapturedGlobal.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.functionDefinition = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sourceLine = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.capturedGlobals.push(FunctionReferenceCapturedGlobal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      functionDefinition: isSet(object.functionDefinition) ? globalThis.String(object.functionDefinition) : "",
      sourceLine: isSet(object.sourceLine) ? globalThis.Number(object.sourceLine) : undefined,
      capturedGlobals: globalThis.Array.isArray(object?.capturedGlobals)
        ? object.capturedGlobals.map((e: any) => FunctionReferenceCapturedGlobal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunctionReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.functionDefinition !== "") {
      obj.functionDefinition = message.functionDefinition;
    }
    if (message.sourceLine !== undefined) {
      obj.sourceLine = Math.round(message.sourceLine);
    }
    if (message.capturedGlobals?.length) {
      obj.capturedGlobals = message.capturedGlobals.map((e) => FunctionReferenceCapturedGlobal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionReference>, I>>(base?: I): FunctionReference {
    return FunctionReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionReference>, I>>(object: I): FunctionReference {
    const message = createBaseFunctionReference();
    message.name = object.name ?? "";
    message.module = object.module ?? "";
    message.fileName = object.fileName ?? "";
    message.functionDefinition = object.functionDefinition ?? "";
    message.sourceLine = object.sourceLine ?? undefined;
    message.capturedGlobals = object.capturedGlobals?.map((e) => FunctionReferenceCapturedGlobal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunctionReferenceCapturedGlobal(): FunctionReferenceCapturedGlobal {
  return {
    globalName: "",
    builtin: undefined,
    featureClass: undefined,
    enum: undefined,
    module: undefined,
    moduleMember: undefined,
    function: undefined,
    struct: undefined,
    variable: undefined,
    sourceReference: undefined,
  };
}

export const FunctionReferenceCapturedGlobal: MessageFns<FunctionReferenceCapturedGlobal> = {
  encode(message: FunctionReferenceCapturedGlobal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalName !== "") {
      writer.uint32(26).string(message.globalName);
    }
    if (message.builtin !== undefined) {
      FunctionGlobalCapturedBuiltin.encode(message.builtin, writer.uint32(10).fork()).join();
    }
    if (message.featureClass !== undefined) {
      FunctionGlobalCapturedFeatureClass.encode(message.featureClass, writer.uint32(18).fork()).join();
    }
    if (message.enum !== undefined) {
      FunctionGlobalCapturedEnum.encode(message.enum, writer.uint32(34).fork()).join();
    }
    if (message.module !== undefined) {
      FunctionGlobalCapturedModule.encode(message.module, writer.uint32(42).fork()).join();
    }
    if (message.moduleMember !== undefined) {
      FunctionGlobalCapturedModuleMember.encode(message.moduleMember, writer.uint32(58).fork()).join();
    }
    if (message.function !== undefined) {
      FunctionGlobalCapturedFunction.encode(message.function, writer.uint32(50).fork()).join();
    }
    if (message.struct !== undefined) {
      FunctionGlobalCapturedStruct.encode(message.struct, writer.uint32(66).fork()).join();
    }
    if (message.variable !== undefined) {
      FunctionGlobalCapturedVariable.encode(message.variable, writer.uint32(82).fork()).join();
    }
    if (message.sourceReference !== undefined) {
      SourceFileReference.encode(message.sourceReference, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionReferenceCapturedGlobal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionReferenceCapturedGlobal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.globalName = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.builtin = FunctionGlobalCapturedBuiltin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.featureClass = FunctionGlobalCapturedFeatureClass.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.enum = FunctionGlobalCapturedEnum.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.module = FunctionGlobalCapturedModule.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.moduleMember = FunctionGlobalCapturedModuleMember.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.function = FunctionGlobalCapturedFunction.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.struct = FunctionGlobalCapturedStruct.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.variable = FunctionGlobalCapturedVariable.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sourceReference = SourceFileReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionReferenceCapturedGlobal {
    return {
      globalName: isSet(object.globalName) ? globalThis.String(object.globalName) : "",
      builtin: isSet(object.builtin) ? FunctionGlobalCapturedBuiltin.fromJSON(object.builtin) : undefined,
      featureClass: isSet(object.featureClass)
        ? FunctionGlobalCapturedFeatureClass.fromJSON(object.featureClass)
        : undefined,
      enum: isSet(object.enum) ? FunctionGlobalCapturedEnum.fromJSON(object.enum) : undefined,
      module: isSet(object.module) ? FunctionGlobalCapturedModule.fromJSON(object.module) : undefined,
      moduleMember: isSet(object.moduleMember)
        ? FunctionGlobalCapturedModuleMember.fromJSON(object.moduleMember)
        : undefined,
      function: isSet(object.function) ? FunctionGlobalCapturedFunction.fromJSON(object.function) : undefined,
      struct: isSet(object.struct) ? FunctionGlobalCapturedStruct.fromJSON(object.struct) : undefined,
      variable: isSet(object.variable) ? FunctionGlobalCapturedVariable.fromJSON(object.variable) : undefined,
      sourceReference: isSet(object.sourceReference) ? SourceFileReference.fromJSON(object.sourceReference) : undefined,
    };
  },

  toJSON(message: FunctionReferenceCapturedGlobal): unknown {
    const obj: any = {};
    if (message.globalName !== "") {
      obj.globalName = message.globalName;
    }
    if (message.builtin !== undefined) {
      obj.builtin = FunctionGlobalCapturedBuiltin.toJSON(message.builtin);
    }
    if (message.featureClass !== undefined) {
      obj.featureClass = FunctionGlobalCapturedFeatureClass.toJSON(message.featureClass);
    }
    if (message.enum !== undefined) {
      obj.enum = FunctionGlobalCapturedEnum.toJSON(message.enum);
    }
    if (message.module !== undefined) {
      obj.module = FunctionGlobalCapturedModule.toJSON(message.module);
    }
    if (message.moduleMember !== undefined) {
      obj.moduleMember = FunctionGlobalCapturedModuleMember.toJSON(message.moduleMember);
    }
    if (message.function !== undefined) {
      obj.function = FunctionGlobalCapturedFunction.toJSON(message.function);
    }
    if (message.struct !== undefined) {
      obj.struct = FunctionGlobalCapturedStruct.toJSON(message.struct);
    }
    if (message.variable !== undefined) {
      obj.variable = FunctionGlobalCapturedVariable.toJSON(message.variable);
    }
    if (message.sourceReference !== undefined) {
      obj.sourceReference = SourceFileReference.toJSON(message.sourceReference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionReferenceCapturedGlobal>, I>>(base?: I): FunctionReferenceCapturedGlobal {
    return FunctionReferenceCapturedGlobal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionReferenceCapturedGlobal>, I>>(
    object: I,
  ): FunctionReferenceCapturedGlobal {
    const message = createBaseFunctionReferenceCapturedGlobal();
    message.globalName = object.globalName ?? "";
    message.builtin = (object.builtin !== undefined && object.builtin !== null)
      ? FunctionGlobalCapturedBuiltin.fromPartial(object.builtin)
      : undefined;
    message.featureClass = (object.featureClass !== undefined && object.featureClass !== null)
      ? FunctionGlobalCapturedFeatureClass.fromPartial(object.featureClass)
      : undefined;
    message.enum = (object.enum !== undefined && object.enum !== null)
      ? FunctionGlobalCapturedEnum.fromPartial(object.enum)
      : undefined;
    message.module = (object.module !== undefined && object.module !== null)
      ? FunctionGlobalCapturedModule.fromPartial(object.module)
      : undefined;
    message.moduleMember = (object.moduleMember !== undefined && object.moduleMember !== null)
      ? FunctionGlobalCapturedModuleMember.fromPartial(object.moduleMember)
      : undefined;
    message.function = (object.function !== undefined && object.function !== null)
      ? FunctionGlobalCapturedFunction.fromPartial(object.function)
      : undefined;
    message.struct = (object.struct !== undefined && object.struct !== null)
      ? FunctionGlobalCapturedStruct.fromPartial(object.struct)
      : undefined;
    message.variable = (object.variable !== undefined && object.variable !== null)
      ? FunctionGlobalCapturedVariable.fromPartial(object.variable)
      : undefined;
    message.sourceReference = (object.sourceReference !== undefined && object.sourceReference !== null)
      ? SourceFileReference.fromPartial(object.sourceReference)
      : undefined;
    return message;
  },
};

function createBaseFunctionGlobalCapturedBuiltin(): FunctionGlobalCapturedBuiltin {
  return { builtinName: "" };
}

export const FunctionGlobalCapturedBuiltin: MessageFns<FunctionGlobalCapturedBuiltin> = {
  encode(message: FunctionGlobalCapturedBuiltin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.builtinName !== "") {
      writer.uint32(10).string(message.builtinName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedBuiltin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedBuiltin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.builtinName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedBuiltin {
    return { builtinName: isSet(object.builtinName) ? globalThis.String(object.builtinName) : "" };
  },

  toJSON(message: FunctionGlobalCapturedBuiltin): unknown {
    const obj: any = {};
    if (message.builtinName !== "") {
      obj.builtinName = message.builtinName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedBuiltin>, I>>(base?: I): FunctionGlobalCapturedBuiltin {
    return FunctionGlobalCapturedBuiltin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedBuiltin>, I>>(
    object: I,
  ): FunctionGlobalCapturedBuiltin {
    const message = createBaseFunctionGlobalCapturedBuiltin();
    message.builtinName = object.builtinName ?? "";
    return message;
  },
};

function createBaseFunctionGlobalCapturedVariable(): FunctionGlobalCapturedVariable {
  return { module: "", name: "" };
}

export const FunctionGlobalCapturedVariable: MessageFns<FunctionGlobalCapturedVariable> = {
  encode(message: FunctionGlobalCapturedVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedVariable {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedVariable): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedVariable>, I>>(base?: I): FunctionGlobalCapturedVariable {
    return FunctionGlobalCapturedVariable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedVariable>, I>>(
    object: I,
  ): FunctionGlobalCapturedVariable {
    const message = createBaseFunctionGlobalCapturedVariable();
    message.module = object.module ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseFunctionGlobalCapturedStruct(): FunctionGlobalCapturedStruct {
  return { module: "", name: "", paDtype: undefined };
}

export const FunctionGlobalCapturedStruct: MessageFns<FunctionGlobalCapturedStruct> = {
  encode(message: FunctionGlobalCapturedStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.paDtype !== undefined) {
      ArrowType.encode(message.paDtype, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paDtype = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedStruct {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      paDtype: isSet(object.paDtype) ? ArrowType.fromJSON(object.paDtype) : undefined,
    };
  },

  toJSON(message: FunctionGlobalCapturedStruct): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.paDtype !== undefined) {
      obj.paDtype = ArrowType.toJSON(message.paDtype);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedStruct>, I>>(base?: I): FunctionGlobalCapturedStruct {
    return FunctionGlobalCapturedStruct.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedStruct>, I>>(object: I): FunctionGlobalCapturedStruct {
    const message = createBaseFunctionGlobalCapturedStruct();
    message.module = object.module ?? "";
    message.name = object.name ?? "";
    message.paDtype = (object.paDtype !== undefined && object.paDtype !== null)
      ? ArrowType.fromPartial(object.paDtype)
      : undefined;
    return message;
  },
};

function createBaseFunctionGlobalCapturedEnum(): FunctionGlobalCapturedEnum {
  return { module: "", name: "", memberMap: {}, bases: [] };
}

export const FunctionGlobalCapturedEnum: MessageFns<FunctionGlobalCapturedEnum> = {
  encode(message: FunctionGlobalCapturedEnum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.memberMap).forEach(([key, value]) => {
      FunctionGlobalCapturedEnum_MemberMapEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.bases) {
      ArrowType.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedEnum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedEnum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = FunctionGlobalCapturedEnum_MemberMapEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.memberMap[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bases.push(ArrowType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedEnum {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      memberMap: isObject(object.memberMap)
        ? Object.entries(object.memberMap).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      bases: globalThis.Array.isArray(object?.bases) ? object.bases.map((e: any) => ArrowType.fromJSON(e)) : [],
    };
  },

  toJSON(message: FunctionGlobalCapturedEnum): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.memberMap) {
      const entries = Object.entries(message.memberMap);
      if (entries.length > 0) {
        obj.memberMap = {};
        entries.forEach(([k, v]) => {
          obj.memberMap[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.bases?.length) {
      obj.bases = message.bases.map((e) => ArrowType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedEnum>, I>>(base?: I): FunctionGlobalCapturedEnum {
    return FunctionGlobalCapturedEnum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedEnum>, I>>(object: I): FunctionGlobalCapturedEnum {
    const message = createBaseFunctionGlobalCapturedEnum();
    message.module = object.module ?? "";
    message.name = object.name ?? "";
    message.memberMap = Object.entries(object.memberMap ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.bases = object.bases?.map((e) => ArrowType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunctionGlobalCapturedEnum_MemberMapEntry(): FunctionGlobalCapturedEnum_MemberMapEntry {
  return { key: "", value: undefined };
}

export const FunctionGlobalCapturedEnum_MemberMapEntry: MessageFns<FunctionGlobalCapturedEnum_MemberMapEntry> = {
  encode(message: FunctionGlobalCapturedEnum_MemberMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedEnum_MemberMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedEnum_MemberMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedEnum_MemberMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FunctionGlobalCapturedEnum_MemberMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedEnum_MemberMapEntry>, I>>(
    base?: I,
  ): FunctionGlobalCapturedEnum_MemberMapEntry {
    return FunctionGlobalCapturedEnum_MemberMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedEnum_MemberMapEntry>, I>>(
    object: I,
  ): FunctionGlobalCapturedEnum_MemberMapEntry {
    const message = createBaseFunctionGlobalCapturedEnum_MemberMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFunctionGlobalCapturedFeatureClass(): FunctionGlobalCapturedFeatureClass {
  return { featureClassName: "" };
}

export const FunctionGlobalCapturedFeatureClass: MessageFns<FunctionGlobalCapturedFeatureClass> = {
  encode(message: FunctionGlobalCapturedFeatureClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featureClassName !== "") {
      writer.uint32(10).string(message.featureClassName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedFeatureClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedFeatureClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureClassName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedFeatureClass {
    return { featureClassName: isSet(object.featureClassName) ? globalThis.String(object.featureClassName) : "" };
  },

  toJSON(message: FunctionGlobalCapturedFeatureClass): unknown {
    const obj: any = {};
    if (message.featureClassName !== "") {
      obj.featureClassName = message.featureClassName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedFeatureClass>, I>>(
    base?: I,
  ): FunctionGlobalCapturedFeatureClass {
    return FunctionGlobalCapturedFeatureClass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedFeatureClass>, I>>(
    object: I,
  ): FunctionGlobalCapturedFeatureClass {
    const message = createBaseFunctionGlobalCapturedFeatureClass();
    message.featureClassName = object.featureClassName ?? "";
    return message;
  },
};

function createBaseFunctionGlobalCapturedModule(): FunctionGlobalCapturedModule {
  return { name: "" };
}

export const FunctionGlobalCapturedModule: MessageFns<FunctionGlobalCapturedModule> = {
  encode(message: FunctionGlobalCapturedModule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedModule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedModule {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: FunctionGlobalCapturedModule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedModule>, I>>(base?: I): FunctionGlobalCapturedModule {
    return FunctionGlobalCapturedModule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedModule>, I>>(object: I): FunctionGlobalCapturedModule {
    const message = createBaseFunctionGlobalCapturedModule();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseFunctionGlobalCapturedModuleMember(): FunctionGlobalCapturedModuleMember {
  return { moduleName: "", qualname: "" };
}

export const FunctionGlobalCapturedModuleMember: MessageFns<FunctionGlobalCapturedModuleMember> = {
  encode(message: FunctionGlobalCapturedModuleMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.qualname !== "") {
      writer.uint32(18).string(message.qualname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedModuleMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedModuleMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.qualname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedModuleMember {
    return {
      moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
      qualname: isSet(object.qualname) ? globalThis.String(object.qualname) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedModuleMember): unknown {
    const obj: any = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.qualname !== "") {
      obj.qualname = message.qualname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedModuleMember>, I>>(
    base?: I,
  ): FunctionGlobalCapturedModuleMember {
    return FunctionGlobalCapturedModuleMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedModuleMember>, I>>(
    object: I,
  ): FunctionGlobalCapturedModuleMember {
    const message = createBaseFunctionGlobalCapturedModuleMember();
    message.moduleName = object.moduleName ?? "";
    message.qualname = object.qualname ?? "";
    return message;
  },
};

function createBaseFunctionGlobalCapturedFunction(): FunctionGlobalCapturedFunction {
  return { source: "", capturedGlobals: [], module: undefined, name: "" };
}

export const FunctionGlobalCapturedFunction: MessageFns<FunctionGlobalCapturedFunction> = {
  encode(message: FunctionGlobalCapturedFunction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    for (const v of message.capturedGlobals) {
      FunctionReferenceCapturedGlobal.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.module !== undefined) {
      writer.uint32(26).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedFunction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capturedGlobals.push(FunctionReferenceCapturedGlobal.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedFunction {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      capturedGlobals: globalThis.Array.isArray(object?.capturedGlobals)
        ? object.capturedGlobals.map((e: any) => FunctionReferenceCapturedGlobal.fromJSON(e))
        : [],
      module: isSet(object.module) ? globalThis.String(object.module) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedFunction): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.capturedGlobals?.length) {
      obj.capturedGlobals = message.capturedGlobals.map((e) => FunctionReferenceCapturedGlobal.toJSON(e));
    }
    if (message.module !== undefined) {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionGlobalCapturedFunction>, I>>(base?: I): FunctionGlobalCapturedFunction {
    return FunctionGlobalCapturedFunction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionGlobalCapturedFunction>, I>>(
    object: I,
  ): FunctionGlobalCapturedFunction {
    const message = createBaseFunctionGlobalCapturedFunction();
    message.source = object.source ?? "";
    message.capturedGlobals = object.capturedGlobals?.map((e) => FunctionReferenceCapturedGlobal.fromPartial(e)) || [];
    message.module = object.module ?? undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSourceFileReference(): SourceFileReference {
  return { range: undefined, code: undefined, fileName: "" };
}

export const SourceFileReference: MessageFns<SourceFileReference> = {
  encode(message: SourceFileReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      Range.encode(message.range, writer.uint32(10).fork()).join();
    }
    if (message.code !== undefined) {
      writer.uint32(18).string(message.code);
    }
    if (message.fileName !== "") {
      writer.uint32(26).string(message.fileName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceFileReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceFileReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = Range.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceFileReference {
    return {
      range: isSet(object.range) ? Range.fromJSON(object.range) : undefined,
      code: isSet(object.code) ? globalThis.String(object.code) : undefined,
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
    };
  },

  toJSON(message: SourceFileReference): unknown {
    const obj: any = {};
    if (message.range !== undefined) {
      obj.range = Range.toJSON(message.range);
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceFileReference>, I>>(base?: I): SourceFileReference {
    return SourceFileReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceFileReference>, I>>(object: I): SourceFileReference {
    const message = createBaseSourceFileReference();
    message.range = (object.range !== undefined && object.range !== null) ? Range.fromPartial(object.range) : undefined;
    message.code = object.code ?? undefined;
    message.fileName = object.fileName ?? "";
    return message;
  },
};

function createBaseStreamKey(): StreamKey {
  return { key: "", feature: undefined };
}

export const StreamKey: MessageFns<StreamKey> = {
  encode(message: StreamKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
    };
  },

  toJSON(message: StreamKey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamKey>, I>>(base?: I): StreamKey {
    return StreamKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamKey>, I>>(object: I): StreamKey {
    const message = createBaseStreamKey();
    message.key = object.key ?? "";
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? FeatureReference.fromPartial(object.feature)
      : undefined;
    return message;
  },
};

function createBaseSQLResolverSettings(): SQLResolverSettings {
  return { finalizer: 0, incrementalSettings: undefined, fieldsRootFqn: {} };
}

export const SQLResolverSettings: MessageFns<SQLResolverSettings> = {
  encode(message: SQLResolverSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalizer !== 0) {
      writer.uint32(8).int32(message.finalizer);
    }
    if (message.incrementalSettings !== undefined) {
      IncrementalSettings.encode(message.incrementalSettings, writer.uint32(18).fork()).join();
    }
    Object.entries(message.fieldsRootFqn).forEach(([key, value]) => {
      SQLResolverSettings_FieldsRootFqnEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.finalizer = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.incrementalSettings = IncrementalSettings.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SQLResolverSettings_FieldsRootFqnEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fieldsRootFqn[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverSettings {
    return {
      finalizer: isSet(object.finalizer) ? finalizerFromJSON(object.finalizer) : 0,
      incrementalSettings: isSet(object.incrementalSettings)
        ? IncrementalSettings.fromJSON(object.incrementalSettings)
        : undefined,
      fieldsRootFqn: isObject(object.fieldsRootFqn)
        ? Object.entries(object.fieldsRootFqn).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SQLResolverSettings): unknown {
    const obj: any = {};
    if (message.finalizer !== 0) {
      obj.finalizer = finalizerToJSON(message.finalizer);
    }
    if (message.incrementalSettings !== undefined) {
      obj.incrementalSettings = IncrementalSettings.toJSON(message.incrementalSettings);
    }
    if (message.fieldsRootFqn) {
      const entries = Object.entries(message.fieldsRootFqn);
      if (entries.length > 0) {
        obj.fieldsRootFqn = {};
        entries.forEach(([k, v]) => {
          obj.fieldsRootFqn[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SQLResolverSettings>, I>>(base?: I): SQLResolverSettings {
    return SQLResolverSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SQLResolverSettings>, I>>(object: I): SQLResolverSettings {
    const message = createBaseSQLResolverSettings();
    message.finalizer = object.finalizer ?? 0;
    message.incrementalSettings = (object.incrementalSettings !== undefined && object.incrementalSettings !== null)
      ? IncrementalSettings.fromPartial(object.incrementalSettings)
      : undefined;
    message.fieldsRootFqn = Object.entries(object.fieldsRootFqn ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSQLResolverSettings_FieldsRootFqnEntry(): SQLResolverSettings_FieldsRootFqnEntry {
  return { key: "", value: "" };
}

export const SQLResolverSettings_FieldsRootFqnEntry: MessageFns<SQLResolverSettings_FieldsRootFqnEntry> = {
  encode(message: SQLResolverSettings_FieldsRootFqnEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverSettings_FieldsRootFqnEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverSettings_FieldsRootFqnEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverSettings_FieldsRootFqnEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SQLResolverSettings_FieldsRootFqnEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SQLResolverSettings_FieldsRootFqnEntry>, I>>(
    base?: I,
  ): SQLResolverSettings_FieldsRootFqnEntry {
    return SQLResolverSettings_FieldsRootFqnEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SQLResolverSettings_FieldsRootFqnEntry>, I>>(
    object: I,
  ): SQLResolverSettings_FieldsRootFqnEntry {
    const message = createBaseSQLResolverSettings_FieldsRootFqnEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIncrementalSettings(): IncrementalSettings {
  return { mode: 0, lookbackPeriod: undefined, incrementalColumn: undefined, timestampMode: 0 };
}

export const IncrementalSettings: MessageFns<IncrementalSettings> = {
  encode(message: IncrementalSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.lookbackPeriod !== undefined) {
      Duration.encode(message.lookbackPeriod, writer.uint32(18).fork()).join();
    }
    if (message.incrementalColumn !== undefined) {
      writer.uint32(26).string(message.incrementalColumn);
    }
    if (message.timestampMode !== 0) {
      writer.uint32(32).int32(message.timestampMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncrementalSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncrementalSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lookbackPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.incrementalColumn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestampMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncrementalSettings {
    return {
      mode: isSet(object.mode) ? incrementalModeFromJSON(object.mode) : 0,
      lookbackPeriod: isSet(object.lookbackPeriod) ? Duration.fromJSON(object.lookbackPeriod) : undefined,
      incrementalColumn: isSet(object.incrementalColumn) ? globalThis.String(object.incrementalColumn) : undefined,
      timestampMode: isSet(object.timestampMode) ? incrementalTimestampModeFromJSON(object.timestampMode) : 0,
    };
  },

  toJSON(message: IncrementalSettings): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = incrementalModeToJSON(message.mode);
    }
    if (message.lookbackPeriod !== undefined) {
      obj.lookbackPeriod = Duration.toJSON(message.lookbackPeriod);
    }
    if (message.incrementalColumn !== undefined) {
      obj.incrementalColumn = message.incrementalColumn;
    }
    if (message.timestampMode !== 0) {
      obj.timestampMode = incrementalTimestampModeToJSON(message.timestampMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncrementalSettings>, I>>(base?: I): IncrementalSettings {
    return IncrementalSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncrementalSettings>, I>>(object: I): IncrementalSettings {
    const message = createBaseIncrementalSettings();
    message.mode = object.mode ?? 0;
    message.lookbackPeriod = (object.lookbackPeriod !== undefined && object.lookbackPeriod !== null)
      ? Duration.fromPartial(object.lookbackPeriod)
      : undefined;
    message.incrementalColumn = object.incrementalColumn ?? undefined;
    message.timestampMode = object.timestampMode ?? 0;
    return message;
  },
};

function createBaseCronFilterWithFeatureArgs(): CronFilterWithFeatureArgs {
  return { filter: undefined, args: [] };
}

export const CronFilterWithFeatureArgs: MessageFns<CronFilterWithFeatureArgs> = {
  encode(message: CronFilterWithFeatureArgs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      FunctionReference.encode(message.filter, writer.uint32(10).fork()).join();
    }
    for (const v of message.args) {
      FeatureReference.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronFilterWithFeatureArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronFilterWithFeatureArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronFilterWithFeatureArgs {
    return {
      filter: isSet(object.filter) ? FunctionReference.fromJSON(object.filter) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => FeatureReference.fromJSON(e)) : [],
    };
  },

  toJSON(message: CronFilterWithFeatureArgs): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = FunctionReference.toJSON(message.filter);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => FeatureReference.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronFilterWithFeatureArgs>, I>>(base?: I): CronFilterWithFeatureArgs {
    return CronFilterWithFeatureArgs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronFilterWithFeatureArgs>, I>>(object: I): CronFilterWithFeatureArgs {
    const message = createBaseCronFilterWithFeatureArgs();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? FunctionReference.fromPartial(object.filter)
      : undefined;
    message.args = object.args?.map((e) => FeatureReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchedule(): Schedule {
  return { crontab: undefined, duration: undefined, filter: undefined, sample: undefined };
}

export const Schedule: MessageFns<Schedule> = {
  encode(message: Schedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crontab !== undefined) {
      writer.uint32(10).string(message.crontab);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.filter !== undefined) {
      FunctionReference.encode(message.filter, writer.uint32(26).fork()).join();
    }
    if (message.sample !== undefined) {
      FunctionReference.encode(message.sample, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.crontab = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sample = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schedule {
    return {
      crontab: isSet(object.crontab) ? globalThis.String(object.crontab) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      filter: isSet(object.filter) ? FunctionReference.fromJSON(object.filter) : undefined,
      sample: isSet(object.sample) ? FunctionReference.fromJSON(object.sample) : undefined,
    };
  },

  toJSON(message: Schedule): unknown {
    const obj: any = {};
    if (message.crontab !== undefined) {
      obj.crontab = message.crontab;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.filter !== undefined) {
      obj.filter = FunctionReference.toJSON(message.filter);
    }
    if (message.sample !== undefined) {
      obj.sample = FunctionReference.toJSON(message.sample);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schedule>, I>>(base?: I): Schedule {
    return Schedule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schedule>, I>>(object: I): Schedule {
    const message = createBaseSchedule();
    message.crontab = object.crontab ?? undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? FunctionReference.fromPartial(object.filter)
      : undefined;
    message.sample = (object.sample !== undefined && object.sample !== null)
      ? FunctionReference.fromPartial(object.sample)
      : undefined;
    return message;
  },
};

function createBaseFeatureValidation(): FeatureValidation {
  return {
    min: undefined,
    max: undefined,
    minLength: undefined,
    maxLength: undefined,
    minArrow: undefined,
    maxArrow: undefined,
    minLengthArrow: undefined,
    maxLengthArrow: undefined,
    contains: undefined,
    strict: false,
  };
}

export const FeatureValidation: MessageFns<FeatureValidation> = {
  encode(message: FeatureValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== undefined) {
      writer.uint32(21).float(message.max);
    }
    if (message.minLength !== undefined) {
      writer.uint32(24).uint32(message.minLength);
    }
    if (message.maxLength !== undefined) {
      writer.uint32(32).uint32(message.maxLength);
    }
    if (message.minArrow !== undefined) {
      ScalarValue.encode(message.minArrow, writer.uint32(50).fork()).join();
    }
    if (message.maxArrow !== undefined) {
      ScalarValue.encode(message.maxArrow, writer.uint32(58).fork()).join();
    }
    if (message.minLengthArrow !== undefined) {
      ScalarValue.encode(message.minLengthArrow, writer.uint32(66).fork()).join();
    }
    if (message.maxLengthArrow !== undefined) {
      ScalarValue.encode(message.maxLengthArrow, writer.uint32(74).fork()).join();
    }
    if (message.contains !== undefined) {
      ScalarValue.encode(message.contains, writer.uint32(82).fork()).join();
    }
    if (message.strict !== false) {
      writer.uint32(40).bool(message.strict);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minLength = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxLength = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.minArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.minLengthArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.maxLengthArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.contains = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.strict = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureValidation {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : undefined,
      max: isSet(object.max) ? globalThis.Number(object.max) : undefined,
      minLength: isSet(object.minLength) ? globalThis.Number(object.minLength) : undefined,
      maxLength: isSet(object.maxLength) ? globalThis.Number(object.maxLength) : undefined,
      minArrow: isSet(object.minArrow) ? ScalarValue.fromJSON(object.minArrow) : undefined,
      maxArrow: isSet(object.maxArrow) ? ScalarValue.fromJSON(object.maxArrow) : undefined,
      minLengthArrow: isSet(object.minLengthArrow) ? ScalarValue.fromJSON(object.minLengthArrow) : undefined,
      maxLengthArrow: isSet(object.maxLengthArrow) ? ScalarValue.fromJSON(object.maxLengthArrow) : undefined,
      contains: isSet(object.contains) ? ScalarValue.fromJSON(object.contains) : undefined,
      strict: isSet(object.strict) ? globalThis.Boolean(object.strict) : false,
    };
  },

  toJSON(message: FeatureValidation): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = message.min;
    }
    if (message.max !== undefined) {
      obj.max = message.max;
    }
    if (message.minLength !== undefined) {
      obj.minLength = Math.round(message.minLength);
    }
    if (message.maxLength !== undefined) {
      obj.maxLength = Math.round(message.maxLength);
    }
    if (message.minArrow !== undefined) {
      obj.minArrow = ScalarValue.toJSON(message.minArrow);
    }
    if (message.maxArrow !== undefined) {
      obj.maxArrow = ScalarValue.toJSON(message.maxArrow);
    }
    if (message.minLengthArrow !== undefined) {
      obj.minLengthArrow = ScalarValue.toJSON(message.minLengthArrow);
    }
    if (message.maxLengthArrow !== undefined) {
      obj.maxLengthArrow = ScalarValue.toJSON(message.maxLengthArrow);
    }
    if (message.contains !== undefined) {
      obj.contains = ScalarValue.toJSON(message.contains);
    }
    if (message.strict !== false) {
      obj.strict = message.strict;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeatureValidation>, I>>(base?: I): FeatureValidation {
    return FeatureValidation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeatureValidation>, I>>(object: I): FeatureValidation {
    const message = createBaseFeatureValidation();
    message.min = object.min ?? undefined;
    message.max = object.max ?? undefined;
    message.minLength = object.minLength ?? undefined;
    message.maxLength = object.maxLength ?? undefined;
    message.minArrow = (object.minArrow !== undefined && object.minArrow !== null)
      ? ScalarValue.fromPartial(object.minArrow)
      : undefined;
    message.maxArrow = (object.maxArrow !== undefined && object.maxArrow !== null)
      ? ScalarValue.fromPartial(object.maxArrow)
      : undefined;
    message.minLengthArrow = (object.minLengthArrow !== undefined && object.minLengthArrow !== null)
      ? ScalarValue.fromPartial(object.minLengthArrow)
      : undefined;
    message.maxLengthArrow = (object.maxLengthArrow !== undefined && object.maxLengthArrow !== null)
      ? ScalarValue.fromPartial(object.maxLengthArrow)
      : undefined;
    message.contains = (object.contains !== undefined && object.contains !== null)
      ? ScalarValue.fromPartial(object.contains)
      : undefined;
    message.strict = object.strict ?? false;
    return message;
  },
};

function createBaseVersionInfo(): VersionInfo {
  return { default: 0, maximum: 0 };
}

export const VersionInfo: MessageFns<VersionInfo> = {
  encode(message: VersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.default !== 0) {
      writer.uint32(8).uint32(message.default);
    }
    if (message.maximum !== 0) {
      writer.uint32(16).uint32(message.maximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.default = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maximum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionInfo {
    return {
      default: isSet(object.default) ? globalThis.Number(object.default) : 0,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : 0,
    };
  },

  toJSON(message: VersionInfo): unknown {
    const obj: any = {};
    if (message.default !== 0) {
      obj.default = Math.round(message.default);
    }
    if (message.maximum !== 0) {
      obj.maximum = Math.round(message.maximum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionInfo>, I>>(base?: I): VersionInfo {
    return VersionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionInfo>, I>>(object: I): VersionInfo {
    const message = createBaseVersionInfo();
    message.default = object.default ?? 0;
    message.maximum = object.maximum ?? 0;
    return message;
  },
};

function createBaseStrictValidation(): StrictValidation {
  return { feature: undefined, validations: [] };
}

export const StrictValidation: MessageFns<StrictValidation> = {
  encode(message: StrictValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(10).fork()).join();
    }
    for (const v of message.validations) {
      FeatureValidation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrictValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrictValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validations.push(FeatureValidation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrictValidation {
    return {
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => FeatureValidation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrictValidation): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => FeatureValidation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StrictValidation>, I>>(base?: I): StrictValidation {
    return StrictValidation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StrictValidation>, I>>(object: I): StrictValidation {
    const message = createBaseStrictValidation();
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? FeatureReference.fromPartial(object.feature)
      : undefined;
    message.validations = object.validations?.map((e) => FeatureValidation.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
