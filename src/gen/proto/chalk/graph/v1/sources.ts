// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/graph/v1/sources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration";
import { ScalarValue } from "../../arrow/v1/arrow";

export const protobufPackage = "chalk.graph.v1";

export enum StreamSourceType {
  STREAM_SOURCE_TYPE_UNSPECIFIED = 0,
  STREAM_SOURCE_TYPE_KAFKA = 1,
  STREAM_SOURCE_TYPE_KINESIS = 2,
  STREAM_SOURCE_TYPE_PUBSUB = 3,
  UNRECOGNIZED = -1,
}

export function streamSourceTypeFromJSON(object: any): StreamSourceType {
  switch (object) {
    case 0:
    case "STREAM_SOURCE_TYPE_UNSPECIFIED":
      return StreamSourceType.STREAM_SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "STREAM_SOURCE_TYPE_KAFKA":
      return StreamSourceType.STREAM_SOURCE_TYPE_KAFKA;
    case 2:
    case "STREAM_SOURCE_TYPE_KINESIS":
      return StreamSourceType.STREAM_SOURCE_TYPE_KINESIS;
    case 3:
    case "STREAM_SOURCE_TYPE_PUBSUB":
      return StreamSourceType.STREAM_SOURCE_TYPE_PUBSUB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamSourceType.UNRECOGNIZED;
  }
}

export function streamSourceTypeToJSON(object: StreamSourceType): string {
  switch (object) {
    case StreamSourceType.STREAM_SOURCE_TYPE_UNSPECIFIED:
      return "STREAM_SOURCE_TYPE_UNSPECIFIED";
    case StreamSourceType.STREAM_SOURCE_TYPE_KAFKA:
      return "STREAM_SOURCE_TYPE_KAFKA";
    case StreamSourceType.STREAM_SOURCE_TYPE_KINESIS:
      return "STREAM_SOURCE_TYPE_KINESIS";
    case StreamSourceType.STREAM_SOURCE_TYPE_PUBSUB:
      return "STREAM_SOURCE_TYPE_PUBSUB";
    case StreamSourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DatabaseSourceType {
  DATABASE_SOURCE_TYPE_UNSPECIFIED = 0,
  DATABASE_SOURCE_TYPE_BIGQUERY = 1,
  DATABASE_SOURCE_TYPE_CLOUDSQL = 2,
  DATABASE_SOURCE_TYPE_DATABRICKS = 3,
  DATABASE_SOURCE_TYPE_MYSQL = 4,
  DATABASE_SOURCE_TYPE_POSTGRES = 5,
  DATABASE_SOURCE_TYPE_REDSHIFT = 6,
  DATABASE_SOURCE_TYPE_SNOWFLAKE = 7,
  DATABASE_SOURCE_TYPE_SQLITE = 8,
  DATABASE_SOURCE_TYPE_SPANNER = 9,
  DATABASE_SOURCE_TYPE_TRINO = 10,
  DATABASE_SOURCE_TYPE_DYNAMODB = 11,
  DATABASE_SOURCE_TYPE_ATHENA = 12,
  UNRECOGNIZED = -1,
}

export function databaseSourceTypeFromJSON(object: any): DatabaseSourceType {
  switch (object) {
    case 0:
    case "DATABASE_SOURCE_TYPE_UNSPECIFIED":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "DATABASE_SOURCE_TYPE_BIGQUERY":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_BIGQUERY;
    case 2:
    case "DATABASE_SOURCE_TYPE_CLOUDSQL":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_CLOUDSQL;
    case 3:
    case "DATABASE_SOURCE_TYPE_DATABRICKS":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_DATABRICKS;
    case 4:
    case "DATABASE_SOURCE_TYPE_MYSQL":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_MYSQL;
    case 5:
    case "DATABASE_SOURCE_TYPE_POSTGRES":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_POSTGRES;
    case 6:
    case "DATABASE_SOURCE_TYPE_REDSHIFT":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_REDSHIFT;
    case 7:
    case "DATABASE_SOURCE_TYPE_SNOWFLAKE":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_SNOWFLAKE;
    case 8:
    case "DATABASE_SOURCE_TYPE_SQLITE":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_SQLITE;
    case 9:
    case "DATABASE_SOURCE_TYPE_SPANNER":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_SPANNER;
    case 10:
    case "DATABASE_SOURCE_TYPE_TRINO":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_TRINO;
    case 11:
    case "DATABASE_SOURCE_TYPE_DYNAMODB":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_DYNAMODB;
    case 12:
    case "DATABASE_SOURCE_TYPE_ATHENA":
      return DatabaseSourceType.DATABASE_SOURCE_TYPE_ATHENA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseSourceType.UNRECOGNIZED;
  }
}

export function databaseSourceTypeToJSON(object: DatabaseSourceType): string {
  switch (object) {
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_UNSPECIFIED:
      return "DATABASE_SOURCE_TYPE_UNSPECIFIED";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_BIGQUERY:
      return "DATABASE_SOURCE_TYPE_BIGQUERY";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_CLOUDSQL:
      return "DATABASE_SOURCE_TYPE_CLOUDSQL";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_DATABRICKS:
      return "DATABASE_SOURCE_TYPE_DATABRICKS";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_MYSQL:
      return "DATABASE_SOURCE_TYPE_MYSQL";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_POSTGRES:
      return "DATABASE_SOURCE_TYPE_POSTGRES";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_REDSHIFT:
      return "DATABASE_SOURCE_TYPE_REDSHIFT";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_SNOWFLAKE:
      return "DATABASE_SOURCE_TYPE_SNOWFLAKE";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_SQLITE:
      return "DATABASE_SOURCE_TYPE_SQLITE";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_SPANNER:
      return "DATABASE_SOURCE_TYPE_SPANNER";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_TRINO:
      return "DATABASE_SOURCE_TYPE_TRINO";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_DYNAMODB:
      return "DATABASE_SOURCE_TYPE_DYNAMODB";
    case DatabaseSourceType.DATABASE_SOURCE_TYPE_ATHENA:
      return "DATABASE_SOURCE_TYPE_ATHENA";
    case DatabaseSourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface StreamSourceReference {
  type: StreamSourceType;
  name: string;
}

export interface StreamSource {
  kafka?: KafkaSource | undefined;
  kinesis?: KinesisSource | undefined;
  pubsub?: PubSubSource | undefined;
}

export interface KinesisSource {
  name: string;
  streamName: string;
  streamArn: string;
  regionName: string;
  lateArrivalDeadline: Duration | undefined;
  deadLetterQueueStreamName: string;
  awsAccessKeyId: string;
  awsSecretAccessKey: string;
  awsSessionToken: string;
  endpointUrl: string;
  consumerRoleArn: string;
}

export interface KafkaSource {
  name: string;
  bootstrapServers: string[];
  topic: string;
  sslKeystoreLocation: string;
  sslCaFile: string;
  clientIdPrefix: string;
  groupIdPrefix: string;
  securityProtocol: string;
  saslMechanism: string;
  saslUsername: string;
  saslPassword: string;
  lateArrivalDeadline: Duration | undefined;
  deadLetterQueueTopic: string;
}

export interface PubSubSource {
  name: string;
  projectId: string;
  subscriptionId: string;
  lateArrivalDeadline: Duration | undefined;
  deadLetterQueueTopic: string;
}

export interface DatabaseSourceReference {
  type: DatabaseSourceType;
  name: string;
}

export interface DatabaseSource {
  bigquery?: BigQuerySource | undefined;
  cloudsql?: CloudSQLSource | undefined;
  databricks?: DatabricksSource | undefined;
  mysql?: MySQLSource | undefined;
  postgres?: PostgresSource | undefined;
  redshift?: RedshiftSource | undefined;
  snowflake?: SnowflakeSource | undefined;
  sqlite?: SQLiteSource | undefined;
  spanner?: SpannerSource | undefined;
  trino?: TrinoSource | undefined;
  dynamodb?: DynamoDBSource | undefined;
  athena?: AthenaSource | undefined;
}

export interface BigQuerySource {
  name: string;
  project: string;
  dataset: string;
  location: string;
  credentialsBase64: string;
  credentialsPath: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface BigQuerySource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface BigQuerySource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface CloudSQLSource {
  name: string;
  db: string;
  user: string;
  password: string;
  instanceName: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface CloudSQLSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface CloudSQLSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface DatabricksSource {
  name: string;
  host: string;
  port: string;
  db: string;
  httpPath: string;
  accessToken: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface DatabricksSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface DatabricksSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface DynamoDBSource {
  name: string;
  awsClientIdOverride?: string | undefined;
  awsClientSecretOverride?: string | undefined;
  awsRegionOverride?: string | undefined;
  endpointOverride?: string | undefined;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface DynamoDBSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface DynamoDBSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface MySQLSource {
  name: string;
  host: string;
  port: string;
  db: string;
  user: string;
  password: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface MySQLSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface MySQLSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface PostgresSource {
  name: string;
  host: string;
  port: string;
  db: string;
  user: string;
  password: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface PostgresSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface PostgresSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface RedshiftSource {
  name: string;
  host: string;
  port: string;
  db: string;
  user: string;
  password: string;
  s3Client: string;
  s3Bucket: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
  unloadIamRole: string;
}

export interface RedshiftSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface RedshiftSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface SnowflakeSource {
  name: string;
  db: string;
  schema: string;
  role: string;
  user: string;
  password: string;
  accountIdentifier: string;
  warehouse: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
  privateKeyB64: string;
}

export interface SnowflakeSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface SnowflakeSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface SQLiteSource {
  name: string;
  fileName: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface SQLiteSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface SQLiteSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface SpannerSource {
  name: string;
  project: string;
  instance: string;
  db: string;
  credentialsBase64: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface SpannerSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface SpannerSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface TrinoSource {
  name: string;
  host: string;
  port: string;
  catalog: string;
  schema: string;
  user: string;
  password: string;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
}

export interface TrinoSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface TrinoSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface AthenaSource {
  name: string;
  awsRegion: string;
  awsAccessKeyId?: string | undefined;
  awsAccessKeySecret?: string | undefined;
  s3StagingDir: string;
  catalogName?: string | undefined;
  schemaName?: string | undefined;
  roleArn?: string | undefined;
  engineArgs: { [key: string]: ScalarValue };
  asyncEngineArgs: { [key: string]: ScalarValue };
  workGroup?: string | undefined;
}

export interface AthenaSource_EngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface AthenaSource_AsyncEngineArgsEntry {
  key: string;
  value: ScalarValue | undefined;
}

function createBaseStreamSourceReference(): StreamSourceReference {
  return { type: 0, name: "" };
}

export const StreamSourceReference: MessageFns<StreamSourceReference> = {
  encode(message: StreamSourceReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamSourceReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSourceReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamSourceReference {
    return {
      type: isSet(object.type) ? streamSourceTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: StreamSourceReference): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = streamSourceTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamSourceReference>, I>>(base?: I): StreamSourceReference {
    return StreamSourceReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamSourceReference>, I>>(object: I): StreamSourceReference {
    const message = createBaseStreamSourceReference();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStreamSource(): StreamSource {
  return { kafka: undefined, kinesis: undefined, pubsub: undefined };
}

export const StreamSource: MessageFns<StreamSource> = {
  encode(message: StreamSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kafka !== undefined) {
      KafkaSource.encode(message.kafka, writer.uint32(10).fork()).join();
    }
    if (message.kinesis !== undefined) {
      KinesisSource.encode(message.kinesis, writer.uint32(18).fork()).join();
    }
    if (message.pubsub !== undefined) {
      PubSubSource.encode(message.pubsub, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kafka = KafkaSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kinesis = KinesisSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pubsub = PubSubSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamSource {
    return {
      kafka: isSet(object.kafka) ? KafkaSource.fromJSON(object.kafka) : undefined,
      kinesis: isSet(object.kinesis) ? KinesisSource.fromJSON(object.kinesis) : undefined,
      pubsub: isSet(object.pubsub) ? PubSubSource.fromJSON(object.pubsub) : undefined,
    };
  },

  toJSON(message: StreamSource): unknown {
    const obj: any = {};
    if (message.kafka !== undefined) {
      obj.kafka = KafkaSource.toJSON(message.kafka);
    }
    if (message.kinesis !== undefined) {
      obj.kinesis = KinesisSource.toJSON(message.kinesis);
    }
    if (message.pubsub !== undefined) {
      obj.pubsub = PubSubSource.toJSON(message.pubsub);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamSource>, I>>(base?: I): StreamSource {
    return StreamSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamSource>, I>>(object: I): StreamSource {
    const message = createBaseStreamSource();
    message.kafka = (object.kafka !== undefined && object.kafka !== null)
      ? KafkaSource.fromPartial(object.kafka)
      : undefined;
    message.kinesis = (object.kinesis !== undefined && object.kinesis !== null)
      ? KinesisSource.fromPartial(object.kinesis)
      : undefined;
    message.pubsub = (object.pubsub !== undefined && object.pubsub !== null)
      ? PubSubSource.fromPartial(object.pubsub)
      : undefined;
    return message;
  },
};

function createBaseKinesisSource(): KinesisSource {
  return {
    name: "",
    streamName: "",
    streamArn: "",
    regionName: "",
    lateArrivalDeadline: undefined,
    deadLetterQueueStreamName: "",
    awsAccessKeyId: "",
    awsSecretAccessKey: "",
    awsSessionToken: "",
    endpointUrl: "",
    consumerRoleArn: "",
  };
}

export const KinesisSource: MessageFns<KinesisSource> = {
  encode(message: KinesisSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.streamName !== "") {
      writer.uint32(18).string(message.streamName);
    }
    if (message.streamArn !== "") {
      writer.uint32(26).string(message.streamArn);
    }
    if (message.regionName !== "") {
      writer.uint32(34).string(message.regionName);
    }
    if (message.lateArrivalDeadline !== undefined) {
      Duration.encode(message.lateArrivalDeadline, writer.uint32(42).fork()).join();
    }
    if (message.deadLetterQueueStreamName !== "") {
      writer.uint32(50).string(message.deadLetterQueueStreamName);
    }
    if (message.awsAccessKeyId !== "") {
      writer.uint32(58).string(message.awsAccessKeyId);
    }
    if (message.awsSecretAccessKey !== "") {
      writer.uint32(66).string(message.awsSecretAccessKey);
    }
    if (message.awsSessionToken !== "") {
      writer.uint32(74).string(message.awsSessionToken);
    }
    if (message.endpointUrl !== "") {
      writer.uint32(82).string(message.endpointUrl);
    }
    if (message.consumerRoleArn !== "") {
      writer.uint32(90).string(message.consumerRoleArn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KinesisSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKinesisSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.streamArn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.regionName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lateArrivalDeadline = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deadLetterQueueStreamName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.awsAccessKeyId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.awsSecretAccessKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.awsSessionToken = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.endpointUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.consumerRoleArn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KinesisSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      streamName: isSet(object.streamName) ? globalThis.String(object.streamName) : "",
      streamArn: isSet(object.streamArn) ? globalThis.String(object.streamArn) : "",
      regionName: isSet(object.regionName) ? globalThis.String(object.regionName) : "",
      lateArrivalDeadline: isSet(object.lateArrivalDeadline)
        ? Duration.fromJSON(object.lateArrivalDeadline)
        : undefined,
      deadLetterQueueStreamName: isSet(object.deadLetterQueueStreamName)
        ? globalThis.String(object.deadLetterQueueStreamName)
        : "",
      awsAccessKeyId: isSet(object.awsAccessKeyId) ? globalThis.String(object.awsAccessKeyId) : "",
      awsSecretAccessKey: isSet(object.awsSecretAccessKey) ? globalThis.String(object.awsSecretAccessKey) : "",
      awsSessionToken: isSet(object.awsSessionToken) ? globalThis.String(object.awsSessionToken) : "",
      endpointUrl: isSet(object.endpointUrl) ? globalThis.String(object.endpointUrl) : "",
      consumerRoleArn: isSet(object.consumerRoleArn) ? globalThis.String(object.consumerRoleArn) : "",
    };
  },

  toJSON(message: KinesisSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.streamName !== "") {
      obj.streamName = message.streamName;
    }
    if (message.streamArn !== "") {
      obj.streamArn = message.streamArn;
    }
    if (message.regionName !== "") {
      obj.regionName = message.regionName;
    }
    if (message.lateArrivalDeadline !== undefined) {
      obj.lateArrivalDeadline = Duration.toJSON(message.lateArrivalDeadline);
    }
    if (message.deadLetterQueueStreamName !== "") {
      obj.deadLetterQueueStreamName = message.deadLetterQueueStreamName;
    }
    if (message.awsAccessKeyId !== "") {
      obj.awsAccessKeyId = message.awsAccessKeyId;
    }
    if (message.awsSecretAccessKey !== "") {
      obj.awsSecretAccessKey = message.awsSecretAccessKey;
    }
    if (message.awsSessionToken !== "") {
      obj.awsSessionToken = message.awsSessionToken;
    }
    if (message.endpointUrl !== "") {
      obj.endpointUrl = message.endpointUrl;
    }
    if (message.consumerRoleArn !== "") {
      obj.consumerRoleArn = message.consumerRoleArn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KinesisSource>, I>>(base?: I): KinesisSource {
    return KinesisSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KinesisSource>, I>>(object: I): KinesisSource {
    const message = createBaseKinesisSource();
    message.name = object.name ?? "";
    message.streamName = object.streamName ?? "";
    message.streamArn = object.streamArn ?? "";
    message.regionName = object.regionName ?? "";
    message.lateArrivalDeadline = (object.lateArrivalDeadline !== undefined && object.lateArrivalDeadline !== null)
      ? Duration.fromPartial(object.lateArrivalDeadline)
      : undefined;
    message.deadLetterQueueStreamName = object.deadLetterQueueStreamName ?? "";
    message.awsAccessKeyId = object.awsAccessKeyId ?? "";
    message.awsSecretAccessKey = object.awsSecretAccessKey ?? "";
    message.awsSessionToken = object.awsSessionToken ?? "";
    message.endpointUrl = object.endpointUrl ?? "";
    message.consumerRoleArn = object.consumerRoleArn ?? "";
    return message;
  },
};

function createBaseKafkaSource(): KafkaSource {
  return {
    name: "",
    bootstrapServers: [],
    topic: "",
    sslKeystoreLocation: "",
    sslCaFile: "",
    clientIdPrefix: "",
    groupIdPrefix: "",
    securityProtocol: "",
    saslMechanism: "",
    saslUsername: "",
    saslPassword: "",
    lateArrivalDeadline: undefined,
    deadLetterQueueTopic: "",
  };
}

export const KafkaSource: MessageFns<KafkaSource> = {
  encode(message: KafkaSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.bootstrapServers) {
      writer.uint32(18).string(v!);
    }
    if (message.topic !== "") {
      writer.uint32(26).string(message.topic);
    }
    if (message.sslKeystoreLocation !== "") {
      writer.uint32(34).string(message.sslKeystoreLocation);
    }
    if (message.sslCaFile !== "") {
      writer.uint32(42).string(message.sslCaFile);
    }
    if (message.clientIdPrefix !== "") {
      writer.uint32(50).string(message.clientIdPrefix);
    }
    if (message.groupIdPrefix !== "") {
      writer.uint32(58).string(message.groupIdPrefix);
    }
    if (message.securityProtocol !== "") {
      writer.uint32(66).string(message.securityProtocol);
    }
    if (message.saslMechanism !== "") {
      writer.uint32(74).string(message.saslMechanism);
    }
    if (message.saslUsername !== "") {
      writer.uint32(82).string(message.saslUsername);
    }
    if (message.saslPassword !== "") {
      writer.uint32(90).string(message.saslPassword);
    }
    if (message.lateArrivalDeadline !== undefined) {
      Duration.encode(message.lateArrivalDeadline, writer.uint32(98).fork()).join();
    }
    if (message.deadLetterQueueTopic !== "") {
      writer.uint32(106).string(message.deadLetterQueueTopic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KafkaSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKafkaSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bootstrapServers.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sslKeystoreLocation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sslCaFile = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientIdPrefix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.groupIdPrefix = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.securityProtocol = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.saslMechanism = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.saslUsername = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.saslPassword = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.lateArrivalDeadline = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.deadLetterQueueTopic = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KafkaSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      bootstrapServers: globalThis.Array.isArray(object?.bootstrapServers)
        ? object.bootstrapServers.map((e: any) => globalThis.String(e))
        : [],
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      sslKeystoreLocation: isSet(object.sslKeystoreLocation) ? globalThis.String(object.sslKeystoreLocation) : "",
      sslCaFile: isSet(object.sslCaFile) ? globalThis.String(object.sslCaFile) : "",
      clientIdPrefix: isSet(object.clientIdPrefix) ? globalThis.String(object.clientIdPrefix) : "",
      groupIdPrefix: isSet(object.groupIdPrefix) ? globalThis.String(object.groupIdPrefix) : "",
      securityProtocol: isSet(object.securityProtocol) ? globalThis.String(object.securityProtocol) : "",
      saslMechanism: isSet(object.saslMechanism) ? globalThis.String(object.saslMechanism) : "",
      saslUsername: isSet(object.saslUsername) ? globalThis.String(object.saslUsername) : "",
      saslPassword: isSet(object.saslPassword) ? globalThis.String(object.saslPassword) : "",
      lateArrivalDeadline: isSet(object.lateArrivalDeadline)
        ? Duration.fromJSON(object.lateArrivalDeadline)
        : undefined,
      deadLetterQueueTopic: isSet(object.deadLetterQueueTopic) ? globalThis.String(object.deadLetterQueueTopic) : "",
    };
  },

  toJSON(message: KafkaSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.bootstrapServers?.length) {
      obj.bootstrapServers = message.bootstrapServers;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.sslKeystoreLocation !== "") {
      obj.sslKeystoreLocation = message.sslKeystoreLocation;
    }
    if (message.sslCaFile !== "") {
      obj.sslCaFile = message.sslCaFile;
    }
    if (message.clientIdPrefix !== "") {
      obj.clientIdPrefix = message.clientIdPrefix;
    }
    if (message.groupIdPrefix !== "") {
      obj.groupIdPrefix = message.groupIdPrefix;
    }
    if (message.securityProtocol !== "") {
      obj.securityProtocol = message.securityProtocol;
    }
    if (message.saslMechanism !== "") {
      obj.saslMechanism = message.saslMechanism;
    }
    if (message.saslUsername !== "") {
      obj.saslUsername = message.saslUsername;
    }
    if (message.saslPassword !== "") {
      obj.saslPassword = message.saslPassword;
    }
    if (message.lateArrivalDeadline !== undefined) {
      obj.lateArrivalDeadline = Duration.toJSON(message.lateArrivalDeadline);
    }
    if (message.deadLetterQueueTopic !== "") {
      obj.deadLetterQueueTopic = message.deadLetterQueueTopic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KafkaSource>, I>>(base?: I): KafkaSource {
    return KafkaSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KafkaSource>, I>>(object: I): KafkaSource {
    const message = createBaseKafkaSource();
    message.name = object.name ?? "";
    message.bootstrapServers = object.bootstrapServers?.map((e) => e) || [];
    message.topic = object.topic ?? "";
    message.sslKeystoreLocation = object.sslKeystoreLocation ?? "";
    message.sslCaFile = object.sslCaFile ?? "";
    message.clientIdPrefix = object.clientIdPrefix ?? "";
    message.groupIdPrefix = object.groupIdPrefix ?? "";
    message.securityProtocol = object.securityProtocol ?? "";
    message.saslMechanism = object.saslMechanism ?? "";
    message.saslUsername = object.saslUsername ?? "";
    message.saslPassword = object.saslPassword ?? "";
    message.lateArrivalDeadline = (object.lateArrivalDeadline !== undefined && object.lateArrivalDeadline !== null)
      ? Duration.fromPartial(object.lateArrivalDeadline)
      : undefined;
    message.deadLetterQueueTopic = object.deadLetterQueueTopic ?? "";
    return message;
  },
};

function createBasePubSubSource(): PubSubSource {
  return { name: "", projectId: "", subscriptionId: "", lateArrivalDeadline: undefined, deadLetterQueueTopic: "" };
}

export const PubSubSource: MessageFns<PubSubSource> = {
  encode(message: PubSubSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(26).string(message.subscriptionId);
    }
    if (message.lateArrivalDeadline !== undefined) {
      Duration.encode(message.lateArrivalDeadline, writer.uint32(34).fork()).join();
    }
    if (message.deadLetterQueueTopic !== "") {
      writer.uint32(42).string(message.deadLetterQueueTopic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubSubSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lateArrivalDeadline = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deadLetterQueueTopic = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubSubSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      lateArrivalDeadline: isSet(object.lateArrivalDeadline)
        ? Duration.fromJSON(object.lateArrivalDeadline)
        : undefined,
      deadLetterQueueTopic: isSet(object.deadLetterQueueTopic) ? globalThis.String(object.deadLetterQueueTopic) : "",
    };
  },

  toJSON(message: PubSubSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.lateArrivalDeadline !== undefined) {
      obj.lateArrivalDeadline = Duration.toJSON(message.lateArrivalDeadline);
    }
    if (message.deadLetterQueueTopic !== "") {
      obj.deadLetterQueueTopic = message.deadLetterQueueTopic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubSubSource>, I>>(base?: I): PubSubSource {
    return PubSubSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubSubSource>, I>>(object: I): PubSubSource {
    const message = createBasePubSubSource();
    message.name = object.name ?? "";
    message.projectId = object.projectId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.lateArrivalDeadline = (object.lateArrivalDeadline !== undefined && object.lateArrivalDeadline !== null)
      ? Duration.fromPartial(object.lateArrivalDeadline)
      : undefined;
    message.deadLetterQueueTopic = object.deadLetterQueueTopic ?? "";
    return message;
  },
};

function createBaseDatabaseSourceReference(): DatabaseSourceReference {
  return { type: 0, name: "" };
}

export const DatabaseSourceReference: MessageFns<DatabaseSourceReference> = {
  encode(message: DatabaseSourceReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseSourceReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseSourceReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseSourceReference {
    return {
      type: isSet(object.type) ? databaseSourceTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DatabaseSourceReference): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = databaseSourceTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseSourceReference>, I>>(base?: I): DatabaseSourceReference {
    return DatabaseSourceReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseSourceReference>, I>>(object: I): DatabaseSourceReference {
    const message = createBaseDatabaseSourceReference();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDatabaseSource(): DatabaseSource {
  return {
    bigquery: undefined,
    cloudsql: undefined,
    databricks: undefined,
    mysql: undefined,
    postgres: undefined,
    redshift: undefined,
    snowflake: undefined,
    sqlite: undefined,
    spanner: undefined,
    trino: undefined,
    dynamodb: undefined,
    athena: undefined,
  };
}

export const DatabaseSource: MessageFns<DatabaseSource> = {
  encode(message: DatabaseSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bigquery !== undefined) {
      BigQuerySource.encode(message.bigquery, writer.uint32(10).fork()).join();
    }
    if (message.cloudsql !== undefined) {
      CloudSQLSource.encode(message.cloudsql, writer.uint32(18).fork()).join();
    }
    if (message.databricks !== undefined) {
      DatabricksSource.encode(message.databricks, writer.uint32(26).fork()).join();
    }
    if (message.mysql !== undefined) {
      MySQLSource.encode(message.mysql, writer.uint32(34).fork()).join();
    }
    if (message.postgres !== undefined) {
      PostgresSource.encode(message.postgres, writer.uint32(42).fork()).join();
    }
    if (message.redshift !== undefined) {
      RedshiftSource.encode(message.redshift, writer.uint32(50).fork()).join();
    }
    if (message.snowflake !== undefined) {
      SnowflakeSource.encode(message.snowflake, writer.uint32(58).fork()).join();
    }
    if (message.sqlite !== undefined) {
      SQLiteSource.encode(message.sqlite, writer.uint32(66).fork()).join();
    }
    if (message.spanner !== undefined) {
      SpannerSource.encode(message.spanner, writer.uint32(74).fork()).join();
    }
    if (message.trino !== undefined) {
      TrinoSource.encode(message.trino, writer.uint32(82).fork()).join();
    }
    if (message.dynamodb !== undefined) {
      DynamoDBSource.encode(message.dynamodb, writer.uint32(90).fork()).join();
    }
    if (message.athena !== undefined) {
      AthenaSource.encode(message.athena, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bigquery = BigQuerySource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cloudsql = CloudSQLSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.databricks = DatabricksSource.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mysql = MySQLSource.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.postgres = PostgresSource.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.redshift = RedshiftSource.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.snowflake = SnowflakeSource.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sqlite = SQLiteSource.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.spanner = SpannerSource.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.trino = TrinoSource.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dynamodb = DynamoDBSource.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.athena = AthenaSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseSource {
    return {
      bigquery: isSet(object.bigquery) ? BigQuerySource.fromJSON(object.bigquery) : undefined,
      cloudsql: isSet(object.cloudsql) ? CloudSQLSource.fromJSON(object.cloudsql) : undefined,
      databricks: isSet(object.databricks) ? DatabricksSource.fromJSON(object.databricks) : undefined,
      mysql: isSet(object.mysql) ? MySQLSource.fromJSON(object.mysql) : undefined,
      postgres: isSet(object.postgres) ? PostgresSource.fromJSON(object.postgres) : undefined,
      redshift: isSet(object.redshift) ? RedshiftSource.fromJSON(object.redshift) : undefined,
      snowflake: isSet(object.snowflake) ? SnowflakeSource.fromJSON(object.snowflake) : undefined,
      sqlite: isSet(object.sqlite) ? SQLiteSource.fromJSON(object.sqlite) : undefined,
      spanner: isSet(object.spanner) ? SpannerSource.fromJSON(object.spanner) : undefined,
      trino: isSet(object.trino) ? TrinoSource.fromJSON(object.trino) : undefined,
      dynamodb: isSet(object.dynamodb) ? DynamoDBSource.fromJSON(object.dynamodb) : undefined,
      athena: isSet(object.athena) ? AthenaSource.fromJSON(object.athena) : undefined,
    };
  },

  toJSON(message: DatabaseSource): unknown {
    const obj: any = {};
    if (message.bigquery !== undefined) {
      obj.bigquery = BigQuerySource.toJSON(message.bigquery);
    }
    if (message.cloudsql !== undefined) {
      obj.cloudsql = CloudSQLSource.toJSON(message.cloudsql);
    }
    if (message.databricks !== undefined) {
      obj.databricks = DatabricksSource.toJSON(message.databricks);
    }
    if (message.mysql !== undefined) {
      obj.mysql = MySQLSource.toJSON(message.mysql);
    }
    if (message.postgres !== undefined) {
      obj.postgres = PostgresSource.toJSON(message.postgres);
    }
    if (message.redshift !== undefined) {
      obj.redshift = RedshiftSource.toJSON(message.redshift);
    }
    if (message.snowflake !== undefined) {
      obj.snowflake = SnowflakeSource.toJSON(message.snowflake);
    }
    if (message.sqlite !== undefined) {
      obj.sqlite = SQLiteSource.toJSON(message.sqlite);
    }
    if (message.spanner !== undefined) {
      obj.spanner = SpannerSource.toJSON(message.spanner);
    }
    if (message.trino !== undefined) {
      obj.trino = TrinoSource.toJSON(message.trino);
    }
    if (message.dynamodb !== undefined) {
      obj.dynamodb = DynamoDBSource.toJSON(message.dynamodb);
    }
    if (message.athena !== undefined) {
      obj.athena = AthenaSource.toJSON(message.athena);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabaseSource>, I>>(base?: I): DatabaseSource {
    return DatabaseSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabaseSource>, I>>(object: I): DatabaseSource {
    const message = createBaseDatabaseSource();
    message.bigquery = (object.bigquery !== undefined && object.bigquery !== null)
      ? BigQuerySource.fromPartial(object.bigquery)
      : undefined;
    message.cloudsql = (object.cloudsql !== undefined && object.cloudsql !== null)
      ? CloudSQLSource.fromPartial(object.cloudsql)
      : undefined;
    message.databricks = (object.databricks !== undefined && object.databricks !== null)
      ? DatabricksSource.fromPartial(object.databricks)
      : undefined;
    message.mysql = (object.mysql !== undefined && object.mysql !== null)
      ? MySQLSource.fromPartial(object.mysql)
      : undefined;
    message.postgres = (object.postgres !== undefined && object.postgres !== null)
      ? PostgresSource.fromPartial(object.postgres)
      : undefined;
    message.redshift = (object.redshift !== undefined && object.redshift !== null)
      ? RedshiftSource.fromPartial(object.redshift)
      : undefined;
    message.snowflake = (object.snowflake !== undefined && object.snowflake !== null)
      ? SnowflakeSource.fromPartial(object.snowflake)
      : undefined;
    message.sqlite = (object.sqlite !== undefined && object.sqlite !== null)
      ? SQLiteSource.fromPartial(object.sqlite)
      : undefined;
    message.spanner = (object.spanner !== undefined && object.spanner !== null)
      ? SpannerSource.fromPartial(object.spanner)
      : undefined;
    message.trino = (object.trino !== undefined && object.trino !== null)
      ? TrinoSource.fromPartial(object.trino)
      : undefined;
    message.dynamodb = (object.dynamodb !== undefined && object.dynamodb !== null)
      ? DynamoDBSource.fromPartial(object.dynamodb)
      : undefined;
    message.athena = (object.athena !== undefined && object.athena !== null)
      ? AthenaSource.fromPartial(object.athena)
      : undefined;
    return message;
  },
};

function createBaseBigQuerySource(): BigQuerySource {
  return {
    name: "",
    project: "",
    dataset: "",
    location: "",
    credentialsBase64: "",
    credentialsPath: "",
    engineArgs: {},
    asyncEngineArgs: {},
  };
}

export const BigQuerySource: MessageFns<BigQuerySource> = {
  encode(message: BigQuerySource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.dataset !== "") {
      writer.uint32(26).string(message.dataset);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    if (message.credentialsBase64 !== "") {
      writer.uint32(42).string(message.credentialsBase64);
    }
    if (message.credentialsPath !== "") {
      writer.uint32(50).string(message.credentialsPath);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      BigQuerySource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      BigQuerySource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQuerySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQuerySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataset = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.credentialsBase64 = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.credentialsPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = BigQuerySource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.engineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = BigQuerySource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.asyncEngineArgs[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQuerySource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      credentialsBase64: isSet(object.credentialsBase64) ? globalThis.String(object.credentialsBase64) : "",
      credentialsPath: isSet(object.credentialsPath) ? globalThis.String(object.credentialsPath) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BigQuerySource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.credentialsBase64 !== "") {
      obj.credentialsBase64 = message.credentialsBase64;
    }
    if (message.credentialsPath !== "") {
      obj.credentialsPath = message.credentialsPath;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigQuerySource>, I>>(base?: I): BigQuerySource {
    return BigQuerySource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigQuerySource>, I>>(object: I): BigQuerySource {
    const message = createBaseBigQuerySource();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.dataset = object.dataset ?? "";
    message.location = object.location ?? "";
    message.credentialsBase64 = object.credentialsBase64 ?? "";
    message.credentialsPath = object.credentialsPath ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBigQuerySource_EngineArgsEntry(): BigQuerySource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const BigQuerySource_EngineArgsEntry: MessageFns<BigQuerySource_EngineArgsEntry> = {
  encode(message: BigQuerySource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQuerySource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQuerySource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQuerySource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BigQuerySource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigQuerySource_EngineArgsEntry>, I>>(base?: I): BigQuerySource_EngineArgsEntry {
    return BigQuerySource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigQuerySource_EngineArgsEntry>, I>>(
    object: I,
  ): BigQuerySource_EngineArgsEntry {
    const message = createBaseBigQuerySource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBigQuerySource_AsyncEngineArgsEntry(): BigQuerySource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const BigQuerySource_AsyncEngineArgsEntry: MessageFns<BigQuerySource_AsyncEngineArgsEntry> = {
  encode(message: BigQuerySource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQuerySource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQuerySource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQuerySource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BigQuerySource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BigQuerySource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): BigQuerySource_AsyncEngineArgsEntry {
    return BigQuerySource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BigQuerySource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): BigQuerySource_AsyncEngineArgsEntry {
    const message = createBaseBigQuerySource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCloudSQLSource(): CloudSQLSource {
  return { name: "", db: "", user: "", password: "", instanceName: "", engineArgs: {}, asyncEngineArgs: {} };
}

export const CloudSQLSource: MessageFns<CloudSQLSource> = {
  encode(message: CloudSQLSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.db !== "") {
      writer.uint32(18).string(message.db);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    if (message.instanceName !== "") {
      writer.uint32(42).string(message.instanceName);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      CloudSQLSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      CloudSQLSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSQLSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSQLSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instanceName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CloudSQLSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.engineArgs[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CloudSQLSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.asyncEngineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSQLSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      instanceName: isSet(object.instanceName) ? globalThis.String(object.instanceName) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CloudSQLSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.instanceName !== "") {
      obj.instanceName = message.instanceName;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSQLSource>, I>>(base?: I): CloudSQLSource {
    return CloudSQLSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSQLSource>, I>>(object: I): CloudSQLSource {
    const message = createBaseCloudSQLSource();
    message.name = object.name ?? "";
    message.db = object.db ?? "";
    message.user = object.user ?? "";
    message.password = object.password ?? "";
    message.instanceName = object.instanceName ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCloudSQLSource_EngineArgsEntry(): CloudSQLSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const CloudSQLSource_EngineArgsEntry: MessageFns<CloudSQLSource_EngineArgsEntry> = {
  encode(message: CloudSQLSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSQLSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSQLSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSQLSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CloudSQLSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSQLSource_EngineArgsEntry>, I>>(base?: I): CloudSQLSource_EngineArgsEntry {
    return CloudSQLSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSQLSource_EngineArgsEntry>, I>>(
    object: I,
  ): CloudSQLSource_EngineArgsEntry {
    const message = createBaseCloudSQLSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCloudSQLSource_AsyncEngineArgsEntry(): CloudSQLSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const CloudSQLSource_AsyncEngineArgsEntry: MessageFns<CloudSQLSource_AsyncEngineArgsEntry> = {
  encode(message: CloudSQLSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSQLSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSQLSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSQLSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CloudSQLSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CloudSQLSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): CloudSQLSource_AsyncEngineArgsEntry {
    return CloudSQLSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CloudSQLSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): CloudSQLSource_AsyncEngineArgsEntry {
    const message = createBaseCloudSQLSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDatabricksSource(): DatabricksSource {
  return { name: "", host: "", port: "", db: "", httpPath: "", accessToken: "", engineArgs: {}, asyncEngineArgs: {} };
}

export const DatabricksSource: MessageFns<DatabricksSource> = {
  encode(message: DatabricksSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(26).string(message.port);
    }
    if (message.db !== "") {
      writer.uint32(34).string(message.db);
    }
    if (message.httpPath !== "") {
      writer.uint32(42).string(message.httpPath);
    }
    if (message.accessToken !== "") {
      writer.uint32(50).string(message.accessToken);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      DatabricksSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      DatabricksSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabricksSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabricksSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.httpPath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = DatabricksSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.engineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = DatabricksSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.asyncEngineArgs[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabricksSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      httpPath: isSet(object.httpPath) ? globalThis.String(object.httpPath) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DatabricksSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.httpPath !== "") {
      obj.httpPath = message.httpPath;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabricksSource>, I>>(base?: I): DatabricksSource {
    return DatabricksSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabricksSource>, I>>(object: I): DatabricksSource {
    const message = createBaseDatabricksSource();
    message.name = object.name ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.db = object.db ?? "";
    message.httpPath = object.httpPath ?? "";
    message.accessToken = object.accessToken ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDatabricksSource_EngineArgsEntry(): DatabricksSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const DatabricksSource_EngineArgsEntry: MessageFns<DatabricksSource_EngineArgsEntry> = {
  encode(message: DatabricksSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabricksSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabricksSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabricksSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DatabricksSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabricksSource_EngineArgsEntry>, I>>(
    base?: I,
  ): DatabricksSource_EngineArgsEntry {
    return DatabricksSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabricksSource_EngineArgsEntry>, I>>(
    object: I,
  ): DatabricksSource_EngineArgsEntry {
    const message = createBaseDatabricksSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDatabricksSource_AsyncEngineArgsEntry(): DatabricksSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const DatabricksSource_AsyncEngineArgsEntry: MessageFns<DatabricksSource_AsyncEngineArgsEntry> = {
  encode(message: DatabricksSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabricksSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabricksSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabricksSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DatabricksSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatabricksSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): DatabricksSource_AsyncEngineArgsEntry {
    return DatabricksSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatabricksSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): DatabricksSource_AsyncEngineArgsEntry {
    const message = createBaseDatabricksSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDynamoDBSource(): DynamoDBSource {
  return {
    name: "",
    awsClientIdOverride: undefined,
    awsClientSecretOverride: undefined,
    awsRegionOverride: undefined,
    endpointOverride: undefined,
    engineArgs: {},
    asyncEngineArgs: {},
  };
}

export const DynamoDBSource: MessageFns<DynamoDBSource> = {
  encode(message: DynamoDBSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.awsClientIdOverride !== undefined) {
      writer.uint32(18).string(message.awsClientIdOverride);
    }
    if (message.awsClientSecretOverride !== undefined) {
      writer.uint32(26).string(message.awsClientSecretOverride);
    }
    if (message.awsRegionOverride !== undefined) {
      writer.uint32(34).string(message.awsRegionOverride);
    }
    if (message.endpointOverride !== undefined) {
      writer.uint32(42).string(message.endpointOverride);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      DynamoDBSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      DynamoDBSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamoDBSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamoDBSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.awsClientIdOverride = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.awsClientSecretOverride = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.awsRegionOverride = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endpointOverride = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = DynamoDBSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.engineArgs[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = DynamoDBSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.asyncEngineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamoDBSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      awsClientIdOverride: isSet(object.awsClientIdOverride)
        ? globalThis.String(object.awsClientIdOverride)
        : undefined,
      awsClientSecretOverride: isSet(object.awsClientSecretOverride)
        ? globalThis.String(object.awsClientSecretOverride)
        : undefined,
      awsRegionOverride: isSet(object.awsRegionOverride) ? globalThis.String(object.awsRegionOverride) : undefined,
      endpointOverride: isSet(object.endpointOverride) ? globalThis.String(object.endpointOverride) : undefined,
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DynamoDBSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.awsClientIdOverride !== undefined) {
      obj.awsClientIdOverride = message.awsClientIdOverride;
    }
    if (message.awsClientSecretOverride !== undefined) {
      obj.awsClientSecretOverride = message.awsClientSecretOverride;
    }
    if (message.awsRegionOverride !== undefined) {
      obj.awsRegionOverride = message.awsRegionOverride;
    }
    if (message.endpointOverride !== undefined) {
      obj.endpointOverride = message.endpointOverride;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamoDBSource>, I>>(base?: I): DynamoDBSource {
    return DynamoDBSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamoDBSource>, I>>(object: I): DynamoDBSource {
    const message = createBaseDynamoDBSource();
    message.name = object.name ?? "";
    message.awsClientIdOverride = object.awsClientIdOverride ?? undefined;
    message.awsClientSecretOverride = object.awsClientSecretOverride ?? undefined;
    message.awsRegionOverride = object.awsRegionOverride ?? undefined;
    message.endpointOverride = object.endpointOverride ?? undefined;
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDynamoDBSource_EngineArgsEntry(): DynamoDBSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const DynamoDBSource_EngineArgsEntry: MessageFns<DynamoDBSource_EngineArgsEntry> = {
  encode(message: DynamoDBSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamoDBSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamoDBSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamoDBSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DynamoDBSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamoDBSource_EngineArgsEntry>, I>>(base?: I): DynamoDBSource_EngineArgsEntry {
    return DynamoDBSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamoDBSource_EngineArgsEntry>, I>>(
    object: I,
  ): DynamoDBSource_EngineArgsEntry {
    const message = createBaseDynamoDBSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDynamoDBSource_AsyncEngineArgsEntry(): DynamoDBSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const DynamoDBSource_AsyncEngineArgsEntry: MessageFns<DynamoDBSource_AsyncEngineArgsEntry> = {
  encode(message: DynamoDBSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamoDBSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamoDBSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamoDBSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DynamoDBSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamoDBSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): DynamoDBSource_AsyncEngineArgsEntry {
    return DynamoDBSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamoDBSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): DynamoDBSource_AsyncEngineArgsEntry {
    const message = createBaseDynamoDBSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMySQLSource(): MySQLSource {
  return { name: "", host: "", port: "", db: "", user: "", password: "", engineArgs: {}, asyncEngineArgs: {} };
}

export const MySQLSource: MessageFns<MySQLSource> = {
  encode(message: MySQLSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(26).string(message.port);
    }
    if (message.db !== "") {
      writer.uint32(34).string(message.db);
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    if (message.password !== "") {
      writer.uint32(50).string(message.password);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      MySQLSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      MySQLSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MySQLSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySQLSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = MySQLSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.engineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = MySQLSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.asyncEngineArgs[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySQLSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MySQLSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySQLSource>, I>>(base?: I): MySQLSource {
    return MySQLSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySQLSource>, I>>(object: I): MySQLSource {
    const message = createBaseMySQLSource();
    message.name = object.name ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.db = object.db ?? "";
    message.user = object.user ?? "";
    message.password = object.password ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMySQLSource_EngineArgsEntry(): MySQLSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const MySQLSource_EngineArgsEntry: MessageFns<MySQLSource_EngineArgsEntry> = {
  encode(message: MySQLSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MySQLSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySQLSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySQLSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MySQLSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySQLSource_EngineArgsEntry>, I>>(base?: I): MySQLSource_EngineArgsEntry {
    return MySQLSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySQLSource_EngineArgsEntry>, I>>(object: I): MySQLSource_EngineArgsEntry {
    const message = createBaseMySQLSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMySQLSource_AsyncEngineArgsEntry(): MySQLSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const MySQLSource_AsyncEngineArgsEntry: MessageFns<MySQLSource_AsyncEngineArgsEntry> = {
  encode(message: MySQLSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MySQLSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySQLSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySQLSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MySQLSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySQLSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): MySQLSource_AsyncEngineArgsEntry {
    return MySQLSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySQLSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): MySQLSource_AsyncEngineArgsEntry {
    const message = createBaseMySQLSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePostgresSource(): PostgresSource {
  return { name: "", host: "", port: "", db: "", user: "", password: "", engineArgs: {}, asyncEngineArgs: {} };
}

export const PostgresSource: MessageFns<PostgresSource> = {
  encode(message: PostgresSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(26).string(message.port);
    }
    if (message.db !== "") {
      writer.uint32(34).string(message.db);
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    if (message.password !== "") {
      writer.uint32(50).string(message.password);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      PostgresSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      PostgresSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostgresSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgresSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = PostgresSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.engineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = PostgresSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.asyncEngineArgs[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgresSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PostgresSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostgresSource>, I>>(base?: I): PostgresSource {
    return PostgresSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostgresSource>, I>>(object: I): PostgresSource {
    const message = createBasePostgresSource();
    message.name = object.name ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.db = object.db ?? "";
    message.user = object.user ?? "";
    message.password = object.password ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePostgresSource_EngineArgsEntry(): PostgresSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const PostgresSource_EngineArgsEntry: MessageFns<PostgresSource_EngineArgsEntry> = {
  encode(message: PostgresSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostgresSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgresSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgresSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PostgresSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostgresSource_EngineArgsEntry>, I>>(base?: I): PostgresSource_EngineArgsEntry {
    return PostgresSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostgresSource_EngineArgsEntry>, I>>(
    object: I,
  ): PostgresSource_EngineArgsEntry {
    const message = createBasePostgresSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePostgresSource_AsyncEngineArgsEntry(): PostgresSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const PostgresSource_AsyncEngineArgsEntry: MessageFns<PostgresSource_AsyncEngineArgsEntry> = {
  encode(message: PostgresSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostgresSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgresSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgresSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PostgresSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostgresSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): PostgresSource_AsyncEngineArgsEntry {
    return PostgresSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostgresSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): PostgresSource_AsyncEngineArgsEntry {
    const message = createBasePostgresSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRedshiftSource(): RedshiftSource {
  return {
    name: "",
    host: "",
    port: "",
    db: "",
    user: "",
    password: "",
    s3Client: "",
    s3Bucket: "",
    engineArgs: {},
    asyncEngineArgs: {},
    unloadIamRole: "",
  };
}

export const RedshiftSource: MessageFns<RedshiftSource> = {
  encode(message: RedshiftSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(26).string(message.port);
    }
    if (message.db !== "") {
      writer.uint32(34).string(message.db);
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    if (message.password !== "") {
      writer.uint32(50).string(message.password);
    }
    if (message.s3Client !== "") {
      writer.uint32(58).string(message.s3Client);
    }
    if (message.s3Bucket !== "") {
      writer.uint32(66).string(message.s3Bucket);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      RedshiftSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      RedshiftSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.unloadIamRole !== "") {
      writer.uint32(90).string(message.unloadIamRole);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedshiftSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedshiftSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.s3Client = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.s3Bucket = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = RedshiftSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.engineArgs[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = RedshiftSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.asyncEngineArgs[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.unloadIamRole = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedshiftSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      s3Client: isSet(object.s3Client) ? globalThis.String(object.s3Client) : "",
      s3Bucket: isSet(object.s3Bucket) ? globalThis.String(object.s3Bucket) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      unloadIamRole: isSet(object.unloadIamRole) ? globalThis.String(object.unloadIamRole) : "",
    };
  },

  toJSON(message: RedshiftSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.s3Client !== "") {
      obj.s3Client = message.s3Client;
    }
    if (message.s3Bucket !== "") {
      obj.s3Bucket = message.s3Bucket;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.unloadIamRole !== "") {
      obj.unloadIamRole = message.unloadIamRole;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedshiftSource>, I>>(base?: I): RedshiftSource {
    return RedshiftSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedshiftSource>, I>>(object: I): RedshiftSource {
    const message = createBaseRedshiftSource();
    message.name = object.name ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.db = object.db ?? "";
    message.user = object.user ?? "";
    message.password = object.password ?? "";
    message.s3Client = object.s3Client ?? "";
    message.s3Bucket = object.s3Bucket ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.unloadIamRole = object.unloadIamRole ?? "";
    return message;
  },
};

function createBaseRedshiftSource_EngineArgsEntry(): RedshiftSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const RedshiftSource_EngineArgsEntry: MessageFns<RedshiftSource_EngineArgsEntry> = {
  encode(message: RedshiftSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedshiftSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedshiftSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedshiftSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RedshiftSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedshiftSource_EngineArgsEntry>, I>>(base?: I): RedshiftSource_EngineArgsEntry {
    return RedshiftSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedshiftSource_EngineArgsEntry>, I>>(
    object: I,
  ): RedshiftSource_EngineArgsEntry {
    const message = createBaseRedshiftSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRedshiftSource_AsyncEngineArgsEntry(): RedshiftSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const RedshiftSource_AsyncEngineArgsEntry: MessageFns<RedshiftSource_AsyncEngineArgsEntry> = {
  encode(message: RedshiftSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedshiftSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedshiftSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedshiftSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RedshiftSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedshiftSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): RedshiftSource_AsyncEngineArgsEntry {
    return RedshiftSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedshiftSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): RedshiftSource_AsyncEngineArgsEntry {
    const message = createBaseRedshiftSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSnowflakeSource(): SnowflakeSource {
  return {
    name: "",
    db: "",
    schema: "",
    role: "",
    user: "",
    password: "",
    accountIdentifier: "",
    warehouse: "",
    engineArgs: {},
    asyncEngineArgs: {},
    privateKeyB64: "",
  };
}

export const SnowflakeSource: MessageFns<SnowflakeSource> = {
  encode(message: SnowflakeSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.db !== "") {
      writer.uint32(18).string(message.db);
    }
    if (message.schema !== "") {
      writer.uint32(26).string(message.schema);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    if (message.password !== "") {
      writer.uint32(50).string(message.password);
    }
    if (message.accountIdentifier !== "") {
      writer.uint32(58).string(message.accountIdentifier);
    }
    if (message.warehouse !== "") {
      writer.uint32(66).string(message.warehouse);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      SnowflakeSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      SnowflakeSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.privateKeyB64 !== "") {
      writer.uint32(90).string(message.privateKeyB64);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnowflakeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnowflakeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accountIdentifier = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.warehouse = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = SnowflakeSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.engineArgs[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SnowflakeSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.asyncEngineArgs[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.privateKeyB64 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnowflakeSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      accountIdentifier: isSet(object.accountIdentifier) ? globalThis.String(object.accountIdentifier) : "",
      warehouse: isSet(object.warehouse) ? globalThis.String(object.warehouse) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      privateKeyB64: isSet(object.privateKeyB64) ? globalThis.String(object.privateKeyB64) : "",
    };
  },

  toJSON(message: SnowflakeSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.accountIdentifier !== "") {
      obj.accountIdentifier = message.accountIdentifier;
    }
    if (message.warehouse !== "") {
      obj.warehouse = message.warehouse;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.privateKeyB64 !== "") {
      obj.privateKeyB64 = message.privateKeyB64;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnowflakeSource>, I>>(base?: I): SnowflakeSource {
    return SnowflakeSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnowflakeSource>, I>>(object: I): SnowflakeSource {
    const message = createBaseSnowflakeSource();
    message.name = object.name ?? "";
    message.db = object.db ?? "";
    message.schema = object.schema ?? "";
    message.role = object.role ?? "";
    message.user = object.user ?? "";
    message.password = object.password ?? "";
    message.accountIdentifier = object.accountIdentifier ?? "";
    message.warehouse = object.warehouse ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.privateKeyB64 = object.privateKeyB64 ?? "";
    return message;
  },
};

function createBaseSnowflakeSource_EngineArgsEntry(): SnowflakeSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const SnowflakeSource_EngineArgsEntry: MessageFns<SnowflakeSource_EngineArgsEntry> = {
  encode(message: SnowflakeSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnowflakeSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnowflakeSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnowflakeSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SnowflakeSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnowflakeSource_EngineArgsEntry>, I>>(base?: I): SnowflakeSource_EngineArgsEntry {
    return SnowflakeSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnowflakeSource_EngineArgsEntry>, I>>(
    object: I,
  ): SnowflakeSource_EngineArgsEntry {
    const message = createBaseSnowflakeSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSnowflakeSource_AsyncEngineArgsEntry(): SnowflakeSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const SnowflakeSource_AsyncEngineArgsEntry: MessageFns<SnowflakeSource_AsyncEngineArgsEntry> = {
  encode(message: SnowflakeSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnowflakeSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnowflakeSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnowflakeSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SnowflakeSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnowflakeSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): SnowflakeSource_AsyncEngineArgsEntry {
    return SnowflakeSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnowflakeSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): SnowflakeSource_AsyncEngineArgsEntry {
    const message = createBaseSnowflakeSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSQLiteSource(): SQLiteSource {
  return { name: "", fileName: "", engineArgs: {}, asyncEngineArgs: {} };
}

export const SQLiteSource: MessageFns<SQLiteSource> = {
  encode(message: SQLiteSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      SQLiteSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      SQLiteSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLiteSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLiteSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SQLiteSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.engineArgs[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SQLiteSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.asyncEngineArgs[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLiteSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SQLiteSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SQLiteSource>, I>>(base?: I): SQLiteSource {
    return SQLiteSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SQLiteSource>, I>>(object: I): SQLiteSource {
    const message = createBaseSQLiteSource();
    message.name = object.name ?? "";
    message.fileName = object.fileName ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSQLiteSource_EngineArgsEntry(): SQLiteSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const SQLiteSource_EngineArgsEntry: MessageFns<SQLiteSource_EngineArgsEntry> = {
  encode(message: SQLiteSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLiteSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLiteSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLiteSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SQLiteSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SQLiteSource_EngineArgsEntry>, I>>(base?: I): SQLiteSource_EngineArgsEntry {
    return SQLiteSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SQLiteSource_EngineArgsEntry>, I>>(object: I): SQLiteSource_EngineArgsEntry {
    const message = createBaseSQLiteSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSQLiteSource_AsyncEngineArgsEntry(): SQLiteSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const SQLiteSource_AsyncEngineArgsEntry: MessageFns<SQLiteSource_AsyncEngineArgsEntry> = {
  encode(message: SQLiteSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLiteSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLiteSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLiteSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SQLiteSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SQLiteSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): SQLiteSource_AsyncEngineArgsEntry {
    return SQLiteSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SQLiteSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): SQLiteSource_AsyncEngineArgsEntry {
    const message = createBaseSQLiteSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpannerSource(): SpannerSource {
  return { name: "", project: "", instance: "", db: "", credentialsBase64: "", engineArgs: {}, asyncEngineArgs: {} };
}

export const SpannerSource: MessageFns<SpannerSource> = {
  encode(message: SpannerSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.db !== "") {
      writer.uint32(34).string(message.db);
    }
    if (message.credentialsBase64 !== "") {
      writer.uint32(42).string(message.credentialsBase64);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      SpannerSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      SpannerSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.db = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.credentialsBase64 = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = SpannerSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.engineArgs[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = SpannerSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.asyncEngineArgs[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      db: isSet(object.db) ? globalThis.String(object.db) : "",
      credentialsBase64: isSet(object.credentialsBase64) ? globalThis.String(object.credentialsBase64) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SpannerSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.db !== "") {
      obj.db = message.db;
    }
    if (message.credentialsBase64 !== "") {
      obj.credentialsBase64 = message.credentialsBase64;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpannerSource>, I>>(base?: I): SpannerSource {
    return SpannerSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpannerSource>, I>>(object: I): SpannerSource {
    const message = createBaseSpannerSource();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.instance = object.instance ?? "";
    message.db = object.db ?? "";
    message.credentialsBase64 = object.credentialsBase64 ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSpannerSource_EngineArgsEntry(): SpannerSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const SpannerSource_EngineArgsEntry: MessageFns<SpannerSource_EngineArgsEntry> = {
  encode(message: SpannerSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SpannerSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpannerSource_EngineArgsEntry>, I>>(base?: I): SpannerSource_EngineArgsEntry {
    return SpannerSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpannerSource_EngineArgsEntry>, I>>(
    object: I,
  ): SpannerSource_EngineArgsEntry {
    const message = createBaseSpannerSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpannerSource_AsyncEngineArgsEntry(): SpannerSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const SpannerSource_AsyncEngineArgsEntry: MessageFns<SpannerSource_AsyncEngineArgsEntry> = {
  encode(message: SpannerSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpannerSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpannerSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpannerSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SpannerSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpannerSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): SpannerSource_AsyncEngineArgsEntry {
    return SpannerSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpannerSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): SpannerSource_AsyncEngineArgsEntry {
    const message = createBaseSpannerSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTrinoSource(): TrinoSource {
  return {
    name: "",
    host: "",
    port: "",
    catalog: "",
    schema: "",
    user: "",
    password: "",
    engineArgs: {},
    asyncEngineArgs: {},
  };
}

export const TrinoSource: MessageFns<TrinoSource> = {
  encode(message: TrinoSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(26).string(message.port);
    }
    if (message.catalog !== "") {
      writer.uint32(34).string(message.catalog);
    }
    if (message.schema !== "") {
      writer.uint32(42).string(message.schema);
    }
    if (message.user !== "") {
      writer.uint32(50).string(message.user);
    }
    if (message.password !== "") {
      writer.uint32(58).string(message.password);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      TrinoSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      TrinoSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrinoSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrinoSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.catalog = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = TrinoSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.engineArgs[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = TrinoSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.asyncEngineArgs[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrinoSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      catalog: isSet(object.catalog) ? globalThis.String(object.catalog) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TrinoSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.catalog !== "") {
      obj.catalog = message.catalog;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrinoSource>, I>>(base?: I): TrinoSource {
    return TrinoSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrinoSource>, I>>(object: I): TrinoSource {
    const message = createBaseTrinoSource();
    message.name = object.name ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.catalog = object.catalog ?? "";
    message.schema = object.schema ?? "";
    message.user = object.user ?? "";
    message.password = object.password ?? "";
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTrinoSource_EngineArgsEntry(): TrinoSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const TrinoSource_EngineArgsEntry: MessageFns<TrinoSource_EngineArgsEntry> = {
  encode(message: TrinoSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrinoSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrinoSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrinoSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TrinoSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrinoSource_EngineArgsEntry>, I>>(base?: I): TrinoSource_EngineArgsEntry {
    return TrinoSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrinoSource_EngineArgsEntry>, I>>(object: I): TrinoSource_EngineArgsEntry {
    const message = createBaseTrinoSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTrinoSource_AsyncEngineArgsEntry(): TrinoSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const TrinoSource_AsyncEngineArgsEntry: MessageFns<TrinoSource_AsyncEngineArgsEntry> = {
  encode(message: TrinoSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrinoSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrinoSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrinoSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TrinoSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrinoSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): TrinoSource_AsyncEngineArgsEntry {
    return TrinoSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrinoSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): TrinoSource_AsyncEngineArgsEntry {
    const message = createBaseTrinoSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAthenaSource(): AthenaSource {
  return {
    name: "",
    awsRegion: "",
    awsAccessKeyId: undefined,
    awsAccessKeySecret: undefined,
    s3StagingDir: "",
    catalogName: undefined,
    schemaName: undefined,
    roleArn: undefined,
    engineArgs: {},
    asyncEngineArgs: {},
    workGroup: undefined,
  };
}

export const AthenaSource: MessageFns<AthenaSource> = {
  encode(message: AthenaSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.awsRegion !== "") {
      writer.uint32(18).string(message.awsRegion);
    }
    if (message.awsAccessKeyId !== undefined) {
      writer.uint32(26).string(message.awsAccessKeyId);
    }
    if (message.awsAccessKeySecret !== undefined) {
      writer.uint32(34).string(message.awsAccessKeySecret);
    }
    if (message.s3StagingDir !== "") {
      writer.uint32(42).string(message.s3StagingDir);
    }
    if (message.catalogName !== undefined) {
      writer.uint32(50).string(message.catalogName);
    }
    if (message.schemaName !== undefined) {
      writer.uint32(58).string(message.schemaName);
    }
    if (message.roleArn !== undefined) {
      writer.uint32(66).string(message.roleArn);
    }
    Object.entries(message.engineArgs).forEach(([key, value]) => {
      AthenaSource_EngineArgsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.asyncEngineArgs).forEach(([key, value]) => {
      AthenaSource_AsyncEngineArgsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.workGroup !== undefined) {
      writer.uint32(90).string(message.workGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AthenaSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAthenaSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.awsRegion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.awsAccessKeyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.awsAccessKeySecret = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.s3StagingDir = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.catalogName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.roleArn = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = AthenaSource_EngineArgsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.engineArgs[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = AthenaSource_AsyncEngineArgsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.asyncEngineArgs[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.workGroup = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AthenaSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      awsRegion: isSet(object.awsRegion) ? globalThis.String(object.awsRegion) : "",
      awsAccessKeyId: isSet(object.awsAccessKeyId) ? globalThis.String(object.awsAccessKeyId) : undefined,
      awsAccessKeySecret: isSet(object.awsAccessKeySecret) ? globalThis.String(object.awsAccessKeySecret) : undefined,
      s3StagingDir: isSet(object.s3StagingDir) ? globalThis.String(object.s3StagingDir) : "",
      catalogName: isSet(object.catalogName) ? globalThis.String(object.catalogName) : undefined,
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : undefined,
      roleArn: isSet(object.roleArn) ? globalThis.String(object.roleArn) : undefined,
      engineArgs: isObject(object.engineArgs)
        ? Object.entries(object.engineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      asyncEngineArgs: isObject(object.asyncEngineArgs)
        ? Object.entries(object.asyncEngineArgs).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      workGroup: isSet(object.workGroup) ? globalThis.String(object.workGroup) : undefined,
    };
  },

  toJSON(message: AthenaSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.awsRegion !== "") {
      obj.awsRegion = message.awsRegion;
    }
    if (message.awsAccessKeyId !== undefined) {
      obj.awsAccessKeyId = message.awsAccessKeyId;
    }
    if (message.awsAccessKeySecret !== undefined) {
      obj.awsAccessKeySecret = message.awsAccessKeySecret;
    }
    if (message.s3StagingDir !== "") {
      obj.s3StagingDir = message.s3StagingDir;
    }
    if (message.catalogName !== undefined) {
      obj.catalogName = message.catalogName;
    }
    if (message.schemaName !== undefined) {
      obj.schemaName = message.schemaName;
    }
    if (message.roleArn !== undefined) {
      obj.roleArn = message.roleArn;
    }
    if (message.engineArgs) {
      const entries = Object.entries(message.engineArgs);
      if (entries.length > 0) {
        obj.engineArgs = {};
        entries.forEach(([k, v]) => {
          obj.engineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.asyncEngineArgs) {
      const entries = Object.entries(message.asyncEngineArgs);
      if (entries.length > 0) {
        obj.asyncEngineArgs = {};
        entries.forEach(([k, v]) => {
          obj.asyncEngineArgs[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.workGroup !== undefined) {
      obj.workGroup = message.workGroup;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AthenaSource>, I>>(base?: I): AthenaSource {
    return AthenaSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AthenaSource>, I>>(object: I): AthenaSource {
    const message = createBaseAthenaSource();
    message.name = object.name ?? "";
    message.awsRegion = object.awsRegion ?? "";
    message.awsAccessKeyId = object.awsAccessKeyId ?? undefined;
    message.awsAccessKeySecret = object.awsAccessKeySecret ?? undefined;
    message.s3StagingDir = object.s3StagingDir ?? "";
    message.catalogName = object.catalogName ?? undefined;
    message.schemaName = object.schemaName ?? undefined;
    message.roleArn = object.roleArn ?? undefined;
    message.engineArgs = Object.entries(object.engineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.asyncEngineArgs = Object.entries(object.asyncEngineArgs ?? {}).reduce<{ [key: string]: ScalarValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalarValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.workGroup = object.workGroup ?? undefined;
    return message;
  },
};

function createBaseAthenaSource_EngineArgsEntry(): AthenaSource_EngineArgsEntry {
  return { key: "", value: undefined };
}

export const AthenaSource_EngineArgsEntry: MessageFns<AthenaSource_EngineArgsEntry> = {
  encode(message: AthenaSource_EngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AthenaSource_EngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAthenaSource_EngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AthenaSource_EngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AthenaSource_EngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AthenaSource_EngineArgsEntry>, I>>(base?: I): AthenaSource_EngineArgsEntry {
    return AthenaSource_EngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AthenaSource_EngineArgsEntry>, I>>(object: I): AthenaSource_EngineArgsEntry {
    const message = createBaseAthenaSource_EngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAthenaSource_AsyncEngineArgsEntry(): AthenaSource_AsyncEngineArgsEntry {
  return { key: "", value: undefined };
}

export const AthenaSource_AsyncEngineArgsEntry: MessageFns<AthenaSource_AsyncEngineArgsEntry> = {
  encode(message: AthenaSource_AsyncEngineArgsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AthenaSource_AsyncEngineArgsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAthenaSource_AsyncEngineArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AthenaSource_AsyncEngineArgsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AthenaSource_AsyncEngineArgsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AthenaSource_AsyncEngineArgsEntry>, I>>(
    base?: I,
  ): AthenaSource_AsyncEngineArgsEntry {
    return AthenaSource_AsyncEngineArgsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AthenaSource_AsyncEngineArgsEntry>, I>>(
    object: I,
  ): AthenaSource_AsyncEngineArgsEntry {
    const message = createBaseAthenaSource_AsyncEngineArgsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScalarValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
