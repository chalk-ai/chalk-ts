// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/graph/v1/graph.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration.pb";
import { Timestamp } from "../../../google/protobuf/timestamp.pb";
import { ArrowType, ScalarValue } from "../../arrow/v1/arrow.pb";
import { LogicalExprNode } from "../../expression/v1/expression.pb";
import { Range } from "../../lsp/v1/lsp.pb";
import {
  DatabaseSource as DatabaseSource1,
  DatabaseSourceGroup,
  DatabaseSourceReference as DatabaseSourceReference3,
  StreamSource as StreamSource2,
  StreamSourceReference as StreamSourceReference4,
} from "../v2/sources.pb";
import { DatabaseSource, DatabaseSourceReference, StreamSource, StreamSourceReference } from "./sources.pb";

export const protobufPackage = "chalk.graph.v1";

export enum CacheStrategy {
  CACHE_STRATEGY_UNSPECIFIED = 0,
  CACHE_STRATEGY_ALL = 1,
  CACHE_STRATEGY_NO_NULLS = 2,
  CACHE_STRATEGY_EVICT_NULLS = 3,
  CACHE_STRATEGY_NO_DEFAULTS = 4,
  CACHE_STRATEGY_EVICT_DEFAULTS = 5,
  CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS = 6,
  CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS = 7,
  UNRECOGNIZED = -1,
}

export function cacheStrategyFromJSON(object: any): CacheStrategy {
  switch (object) {
    case 0:
    case "CACHE_STRATEGY_UNSPECIFIED":
      return CacheStrategy.CACHE_STRATEGY_UNSPECIFIED;
    case 1:
    case "CACHE_STRATEGY_ALL":
      return CacheStrategy.CACHE_STRATEGY_ALL;
    case 2:
    case "CACHE_STRATEGY_NO_NULLS":
      return CacheStrategy.CACHE_STRATEGY_NO_NULLS;
    case 3:
    case "CACHE_STRATEGY_EVICT_NULLS":
      return CacheStrategy.CACHE_STRATEGY_EVICT_NULLS;
    case 4:
    case "CACHE_STRATEGY_NO_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_NO_DEFAULTS;
    case 5:
    case "CACHE_STRATEGY_EVICT_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_EVICT_DEFAULTS;
    case 6:
    case "CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS;
    case 7:
    case "CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS":
      return CacheStrategy.CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CacheStrategy.UNRECOGNIZED;
  }
}

export function cacheStrategyToJSON(object: CacheStrategy): string {
  switch (object) {
    case CacheStrategy.CACHE_STRATEGY_UNSPECIFIED:
      return "CACHE_STRATEGY_UNSPECIFIED";
    case CacheStrategy.CACHE_STRATEGY_ALL:
      return "CACHE_STRATEGY_ALL";
    case CacheStrategy.CACHE_STRATEGY_NO_NULLS:
      return "CACHE_STRATEGY_NO_NULLS";
    case CacheStrategy.CACHE_STRATEGY_EVICT_NULLS:
      return "CACHE_STRATEGY_EVICT_NULLS";
    case CacheStrategy.CACHE_STRATEGY_NO_DEFAULTS:
      return "CACHE_STRATEGY_NO_DEFAULTS";
    case CacheStrategy.CACHE_STRATEGY_EVICT_DEFAULTS:
      return "CACHE_STRATEGY_EVICT_DEFAULTS";
    case CacheStrategy.CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS:
      return "CACHE_STRATEGY_NO_NULLS_OR_DEFAULTS";
    case CacheStrategy.CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS:
      return "CACHE_STRATEGY_EVICT_NULLS_AND_DEFAULTS";
    case CacheStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResolverKind {
  RESOLVER_KIND_UNSPECIFIED = 0,
  RESOLVER_KIND_ONLINE = 1,
  RESOLVER_KIND_OFFLINE = 2,
  UNRECOGNIZED = -1,
}

export function resolverKindFromJSON(object: any): ResolverKind {
  switch (object) {
    case 0:
    case "RESOLVER_KIND_UNSPECIFIED":
      return ResolverKind.RESOLVER_KIND_UNSPECIFIED;
    case 1:
    case "RESOLVER_KIND_ONLINE":
      return ResolverKind.RESOLVER_KIND_ONLINE;
    case 2:
    case "RESOLVER_KIND_OFFLINE":
      return ResolverKind.RESOLVER_KIND_OFFLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResolverKind.UNRECOGNIZED;
  }
}

export function resolverKindToJSON(object: ResolverKind): string {
  switch (object) {
    case ResolverKind.RESOLVER_KIND_UNSPECIFIED:
      return "RESOLVER_KIND_UNSPECIFIED";
    case ResolverKind.RESOLVER_KIND_ONLINE:
      return "RESOLVER_KIND_ONLINE";
    case ResolverKind.RESOLVER_KIND_OFFLINE:
      return "RESOLVER_KIND_OFFLINE";
    case ResolverKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResourceHint {
  RESOURCE_HINT_UNSPECIFIED = 0,
  RESOURCE_HINT_CPU = 1,
  RESOURCE_HINT_IO = 2,
  UNRECOGNIZED = -1,
}

export function resourceHintFromJSON(object: any): ResourceHint {
  switch (object) {
    case 0:
    case "RESOURCE_HINT_UNSPECIFIED":
      return ResourceHint.RESOURCE_HINT_UNSPECIFIED;
    case 1:
    case "RESOURCE_HINT_CPU":
      return ResourceHint.RESOURCE_HINT_CPU;
    case 2:
    case "RESOURCE_HINT_IO":
      return ResourceHint.RESOURCE_HINT_IO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResourceHint.UNRECOGNIZED;
  }
}

export function resourceHintToJSON(object: ResourceHint): string {
  switch (object) {
    case ResourceHint.RESOURCE_HINT_UNSPECIFIED:
      return "RESOURCE_HINT_UNSPECIFIED";
    case ResourceHint.RESOURCE_HINT_CPU:
      return "RESOURCE_HINT_CPU";
    case ResourceHint.RESOURCE_HINT_IO:
      return "RESOURCE_HINT_IO";
    case ResourceHint.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Finalizer {
  FINALIZER_UNSPECIFIED = 0,
  FINALIZER_ONE_OR_NONE = 1,
  FINALIZER_ONE = 2,
  FINALIZER_FIRST = 3,
  FINALIZER_ALL = 4,
  UNRECOGNIZED = -1,
}

export function finalizerFromJSON(object: any): Finalizer {
  switch (object) {
    case 0:
    case "FINALIZER_UNSPECIFIED":
      return Finalizer.FINALIZER_UNSPECIFIED;
    case 1:
    case "FINALIZER_ONE_OR_NONE":
      return Finalizer.FINALIZER_ONE_OR_NONE;
    case 2:
    case "FINALIZER_ONE":
      return Finalizer.FINALIZER_ONE;
    case 3:
    case "FINALIZER_FIRST":
      return Finalizer.FINALIZER_FIRST;
    case 4:
    case "FINALIZER_ALL":
      return Finalizer.FINALIZER_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Finalizer.UNRECOGNIZED;
  }
}

export function finalizerToJSON(object: Finalizer): string {
  switch (object) {
    case Finalizer.FINALIZER_UNSPECIFIED:
      return "FINALIZER_UNSPECIFIED";
    case Finalizer.FINALIZER_ONE_OR_NONE:
      return "FINALIZER_ONE_OR_NONE";
    case Finalizer.FINALIZER_ONE:
      return "FINALIZER_ONE";
    case Finalizer.FINALIZER_FIRST:
      return "FINALIZER_FIRST";
    case Finalizer.FINALIZER_ALL:
      return "FINALIZER_ALL";
    case Finalizer.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncrementalMode {
  INCREMENTAL_MODE_UNSPECIFIED = 0,
  INCREMENTAL_MODE_ROW = 1,
  INCREMENTAL_MODE_GROUP = 2,
  INCREMENTAL_MODE_PARAMETER = 3,
  UNRECOGNIZED = -1,
}

export function incrementalModeFromJSON(object: any): IncrementalMode {
  switch (object) {
    case 0:
    case "INCREMENTAL_MODE_UNSPECIFIED":
      return IncrementalMode.INCREMENTAL_MODE_UNSPECIFIED;
    case 1:
    case "INCREMENTAL_MODE_ROW":
      return IncrementalMode.INCREMENTAL_MODE_ROW;
    case 2:
    case "INCREMENTAL_MODE_GROUP":
      return IncrementalMode.INCREMENTAL_MODE_GROUP;
    case 3:
    case "INCREMENTAL_MODE_PARAMETER":
      return IncrementalMode.INCREMENTAL_MODE_PARAMETER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncrementalMode.UNRECOGNIZED;
  }
}

export function incrementalModeToJSON(object: IncrementalMode): string {
  switch (object) {
    case IncrementalMode.INCREMENTAL_MODE_UNSPECIFIED:
      return "INCREMENTAL_MODE_UNSPECIFIED";
    case IncrementalMode.INCREMENTAL_MODE_ROW:
      return "INCREMENTAL_MODE_ROW";
    case IncrementalMode.INCREMENTAL_MODE_GROUP:
      return "INCREMENTAL_MODE_GROUP";
    case IncrementalMode.INCREMENTAL_MODE_PARAMETER:
      return "INCREMENTAL_MODE_PARAMETER";
    case IncrementalMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IncrementalTimestampMode {
  INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED = 0,
  INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME = 1,
  INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME = 2,
  UNRECOGNIZED = -1,
}

export function incrementalTimestampModeFromJSON(object: any): IncrementalTimestampMode {
  switch (object) {
    case 0:
    case "INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED":
      return IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED;
    case 1:
    case "INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME":
      return IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME;
    case 2:
    case "INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME":
      return IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncrementalTimestampMode.UNRECOGNIZED;
  }
}

export function incrementalTimestampModeToJSON(object: IncrementalTimestampMode): string {
  switch (object) {
    case IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED:
      return "INCREMENTAL_TIMESTAMP_MODE_UNSPECIFIED";
    case IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME:
      return "INCREMENTAL_TIMESTAMP_MODE_FEATURE_TIME";
    case IncrementalTimestampMode.INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME:
      return "INCREMENTAL_TIMESTAMP_MODE_RESOLVER_EXECUTION_TIME";
    case IncrementalTimestampMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WindowMode {
  WINDOW_MODE_UNSPECIFIED = 0,
  WINDOW_MODE_CONTINUOUS = 1,
  WINDOW_MODE_TUMBLING = 2,
  WINDOW_MODE_CDC = 3,
  UNRECOGNIZED = -1,
}

export function windowModeFromJSON(object: any): WindowMode {
  switch (object) {
    case 0:
    case "WINDOW_MODE_UNSPECIFIED":
      return WindowMode.WINDOW_MODE_UNSPECIFIED;
    case 1:
    case "WINDOW_MODE_CONTINUOUS":
      return WindowMode.WINDOW_MODE_CONTINUOUS;
    case 2:
    case "WINDOW_MODE_TUMBLING":
      return WindowMode.WINDOW_MODE_TUMBLING;
    case 3:
    case "WINDOW_MODE_CDC":
      return WindowMode.WINDOW_MODE_CDC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowMode.UNRECOGNIZED;
  }
}

export function windowModeToJSON(object: WindowMode): string {
  switch (object) {
    case WindowMode.WINDOW_MODE_UNSPECIFIED:
      return "WINDOW_MODE_UNSPECIFIED";
    case WindowMode.WINDOW_MODE_CONTINUOUS:
      return "WINDOW_MODE_CONTINUOUS";
    case WindowMode.WINDOW_MODE_TUMBLING:
      return "WINDOW_MODE_TUMBLING";
    case WindowMode.WINDOW_MODE_CDC:
      return "WINDOW_MODE_CDC";
    case WindowMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Graph {
  featureSets: FeatureSet[];
  resolvers: Resolver[];
  streamResolvers: StreamResolver[];
  sinkResolvers: SinkResolver[];
  /**
   * database_sources is deprecated; see database_sources_v2
   *
   * @deprecated
   */
  databaseSources: DatabaseSource[];
  /**
   * stream_sources is deprecated; see stream_sources_v2
   *
   * @deprecated
   */
  streamSources: StreamSource[];
  namedQueries: NamedQuery[];
  databaseSourcesV2: DatabaseSource1[];
  databaseSourceGroups: DatabaseSourceGroup[];
  streamSourcesV2: StreamSource2[];
}

export interface OverlayGraph {
  featureSets: FeatureSet[];
  /** New feature fields to be added to existing feature classes */
  featureFields: FeatureType[];
  resolvers: Resolver[];
  generatedSqlResolvers: SQLResolverInfo[];
}

export interface NamedQuery {
  name: string;
  queryVersion?: string | undefined;
  input: string[];
  output: string[];
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  meta: { [key: string]: string };
  staleness: { [key: string]: Duration };
  plannerOptions: { [key: string]: string };
  fileName: string;
  /** required */
  deploymentId?: string | undefined;
  sourceFileReference?: SourceFileReference | undefined;
  additionalLoggedFeatures: string[];
  validPlanNotRequired?: boolean | undefined;
}

export interface NamedQuery_MetaEntry {
  key: string;
  value: string;
}

export interface NamedQuery_StalenessEntry {
  key: string;
  value: Duration | undefined;
}

export interface NamedQuery_PlannerOptionsEntry {
  key: string;
  value: string;
}

export interface FeatureSet {
  name: string;
  features: FeatureType[];
  maxStalenessDuration: Duration | undefined;
  isSingleton: boolean;
  tags: string[];
  owner?:
    | string
    | undefined;
  /** The docstring of the class on which the features are defined. */
  doc?: string | undefined;
  etlOfflineToOnline?: boolean | undefined;
  classPath?: string | undefined;
}

export interface FeatureType {
  scalar?: ScalarFeatureType | undefined;
  hasOne?: HasOneFeatureType | undefined;
  hasMany?: HasManyFeatureType | undefined;
  featureTime?: FeatureTimeFeatureType | undefined;
  windowed?: WindowedFeatureType | undefined;
  groupBy?: GroupByFeatureType | undefined;
}

export interface FeatureReference {
  name: string;
  namespace: string;
  path: FeatureReference[];
  df: DataFrameType | undefined;
}

export interface DataFrameType {
  rootNamespace: string;
  requiredColumns: FeatureReference[];
  optionalColumns: FeatureReference[];
  filter: LogicalExprNode | undefined;
  limit?: number | undefined;
}

export interface GroupByFeatureType {
  name: string;
  namespace: string;
  isNullable: boolean;
  internalVersion?: number | undefined;
  arrowType: ArrowType | undefined;
  aggregation: WindowAggregation | undefined;
  windowDurations: Duration[];
  expression: LogicalExprNode | undefined;
  defaultValue: ScalarValue | undefined;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  validations: FeatureValidation[];
  attributeName: string;
  unversionedAttributeName: string;
}

export interface ScalarFeatureType {
  name: string;
  namespace: string;
  isAutogenerated: boolean;
  noDisplay: boolean;
  isPrimary: boolean;
  isNullable: boolean;
  internalVersion?:
    | number
    | undefined;
  /**
   * This represents whatever arg the user passed into the `feature()` call.
   * If both set, this should take precedence over the value in `FeatureSet`.
   * If unset here, the value in `FeatureSet` should be used.
   */
  maxStalenessDuration: Duration | undefined;
  offlineTtlDuration: Duration | undefined;
  arrowType: ArrowType | undefined;
  version: VersionInfo | undefined;
  windowInfo: WindowInfo | undefined;
  defaultValue: ScalarValue | undefined;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  expression: LogicalExprNode | undefined;
  validations: FeatureValidation[];
  lastFor:
    | FeatureReference
    | undefined;
  /**
   * This represents whatever arg the user passed into the `feature()` call.
   * If both set, this should take precedence over the value in `FeatureSet`.
   * If unset here, the value in `FeatureSet` should be used.
   */
  etlOfflineToOnline?: boolean | undefined;
  isDistancePseudofeature: boolean;
  attributeName: string;
  /** Whether the user marked the feature as deprecated. */
  isDeprecated: boolean;
  cacheStrategy: CacheStrategy;
  /** optional because proto default is false, but chalk defaults to true */
  storeOnline?:
    | boolean
    | undefined;
  /** optional because proto default is false, but chalk defaults to true */
  storeOffline?: boolean | undefined;
  unversionedAttributeName: string;
  richTypeInfo?: FeatureRichTypeInfo | undefined;
}

export interface HasOneFeatureType {
  name: string;
  namespace: string;
  foreignNamespace: string;
  join: LogicalExprNode | undefined;
  isNullable: boolean;
  isAutogenerated: boolean;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  attributeName: string;
  unversionedAttributeName: string;
}

export interface HasManyFeatureType {
  name: string;
  namespace: string;
  foreignNamespace: string;
  join: LogicalExprNode | undefined;
  isAutogenerated: boolean;
  maxStalenessDuration: Duration | undefined;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  attributeName: string;
  unversionedAttributeName: string;
}

export interface FeatureTimeFeatureType {
  name: string;
  namespace: string;
  isAutogenerated: boolean;
  tags: string[];
  description?: string | undefined;
  owner?: string | undefined;
  attributeName: string;
}

export interface WindowedFeatureType {
  name: string;
  namespace: string;
  isAutogenerated: boolean;
  windowDurations: Duration[];
  attributeName: string;
  unversionedAttributeName: string;
}

export interface WindowAggregation {
  namespace: string;
  groupBy: FeatureReference[];
  bucketDuration: Duration | undefined;
  aggregation: string;
  aggregateOn?: FeatureReference | undefined;
  arrowType: ArrowType | undefined;
  filters: LogicalExprNode[];
  /**
   * The resolver to use for back-filling the materialized aggregate.
   * If not provided, the data will be back filled using the resolver
   * that would run for an offline query.
   */
  backfillResolver?:
    | string
    | undefined;
  /**
   * The amount of time before the start of the previous backfill
   * to consider when running the backfill resolver. Set this parameter
   * to the be equal to the latest arriving data in the backfill window.
   */
  backfillLookbackDuration?:
    | Duration
    | undefined;
  /**
   * The time at which to start back filling the materialized aggregate.
   * If not provided, the backfill consider the earliest available data returned
   * by the `backfill_resolver`.
   */
  backfillStartTime?:
    | Date
    | undefined;
  /**
   * The resolver to use for continuous updates to the materialized aggregate.
   * If not provided, the data will be updated using the resolver that would run
   * for an online query.
   */
  continuousResolver?:
    | string
    | undefined;
  /**
   * The period for which to use the continuous resolver, instead
   * of relying upon the last backfill. If not provided, and a continuous
   * resolver is provided, this will be set to backfill_lookback_duration.
   */
  continuousBufferDuration?:
    | Duration
    | undefined;
  /**
   * A crontab or duration string to specify the schedule for back filling the
   * materialized aggregate.
   */
  backfillSchedule?:
    | string
    | undefined;
  /** The lower bound of the first bucket. All buckets are aligned to this time. */
  bucketStart: Date | undefined;
}

export interface WindowInfo {
  duration: Duration | undefined;
  aggregation?: WindowAggregation | undefined;
}

export interface FeatureInput {
  feature: FeatureReference | undefined;
  defaultValue: ScalarValue | undefined;
}

export interface ResolverInput {
  feature?: FeatureInput | undefined;
  df?: DataFrameType | undefined;
  state?: ResolverState | undefined;
}

export interface ResolverOutput {
  feature?: FeatureReference | undefined;
  df?: DataFrameType | undefined;
}

export interface Resolver {
  fqn: string;
  kind: ResolverKind;
  inputs: ResolverInput[];
  outputs: ResolverOutput[];
  isGenerator: boolean;
  /**
   * data_sources is deprecated; see data_sources_v2
   *
   * @deprecated
   */
  dataSources: DatabaseSourceReference[];
  machineType?: string | undefined;
  tags: string[];
  owner?:
    | string
    | undefined;
  /** The docstring of the python function */
  doc?: string | undefined;
  environments: string[];
  timeoutDuration: Duration | undefined;
  schedule: Schedule | undefined;
  when: LogicalExprNode | undefined;
  cronFilter: CronFilterWithFeatureArgs | undefined;
  function: FunctionReference | undefined;
  resourceHint: ResourceHint;
  isStatic: boolean;
  isTotal?: boolean | undefined;
  uniqueOn: string[];
  partitionedBy: string[];
  dataSourcesV2: DatabaseSourceReference3[];
  staticOperation: LogicalExprNode | undefined;
  sqlSettings?: SQLResolverSettings | undefined;
}

export interface SinkResolver {
  fqn: string;
  inputs: ResolverInput[];
  bufferSize?: number | undefined;
  debounceDuration: Duration | undefined;
  maxDelayDuration: Duration | undefined;
  upsert: boolean;
  /**
   * stream_source is deprecated; see stream_source_v2
   *
   * @deprecated
   */
  streamSource?:
    | StreamSourceReference
    | undefined;
  /**
   * database_source is deprecated; see database_source_v2
   *
   * @deprecated
   */
  databaseSource?: DatabaseSourceReference | undefined;
  streamSourceV2?: StreamSourceReference4 | undefined;
  databaseSourceV2?: DatabaseSourceReference3 | undefined;
  machineType?: string | undefined;
  doc?: string | undefined;
  owner?: string | undefined;
  environments: string[];
  timeoutDuration: Duration | undefined;
  function: FunctionReference | undefined;
}

export interface ParseInfo {
  parseFunction: FunctionReference | undefined;
  parseFunctionInputType: ArrowType | undefined;
  parseFunctionOutputType: ArrowType | undefined;
  isParseFunctionOutputOptional: boolean;
  /** These are the `__name__` of the type of the parameter/return annotations. */
  parseFunctionInputTypeName: string;
  parseFunctionOutputTypeName: string;
}

export interface StreamResolver {
  fqn: string;
  params: StreamResolverParam[];
  outputs: ResolverOutput[];
  explicitSchema: ArrowType | undefined;
  keys: StreamKey[];
  /** @deprecated */
  source: StreamSourceReference | undefined;
  parseInfo: ParseInfo | undefined;
  mode: WindowMode;
  environments: string[];
  timeoutDuration: Duration | undefined;
  timestampAttributeName?: string | undefined;
  owner?: string | undefined;
  doc?: string | undefined;
  machineType?: string | undefined;
  function: FunctionReference | undefined;
  sourceV2: StreamSourceReference4 | undefined;
  updatesMaterializedAggregations: boolean;
}

export interface ResolverState {
  initial: ScalarValue | undefined;
  arrowType: ArrowType | undefined;
}

export interface StreamResolverParam {
  message?: StreamResolverParamMessage | undefined;
  messageWindow?: StreamResolverParamMessageWindow | undefined;
  state?: ResolverState | undefined;
}

export interface StreamResolverParamMessageWindow {
  name: string;
  arrowType: ArrowType | undefined;
}

export interface StreamResolverParamMessage {
  name: string;
  arrowType: ArrowType | undefined;
}

export interface FunctionReference {
  name: string;
  module: string;
  fileName: string;
  functionDefinition: string;
  sourceLine?: number | undefined;
  capturedGlobals: FunctionReferenceCapturedGlobal[];
}

export interface FunctionReferenceCapturedGlobal {
  globalName: string;
  builtin?: FunctionGlobalCapturedBuiltin | undefined;
  featureClass?: FunctionGlobalCapturedFeatureClass | undefined;
  enum?: FunctionGlobalCapturedEnum | undefined;
  module?: FunctionGlobalCapturedModule | undefined;
  moduleMember?: FunctionGlobalCapturedModuleMember | undefined;
  function?: FunctionGlobalCapturedFunction | undefined;
  struct?: FunctionGlobalCapturedStruct | undefined;
  variable?: FunctionGlobalCapturedVariable | undefined;
  proto?: FunctionGlobalCapturedProto | undefined;
  sourceReference?: SourceFileReference | undefined;
}

export interface FunctionGlobalCapturedBuiltin {
  builtinName: string;
}

export interface FunctionGlobalCapturedVariable {
  module: string;
  name: string;
}

export interface FunctionGlobalCapturedStruct {
  module: string;
  name: string;
  paDtype: ArrowType | undefined;
}

export interface FunctionGlobalCapturedEnum {
  module: string;
  name: string;
  memberMap: { [key: string]: ScalarValue };
  bases: ArrowType[];
}

export interface FunctionGlobalCapturedEnum_MemberMapEntry {
  key: string;
  value: ScalarValue | undefined;
}

export interface FunctionGlobalCapturedFeatureClass {
  featureClassName: string;
}

export interface FunctionGlobalCapturedModule {
  name: string;
}

export interface FunctionGlobalCapturedModuleMember {
  /** Imported classes/functions, e.g. json.encoder.JSONEncoder */
  moduleName: string;
  /** name of the class or function, e.g. `JSONEncoder``. Not present for modules. */
  qualname: string;
}

export interface FunctionGlobalCapturedFunction {
  source: string;
  capturedGlobals: FunctionReferenceCapturedGlobal[];
  module?: string | undefined;
  name: string;
}

export interface FunctionGlobalCapturedProto {
  module: string;
  name: string;
  /** @deprecated */
  fd: Uint8Array;
  serializedFd: Uint8Array;
  paDtype: ArrowType | undefined;
  fullName: string;
}

export interface SourceFileReference {
  range: Range | undefined;
  code?: string | undefined;
  fileName: string;
}

export interface StreamKey {
  key: string;
  feature: FeatureReference | undefined;
}

export interface SQLResolverSettings {
  finalizer: Finalizer;
  incrementalSettings?: IncrementalSettings | undefined;
  fieldsRootFqn: { [key: string]: string };
  escapedParamNameToFqn: { [key: string]: string };
}

export interface SQLResolverSettings_FieldsRootFqnEntry {
  key: string;
  value: string;
}

export interface SQLResolverSettings_EscapedParamNameToFqnEntry {
  key: string;
  value: string;
}

export interface IncrementalSettings {
  mode: IncrementalMode;
  lookbackPeriod?: Duration | undefined;
  incrementalColumn?: string | undefined;
  timestampMode: IncrementalTimestampMode;
}

export interface SQLResolverCommentDict {
  total?: boolean | undefined;
  source?: string | undefined;
  resolves?: string | undefined;
  namespace?: string | undefined;
  incremental?: IncrementalSettings | undefined;
  tags: string[];
  environment: string[];
  count?: Finalizer | undefined;
  cron?: Schedule | undefined;
  machineType?: string | undefined;
  owner?: string | undefined;
  type?: string | undefined;
  timeout?: string | undefined;
  fields: { [key: string]: string };
  uniqueOn: string[];
  partitionedBy: string[];
}

export interface SQLResolverCommentDict_FieldsEntry {
  key: string;
  value: string;
}

export interface SQLResolverInfo {
  /** Resolver name */
  name: string;
  /** Filepath of the resolver, or None if it doesn't come from a file in the deployment. */
  filepath?:
    | string
    | undefined;
  /** Source of the SQL query */
  sqlString: string;
  /** This overrides any comments present in the sql string itself (e.g. `-- tags: a,b,...`) */
  overrideCommentDict?: SQLResolverCommentDict | undefined;
}

export interface CronFilterWithFeatureArgs {
  filter: FunctionReference | undefined;
  args: FeatureReference[];
}

export interface Schedule {
  crontab?: string | undefined;
  duration?: Duration | undefined;
  filter: FunctionReference | undefined;
  sample: FunctionReference | undefined;
}

export interface FeatureValidation {
  /**
   * Deprecated since they don't store the full type information (e.g. different numeric types)
   * Use the *_arrow fields (6-9) instead.
   *
   * @deprecated
   */
  min?:
    | number
    | undefined;
  /** @deprecated */
  max?:
    | number
    | undefined;
  /** @deprecated */
  minLength?:
    | number
    | undefined;
  /** @deprecated */
  maxLength?: number | undefined;
  minArrow?: ScalarValue | undefined;
  maxArrow?: ScalarValue | undefined;
  minLengthArrow?: ScalarValue | undefined;
  maxLengthArrow?: ScalarValue | undefined;
  contains?: ScalarValue | undefined;
  strict: boolean;
}

export interface VersionInfo {
  default: number;
  maximum: number;
}

export interface StrictValidation {
  feature: FeatureReference | undefined;
  validations: FeatureValidation[];
}

export interface FeatureEncoder {
  globalFunctionReference?: FunctionGlobalCapturedFunction | undefined;
}

export interface FeatureDecoder {
  globalFunctionReference?: FunctionGlobalCapturedFunction | undefined;
}

/** Represents a generic typ annotation, e.g. Dict[str, List[Optional[SomeClass]]] etc. */
export interface RichClassType {
  moduleName: string;
  qualname: string;
  /** The type parameters inside the [] */
  params: RichClassType[];
}

export interface FeatureRichType {
  classType?: RichClassType | undefined;
}

export interface FeatureRichTypeInfo {
  richTypeIsSameAsPrimitiveType: boolean;
  encoder?: FeatureEncoder | undefined;
  decoder?: FeatureDecoder | undefined;
  richType?: FeatureRichType | undefined;
  richTypeName?: string | undefined;
}

function createBaseGraph(): Graph {
  return {
    featureSets: [],
    resolvers: [],
    streamResolvers: [],
    sinkResolvers: [],
    databaseSources: [],
    streamSources: [],
    namedQueries: [],
    databaseSourcesV2: [],
    databaseSourceGroups: [],
    streamSourcesV2: [],
  };
}

export const Graph: MessageFns<Graph> = {
  encode(message: Graph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.featureSets) {
      FeatureSet.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.resolvers) {
      Resolver.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.streamResolvers) {
      StreamResolver.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.sinkResolvers) {
      SinkResolver.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.databaseSources) {
      DatabaseSource.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.streamSources) {
      StreamSource.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.namedQueries) {
      NamedQuery.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.databaseSourcesV2) {
      DatabaseSource1.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.databaseSourceGroups) {
      DatabaseSourceGroup.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.streamSourcesV2) {
      StreamSource2.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Graph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureSets.push(FeatureSet.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resolvers.push(Resolver.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.streamResolvers.push(StreamResolver.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sinkResolvers.push(SinkResolver.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.databaseSources.push(DatabaseSource.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streamSources.push(StreamSource.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.namedQueries.push(NamedQuery.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.databaseSourcesV2.push(DatabaseSource1.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.databaseSourceGroups.push(DatabaseSourceGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.streamSourcesV2.push(StreamSource2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Graph {
    return {
      featureSets: globalThis.Array.isArray(object?.featureSets)
        ? object.featureSets.map((e: any) => FeatureSet.fromJSON(e))
        : [],
      resolvers: globalThis.Array.isArray(object?.resolvers)
        ? object.resolvers.map((e: any) => Resolver.fromJSON(e))
        : [],
      streamResolvers: globalThis.Array.isArray(object?.streamResolvers)
        ? object.streamResolvers.map((e: any) => StreamResolver.fromJSON(e))
        : [],
      sinkResolvers: globalThis.Array.isArray(object?.sinkResolvers)
        ? object.sinkResolvers.map((e: any) => SinkResolver.fromJSON(e))
        : [],
      databaseSources: globalThis.Array.isArray(object?.databaseSources)
        ? object.databaseSources.map((e: any) => DatabaseSource.fromJSON(e))
        : [],
      streamSources: globalThis.Array.isArray(object?.streamSources)
        ? object.streamSources.map((e: any) => StreamSource.fromJSON(e))
        : [],
      namedQueries: globalThis.Array.isArray(object?.namedQueries)
        ? object.namedQueries.map((e: any) => NamedQuery.fromJSON(e))
        : [],
      databaseSourcesV2: globalThis.Array.isArray(object?.databaseSourcesV2)
        ? object.databaseSourcesV2.map((e: any) => DatabaseSource1.fromJSON(e))
        : [],
      databaseSourceGroups: globalThis.Array.isArray(object?.databaseSourceGroups)
        ? object.databaseSourceGroups.map((e: any) => DatabaseSourceGroup.fromJSON(e))
        : [],
      streamSourcesV2: globalThis.Array.isArray(object?.streamSourcesV2)
        ? object.streamSourcesV2.map((e: any) => StreamSource2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Graph): unknown {
    const obj: any = {};
    if (message.featureSets?.length) {
      obj.featureSets = message.featureSets.map((e) => FeatureSet.toJSON(e));
    }
    if (message.resolvers?.length) {
      obj.resolvers = message.resolvers.map((e) => Resolver.toJSON(e));
    }
    if (message.streamResolvers?.length) {
      obj.streamResolvers = message.streamResolvers.map((e) => StreamResolver.toJSON(e));
    }
    if (message.sinkResolvers?.length) {
      obj.sinkResolvers = message.sinkResolvers.map((e) => SinkResolver.toJSON(e));
    }
    if (message.databaseSources?.length) {
      obj.databaseSources = message.databaseSources.map((e) => DatabaseSource.toJSON(e));
    }
    if (message.streamSources?.length) {
      obj.streamSources = message.streamSources.map((e) => StreamSource.toJSON(e));
    }
    if (message.namedQueries?.length) {
      obj.namedQueries = message.namedQueries.map((e) => NamedQuery.toJSON(e));
    }
    if (message.databaseSourcesV2?.length) {
      obj.databaseSourcesV2 = message.databaseSourcesV2.map((e) => DatabaseSource1.toJSON(e));
    }
    if (message.databaseSourceGroups?.length) {
      obj.databaseSourceGroups = message.databaseSourceGroups.map((e) => DatabaseSourceGroup.toJSON(e));
    }
    if (message.streamSourcesV2?.length) {
      obj.streamSourcesV2 = message.streamSourcesV2.map((e) => StreamSource2.toJSON(e));
    }
    return obj;
  },
};

function createBaseOverlayGraph(): OverlayGraph {
  return { featureSets: [], featureFields: [], resolvers: [], generatedSqlResolvers: [] };
}

export const OverlayGraph: MessageFns<OverlayGraph> = {
  encode(message: OverlayGraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.featureSets) {
      FeatureSet.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.featureFields) {
      FeatureType.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.resolvers) {
      Resolver.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.generatedSqlResolvers) {
      SQLResolverInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverlayGraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlayGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureSets.push(FeatureSet.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.featureFields.push(FeatureType.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resolvers.push(Resolver.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.generatedSqlResolvers.push(SQLResolverInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverlayGraph {
    return {
      featureSets: globalThis.Array.isArray(object?.featureSets)
        ? object.featureSets.map((e: any) => FeatureSet.fromJSON(e))
        : [],
      featureFields: globalThis.Array.isArray(object?.featureFields)
        ? object.featureFields.map((e: any) => FeatureType.fromJSON(e))
        : [],
      resolvers: globalThis.Array.isArray(object?.resolvers)
        ? object.resolvers.map((e: any) => Resolver.fromJSON(e))
        : [],
      generatedSqlResolvers: globalThis.Array.isArray(object?.generatedSqlResolvers)
        ? object.generatedSqlResolvers.map((e: any) => SQLResolverInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OverlayGraph): unknown {
    const obj: any = {};
    if (message.featureSets?.length) {
      obj.featureSets = message.featureSets.map((e) => FeatureSet.toJSON(e));
    }
    if (message.featureFields?.length) {
      obj.featureFields = message.featureFields.map((e) => FeatureType.toJSON(e));
    }
    if (message.resolvers?.length) {
      obj.resolvers = message.resolvers.map((e) => Resolver.toJSON(e));
    }
    if (message.generatedSqlResolvers?.length) {
      obj.generatedSqlResolvers = message.generatedSqlResolvers.map((e) => SQLResolverInfo.toJSON(e));
    }
    return obj;
  },
};

function createBaseNamedQuery(): NamedQuery {
  return {
    name: "",
    queryVersion: undefined,
    input: [],
    output: [],
    tags: [],
    description: undefined,
    owner: undefined,
    meta: {},
    staleness: {},
    plannerOptions: {},
    fileName: "",
    deploymentId: undefined,
    sourceFileReference: undefined,
    additionalLoggedFeatures: [],
    validPlanNotRequired: undefined,
  };
}

export const NamedQuery: MessageFns<NamedQuery> = {
  encode(message: NamedQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.queryVersion !== undefined) {
      writer.uint32(18).string(message.queryVersion);
    }
    for (const v of message.input) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.output) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(58).string(message.owner);
    }
    Object.entries(message.meta).forEach(([key, value]) => {
      NamedQuery_MetaEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    Object.entries(message.staleness).forEach(([key, value]) => {
      NamedQuery_StalenessEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.plannerOptions).forEach(([key, value]) => {
      NamedQuery_PlannerOptionsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.fileName !== "") {
      writer.uint32(90).string(message.fileName);
    }
    if (message.deploymentId !== undefined) {
      writer.uint32(98).string(message.deploymentId);
    }
    if (message.sourceFileReference !== undefined) {
      SourceFileReference.encode(message.sourceFileReference, writer.uint32(106).fork()).join();
    }
    for (const v of message.additionalLoggedFeatures) {
      writer.uint32(114).string(v!);
    }
    if (message.validPlanNotRequired !== undefined) {
      writer.uint32(120).bool(message.validPlanNotRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queryVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = NamedQuery_MetaEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.meta[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = NamedQuery_StalenessEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.staleness[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = NamedQuery_PlannerOptionsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.plannerOptions[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sourceFileReference = SourceFileReference.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.additionalLoggedFeatures.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.validPlanNotRequired = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      queryVersion: isSet(object.queryVersion) ? globalThis.String(object.queryVersion) : undefined,
      input: globalThis.Array.isArray(object?.input) ? object.input.map((e: any) => globalThis.String(e)) : [],
      output: globalThis.Array.isArray(object?.output) ? object.output.map((e: any) => globalThis.String(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      meta: isObject(object.meta)
        ? Object.entries(object.meta).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      staleness: isObject(object.staleness)
        ? Object.entries(object.staleness).reduce<{ [key: string]: Duration }>((acc, [key, value]) => {
          acc[key] = Duration.fromJSON(value);
          return acc;
        }, {})
        : {},
      plannerOptions: isObject(object.plannerOptions)
        ? Object.entries(object.plannerOptions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      sourceFileReference: isSet(object.sourceFileReference)
        ? SourceFileReference.fromJSON(object.sourceFileReference)
        : undefined,
      additionalLoggedFeatures: globalThis.Array.isArray(object?.additionalLoggedFeatures)
        ? object.additionalLoggedFeatures.map((e: any) => globalThis.String(e))
        : [],
      validPlanNotRequired: isSet(object.validPlanNotRequired)
        ? globalThis.Boolean(object.validPlanNotRequired)
        : undefined,
    };
  },

  toJSON(message: NamedQuery): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.queryVersion !== undefined) {
      obj.queryVersion = message.queryVersion;
    }
    if (message.input?.length) {
      obj.input = message.input;
    }
    if (message.output?.length) {
      obj.output = message.output;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.meta) {
      const entries = Object.entries(message.meta);
      if (entries.length > 0) {
        obj.meta = {};
        entries.forEach(([k, v]) => {
          obj.meta[k] = v;
        });
      }
    }
    if (message.staleness) {
      const entries = Object.entries(message.staleness);
      if (entries.length > 0) {
        obj.staleness = {};
        entries.forEach(([k, v]) => {
          obj.staleness[k] = Duration.toJSON(v);
        });
      }
    }
    if (message.plannerOptions) {
      const entries = Object.entries(message.plannerOptions);
      if (entries.length > 0) {
        obj.plannerOptions = {};
        entries.forEach(([k, v]) => {
          obj.plannerOptions[k] = v;
        });
      }
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.sourceFileReference !== undefined) {
      obj.sourceFileReference = SourceFileReference.toJSON(message.sourceFileReference);
    }
    if (message.additionalLoggedFeatures?.length) {
      obj.additionalLoggedFeatures = message.additionalLoggedFeatures;
    }
    if (message.validPlanNotRequired !== undefined) {
      obj.validPlanNotRequired = message.validPlanNotRequired;
    }
    return obj;
  },
};

function createBaseNamedQuery_MetaEntry(): NamedQuery_MetaEntry {
  return { key: "", value: "" };
}

export const NamedQuery_MetaEntry: MessageFns<NamedQuery_MetaEntry> = {
  encode(message: NamedQuery_MetaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery_MetaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery_MetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery_MetaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NamedQuery_MetaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseNamedQuery_StalenessEntry(): NamedQuery_StalenessEntry {
  return { key: "", value: undefined };
}

export const NamedQuery_StalenessEntry: MessageFns<NamedQuery_StalenessEntry> = {
  encode(message: NamedQuery_StalenessEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Duration.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery_StalenessEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery_StalenessEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery_StalenessEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Duration.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NamedQuery_StalenessEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Duration.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseNamedQuery_PlannerOptionsEntry(): NamedQuery_PlannerOptionsEntry {
  return { key: "", value: "" };
}

export const NamedQuery_PlannerOptionsEntry: MessageFns<NamedQuery_PlannerOptionsEntry> = {
  encode(message: NamedQuery_PlannerOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedQuery_PlannerOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedQuery_PlannerOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedQuery_PlannerOptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NamedQuery_PlannerOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseFeatureSet(): FeatureSet {
  return {
    name: "",
    features: [],
    maxStalenessDuration: undefined,
    isSingleton: false,
    tags: [],
    owner: undefined,
    doc: undefined,
    etlOfflineToOnline: undefined,
    classPath: undefined,
  };
}

export const FeatureSet: MessageFns<FeatureSet> = {
  encode(message: FeatureSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.features) {
      FeatureType.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.maxStalenessDuration !== undefined) {
      Duration.encode(message.maxStalenessDuration, writer.uint32(26).fork()).join();
    }
    if (message.isSingleton !== false) {
      writer.uint32(32).bool(message.isSingleton);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.owner !== undefined) {
      writer.uint32(50).string(message.owner);
    }
    if (message.doc !== undefined) {
      writer.uint32(58).string(message.doc);
    }
    if (message.etlOfflineToOnline !== undefined) {
      writer.uint32(64).bool(message.etlOfflineToOnline);
    }
    if (message.classPath !== undefined) {
      writer.uint32(74).string(message.classPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.features.push(FeatureType.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxStalenessDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSingleton = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.classPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => FeatureType.fromJSON(e))
        : [],
      maxStalenessDuration: isSet(object.maxStalenessDuration)
        ? Duration.fromJSON(object.maxStalenessDuration)
        : undefined,
      isSingleton: isSet(object.isSingleton) ? globalThis.Boolean(object.isSingleton) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : undefined,
      classPath: isSet(object.classPath) ? globalThis.String(object.classPath) : undefined,
    };
  },

  toJSON(message: FeatureSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.features?.length) {
      obj.features = message.features.map((e) => FeatureType.toJSON(e));
    }
    if (message.maxStalenessDuration !== undefined) {
      obj.maxStalenessDuration = Duration.toJSON(message.maxStalenessDuration);
    }
    if (message.isSingleton !== false) {
      obj.isSingleton = message.isSingleton;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.etlOfflineToOnline !== undefined) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.classPath !== undefined) {
      obj.classPath = message.classPath;
    }
    return obj;
  },
};

function createBaseFeatureType(): FeatureType {
  return {
    scalar: undefined,
    hasOne: undefined,
    hasMany: undefined,
    featureTime: undefined,
    windowed: undefined,
    groupBy: undefined,
  };
}

export const FeatureType: MessageFns<FeatureType> = {
  encode(message: FeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scalar !== undefined) {
      ScalarFeatureType.encode(message.scalar, writer.uint32(10).fork()).join();
    }
    if (message.hasOne !== undefined) {
      HasOneFeatureType.encode(message.hasOne, writer.uint32(18).fork()).join();
    }
    if (message.hasMany !== undefined) {
      HasManyFeatureType.encode(message.hasMany, writer.uint32(26).fork()).join();
    }
    if (message.featureTime !== undefined) {
      FeatureTimeFeatureType.encode(message.featureTime, writer.uint32(34).fork()).join();
    }
    if (message.windowed !== undefined) {
      WindowedFeatureType.encode(message.windowed, writer.uint32(42).fork()).join();
    }
    if (message.groupBy !== undefined) {
      GroupByFeatureType.encode(message.groupBy, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scalar = ScalarFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hasOne = HasOneFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hasMany = HasManyFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.featureTime = FeatureTimeFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.windowed = WindowedFeatureType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.groupBy = GroupByFeatureType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureType {
    return {
      scalar: isSet(object.scalar) ? ScalarFeatureType.fromJSON(object.scalar) : undefined,
      hasOne: isSet(object.hasOne) ? HasOneFeatureType.fromJSON(object.hasOne) : undefined,
      hasMany: isSet(object.hasMany) ? HasManyFeatureType.fromJSON(object.hasMany) : undefined,
      featureTime: isSet(object.featureTime) ? FeatureTimeFeatureType.fromJSON(object.featureTime) : undefined,
      windowed: isSet(object.windowed) ? WindowedFeatureType.fromJSON(object.windowed) : undefined,
      groupBy: isSet(object.groupBy) ? GroupByFeatureType.fromJSON(object.groupBy) : undefined,
    };
  },

  toJSON(message: FeatureType): unknown {
    const obj: any = {};
    if (message.scalar !== undefined) {
      obj.scalar = ScalarFeatureType.toJSON(message.scalar);
    }
    if (message.hasOne !== undefined) {
      obj.hasOne = HasOneFeatureType.toJSON(message.hasOne);
    }
    if (message.hasMany !== undefined) {
      obj.hasMany = HasManyFeatureType.toJSON(message.hasMany);
    }
    if (message.featureTime !== undefined) {
      obj.featureTime = FeatureTimeFeatureType.toJSON(message.featureTime);
    }
    if (message.windowed !== undefined) {
      obj.windowed = WindowedFeatureType.toJSON(message.windowed);
    }
    if (message.groupBy !== undefined) {
      obj.groupBy = GroupByFeatureType.toJSON(message.groupBy);
    }
    return obj;
  },
};

function createBaseFeatureReference(): FeatureReference {
  return { name: "", namespace: "", path: [], df: undefined };
}

export const FeatureReference: MessageFns<FeatureReference> = {
  encode(message: FeatureReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    for (const v of message.path) {
      FeatureReference.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.df !== undefined) {
      DataFrameType.encode(message.df, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.df = DataFrameType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => FeatureReference.fromJSON(e)) : [],
      df: isSet(object.df) ? DataFrameType.fromJSON(object.df) : undefined,
    };
  },

  toJSON(message: FeatureReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => FeatureReference.toJSON(e));
    }
    if (message.df !== undefined) {
      obj.df = DataFrameType.toJSON(message.df);
    }
    return obj;
  },
};

function createBaseDataFrameType(): DataFrameType {
  return { rootNamespace: "", requiredColumns: [], optionalColumns: [], filter: undefined, limit: undefined };
}

export const DataFrameType: MessageFns<DataFrameType> = {
  encode(message: DataFrameType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootNamespace !== "") {
      writer.uint32(10).string(message.rootNamespace);
    }
    for (const v of message.requiredColumns) {
      FeatureReference.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.optionalColumns) {
      FeatureReference.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.filter !== undefined) {
      LogicalExprNode.encode(message.filter, writer.uint32(34).fork()).join();
    }
    if (message.limit !== undefined) {
      writer.uint32(40).uint64(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataFrameType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataFrameType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootNamespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requiredColumns.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.optionalColumns.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataFrameType {
    return {
      rootNamespace: isSet(object.rootNamespace) ? globalThis.String(object.rootNamespace) : "",
      requiredColumns: globalThis.Array.isArray(object?.requiredColumns)
        ? object.requiredColumns.map((e: any) => FeatureReference.fromJSON(e))
        : [],
      optionalColumns: globalThis.Array.isArray(object?.optionalColumns)
        ? object.optionalColumns.map((e: any) => FeatureReference.fromJSON(e))
        : [],
      filter: isSet(object.filter) ? LogicalExprNode.fromJSON(object.filter) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: DataFrameType): unknown {
    const obj: any = {};
    if (message.rootNamespace !== "") {
      obj.rootNamespace = message.rootNamespace;
    }
    if (message.requiredColumns?.length) {
      obj.requiredColumns = message.requiredColumns.map((e) => FeatureReference.toJSON(e));
    }
    if (message.optionalColumns?.length) {
      obj.optionalColumns = message.optionalColumns.map((e) => FeatureReference.toJSON(e));
    }
    if (message.filter !== undefined) {
      obj.filter = LogicalExprNode.toJSON(message.filter);
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },
};

function createBaseGroupByFeatureType(): GroupByFeatureType {
  return {
    name: "",
    namespace: "",
    isNullable: false,
    internalVersion: undefined,
    arrowType: undefined,
    aggregation: undefined,
    windowDurations: [],
    expression: undefined,
    defaultValue: undefined,
    tags: [],
    description: undefined,
    owner: undefined,
    validations: [],
    attributeName: "",
    unversionedAttributeName: "",
  };
}

export const GroupByFeatureType: MessageFns<GroupByFeatureType> = {
  encode(message: GroupByFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isNullable !== false) {
      writer.uint32(24).bool(message.isNullable);
    }
    if (message.internalVersion !== undefined) {
      writer.uint32(32).uint64(message.internalVersion);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(42).fork()).join();
    }
    if (message.aggregation !== undefined) {
      WindowAggregation.encode(message.aggregation, writer.uint32(50).fork()).join();
    }
    for (const v of message.windowDurations) {
      Duration.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.expression !== undefined) {
      LogicalExprNode.encode(message.expression, writer.uint32(66).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      ScalarValue.encode(message.defaultValue, writer.uint32(74).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(82).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(90).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(98).string(message.owner);
    }
    for (const v of message.validations) {
      FeatureValidation.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.attributeName !== "") {
      writer.uint32(114).string(message.attributeName);
    }
    if (message.unversionedAttributeName !== "") {
      writer.uint32(122).string(message.unversionedAttributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupByFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupByFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isNullable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.internalVersion = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.aggregation = WindowAggregation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.windowDurations.push(Duration.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expression = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.defaultValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.validations.push(FeatureValidation.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.unversionedAttributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupByFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isNullable: isSet(object.isNullable) ? globalThis.Boolean(object.isNullable) : false,
      internalVersion: isSet(object.internalVersion) ? globalThis.Number(object.internalVersion) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      aggregation: isSet(object.aggregation) ? WindowAggregation.fromJSON(object.aggregation) : undefined,
      windowDurations: globalThis.Array.isArray(object?.windowDurations)
        ? object.windowDurations.map((e: any) => Duration.fromJSON(e))
        : [],
      expression: isSet(object.expression) ? LogicalExprNode.fromJSON(object.expression) : undefined,
      defaultValue: isSet(object.defaultValue) ? ScalarValue.fromJSON(object.defaultValue) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => FeatureValidation.fromJSON(e))
        : [],
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      unversionedAttributeName: isSet(object.unversionedAttributeName)
        ? globalThis.String(object.unversionedAttributeName)
        : "",
    };
  },

  toJSON(message: GroupByFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isNullable !== false) {
      obj.isNullable = message.isNullable;
    }
    if (message.internalVersion !== undefined) {
      obj.internalVersion = Math.round(message.internalVersion);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.aggregation !== undefined) {
      obj.aggregation = WindowAggregation.toJSON(message.aggregation);
    }
    if (message.windowDurations?.length) {
      obj.windowDurations = message.windowDurations.map((e) => Duration.toJSON(e));
    }
    if (message.expression !== undefined) {
      obj.expression = LogicalExprNode.toJSON(message.expression);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = ScalarValue.toJSON(message.defaultValue);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => FeatureValidation.toJSON(e));
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.unversionedAttributeName !== "") {
      obj.unversionedAttributeName = message.unversionedAttributeName;
    }
    return obj;
  },
};

function createBaseScalarFeatureType(): ScalarFeatureType {
  return {
    name: "",
    namespace: "",
    isAutogenerated: false,
    noDisplay: false,
    isPrimary: false,
    isNullable: false,
    internalVersion: undefined,
    maxStalenessDuration: undefined,
    offlineTtlDuration: undefined,
    arrowType: undefined,
    version: undefined,
    windowInfo: undefined,
    defaultValue: undefined,
    tags: [],
    description: undefined,
    owner: undefined,
    expression: undefined,
    validations: [],
    lastFor: undefined,
    etlOfflineToOnline: undefined,
    isDistancePseudofeature: false,
    attributeName: "",
    isDeprecated: false,
    cacheStrategy: 0,
    storeOnline: undefined,
    storeOffline: undefined,
    unversionedAttributeName: "",
    richTypeInfo: undefined,
  };
}

export const ScalarFeatureType: MessageFns<ScalarFeatureType> = {
  encode(message: ScalarFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(24).bool(message.isAutogenerated);
    }
    if (message.noDisplay !== false) {
      writer.uint32(32).bool(message.noDisplay);
    }
    if (message.isPrimary !== false) {
      writer.uint32(40).bool(message.isPrimary);
    }
    if (message.isNullable !== false) {
      writer.uint32(48).bool(message.isNullable);
    }
    if (message.internalVersion !== undefined) {
      writer.uint32(56).uint64(message.internalVersion);
    }
    if (message.maxStalenessDuration !== undefined) {
      Duration.encode(message.maxStalenessDuration, writer.uint32(66).fork()).join();
    }
    if (message.offlineTtlDuration !== undefined) {
      Duration.encode(message.offlineTtlDuration, writer.uint32(82).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(90).fork()).join();
    }
    if (message.version !== undefined) {
      VersionInfo.encode(message.version, writer.uint32(98).fork()).join();
    }
    if (message.windowInfo !== undefined) {
      WindowInfo.encode(message.windowInfo, writer.uint32(106).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      ScalarValue.encode(message.defaultValue, writer.uint32(114).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(122).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(130).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(138).string(message.owner);
    }
    if (message.expression !== undefined) {
      LogicalExprNode.encode(message.expression, writer.uint32(146).fork()).join();
    }
    for (const v of message.validations) {
      FeatureValidation.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.lastFor !== undefined) {
      FeatureReference.encode(message.lastFor, writer.uint32(162).fork()).join();
    }
    if (message.etlOfflineToOnline !== undefined) {
      writer.uint32(168).bool(message.etlOfflineToOnline);
    }
    if (message.isDistancePseudofeature !== false) {
      writer.uint32(176).bool(message.isDistancePseudofeature);
    }
    if (message.attributeName !== "") {
      writer.uint32(186).string(message.attributeName);
    }
    if (message.isDeprecated !== false) {
      writer.uint32(192).bool(message.isDeprecated);
    }
    if (message.cacheStrategy !== 0) {
      writer.uint32(200).int32(message.cacheStrategy);
    }
    if (message.storeOnline !== undefined) {
      writer.uint32(208).bool(message.storeOnline);
    }
    if (message.storeOffline !== undefined) {
      writer.uint32(216).bool(message.storeOffline);
    }
    if (message.unversionedAttributeName !== "") {
      writer.uint32(226).string(message.unversionedAttributeName);
    }
    if (message.richTypeInfo !== undefined) {
      FeatureRichTypeInfo.encode(message.richTypeInfo, writer.uint32(234).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalarFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalarFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noDisplay = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isPrimary = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isNullable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.internalVersion = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.maxStalenessDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.offlineTtlDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.version = VersionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.windowInfo = WindowInfo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.defaultValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.expression = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.validations.push(FeatureValidation.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.lastFor = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.etlOfflineToOnline = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.isDistancePseudofeature = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.isDeprecated = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.cacheStrategy = reader.int32() as any;
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.storeOnline = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.storeOffline = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.unversionedAttributeName = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.richTypeInfo = FeatureRichTypeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalarFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      noDisplay: isSet(object.noDisplay) ? globalThis.Boolean(object.noDisplay) : false,
      isPrimary: isSet(object.isPrimary) ? globalThis.Boolean(object.isPrimary) : false,
      isNullable: isSet(object.isNullable) ? globalThis.Boolean(object.isNullable) : false,
      internalVersion: isSet(object.internalVersion) ? globalThis.Number(object.internalVersion) : undefined,
      maxStalenessDuration: isSet(object.maxStalenessDuration)
        ? Duration.fromJSON(object.maxStalenessDuration)
        : undefined,
      offlineTtlDuration: isSet(object.offlineTtlDuration) ? Duration.fromJSON(object.offlineTtlDuration) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      version: isSet(object.version) ? VersionInfo.fromJSON(object.version) : undefined,
      windowInfo: isSet(object.windowInfo) ? WindowInfo.fromJSON(object.windowInfo) : undefined,
      defaultValue: isSet(object.defaultValue) ? ScalarValue.fromJSON(object.defaultValue) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      expression: isSet(object.expression) ? LogicalExprNode.fromJSON(object.expression) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => FeatureValidation.fromJSON(e))
        : [],
      lastFor: isSet(object.lastFor) ? FeatureReference.fromJSON(object.lastFor) : undefined,
      etlOfflineToOnline: isSet(object.etlOfflineToOnline) ? globalThis.Boolean(object.etlOfflineToOnline) : undefined,
      isDistancePseudofeature: isSet(object.isDistancePseudofeature)
        ? globalThis.Boolean(object.isDistancePseudofeature)
        : false,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      isDeprecated: isSet(object.isDeprecated) ? globalThis.Boolean(object.isDeprecated) : false,
      cacheStrategy: isSet(object.cacheStrategy) ? cacheStrategyFromJSON(object.cacheStrategy) : 0,
      storeOnline: isSet(object.storeOnline) ? globalThis.Boolean(object.storeOnline) : undefined,
      storeOffline: isSet(object.storeOffline) ? globalThis.Boolean(object.storeOffline) : undefined,
      unversionedAttributeName: isSet(object.unversionedAttributeName)
        ? globalThis.String(object.unversionedAttributeName)
        : "",
      richTypeInfo: isSet(object.richTypeInfo) ? FeatureRichTypeInfo.fromJSON(object.richTypeInfo) : undefined,
    };
  },

  toJSON(message: ScalarFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.noDisplay !== false) {
      obj.noDisplay = message.noDisplay;
    }
    if (message.isPrimary !== false) {
      obj.isPrimary = message.isPrimary;
    }
    if (message.isNullable !== false) {
      obj.isNullable = message.isNullable;
    }
    if (message.internalVersion !== undefined) {
      obj.internalVersion = Math.round(message.internalVersion);
    }
    if (message.maxStalenessDuration !== undefined) {
      obj.maxStalenessDuration = Duration.toJSON(message.maxStalenessDuration);
    }
    if (message.offlineTtlDuration !== undefined) {
      obj.offlineTtlDuration = Duration.toJSON(message.offlineTtlDuration);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.version !== undefined) {
      obj.version = VersionInfo.toJSON(message.version);
    }
    if (message.windowInfo !== undefined) {
      obj.windowInfo = WindowInfo.toJSON(message.windowInfo);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = ScalarValue.toJSON(message.defaultValue);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.expression !== undefined) {
      obj.expression = LogicalExprNode.toJSON(message.expression);
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => FeatureValidation.toJSON(e));
    }
    if (message.lastFor !== undefined) {
      obj.lastFor = FeatureReference.toJSON(message.lastFor);
    }
    if (message.etlOfflineToOnline !== undefined) {
      obj.etlOfflineToOnline = message.etlOfflineToOnline;
    }
    if (message.isDistancePseudofeature !== false) {
      obj.isDistancePseudofeature = message.isDistancePseudofeature;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.isDeprecated !== false) {
      obj.isDeprecated = message.isDeprecated;
    }
    if (message.cacheStrategy !== 0) {
      obj.cacheStrategy = cacheStrategyToJSON(message.cacheStrategy);
    }
    if (message.storeOnline !== undefined) {
      obj.storeOnline = message.storeOnline;
    }
    if (message.storeOffline !== undefined) {
      obj.storeOffline = message.storeOffline;
    }
    if (message.unversionedAttributeName !== "") {
      obj.unversionedAttributeName = message.unversionedAttributeName;
    }
    if (message.richTypeInfo !== undefined) {
      obj.richTypeInfo = FeatureRichTypeInfo.toJSON(message.richTypeInfo);
    }
    return obj;
  },
};

function createBaseHasOneFeatureType(): HasOneFeatureType {
  return {
    name: "",
    namespace: "",
    foreignNamespace: "",
    join: undefined,
    isNullable: false,
    isAutogenerated: false,
    tags: [],
    description: undefined,
    owner: undefined,
    attributeName: "",
    unversionedAttributeName: "",
  };
}

export const HasOneFeatureType: MessageFns<HasOneFeatureType> = {
  encode(message: HasOneFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.foreignNamespace !== "") {
      writer.uint32(26).string(message.foreignNamespace);
    }
    if (message.join !== undefined) {
      LogicalExprNode.encode(message.join, writer.uint32(34).fork()).join();
    }
    if (message.isNullable !== false) {
      writer.uint32(40).bool(message.isNullable);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(48).bool(message.isAutogenerated);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(74).string(message.owner);
    }
    if (message.attributeName !== "") {
      writer.uint32(82).string(message.attributeName);
    }
    if (message.unversionedAttributeName !== "") {
      writer.uint32(90).string(message.unversionedAttributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HasOneFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHasOneFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.foreignNamespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.join = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isNullable = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.unversionedAttributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HasOneFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      foreignNamespace: isSet(object.foreignNamespace) ? globalThis.String(object.foreignNamespace) : "",
      join: isSet(object.join) ? LogicalExprNode.fromJSON(object.join) : undefined,
      isNullable: isSet(object.isNullable) ? globalThis.Boolean(object.isNullable) : false,
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      unversionedAttributeName: isSet(object.unversionedAttributeName)
        ? globalThis.String(object.unversionedAttributeName)
        : "",
    };
  },

  toJSON(message: HasOneFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.foreignNamespace !== "") {
      obj.foreignNamespace = message.foreignNamespace;
    }
    if (message.join !== undefined) {
      obj.join = LogicalExprNode.toJSON(message.join);
    }
    if (message.isNullable !== false) {
      obj.isNullable = message.isNullable;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.unversionedAttributeName !== "") {
      obj.unversionedAttributeName = message.unversionedAttributeName;
    }
    return obj;
  },
};

function createBaseHasManyFeatureType(): HasManyFeatureType {
  return {
    name: "",
    namespace: "",
    foreignNamespace: "",
    join: undefined,
    isAutogenerated: false,
    maxStalenessDuration: undefined,
    tags: [],
    description: undefined,
    owner: undefined,
    attributeName: "",
    unversionedAttributeName: "",
  };
}

export const HasManyFeatureType: MessageFns<HasManyFeatureType> = {
  encode(message: HasManyFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.foreignNamespace !== "") {
      writer.uint32(26).string(message.foreignNamespace);
    }
    if (message.join !== undefined) {
      LogicalExprNode.encode(message.join, writer.uint32(34).fork()).join();
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(40).bool(message.isAutogenerated);
    }
    if (message.maxStalenessDuration !== undefined) {
      Duration.encode(message.maxStalenessDuration, writer.uint32(50).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(74).string(message.owner);
    }
    if (message.attributeName !== "") {
      writer.uint32(82).string(message.attributeName);
    }
    if (message.unversionedAttributeName !== "") {
      writer.uint32(90).string(message.unversionedAttributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HasManyFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHasManyFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.foreignNamespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.join = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.maxStalenessDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.unversionedAttributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HasManyFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      foreignNamespace: isSet(object.foreignNamespace) ? globalThis.String(object.foreignNamespace) : "",
      join: isSet(object.join) ? LogicalExprNode.fromJSON(object.join) : undefined,
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      maxStalenessDuration: isSet(object.maxStalenessDuration)
        ? Duration.fromJSON(object.maxStalenessDuration)
        : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      unversionedAttributeName: isSet(object.unversionedAttributeName)
        ? globalThis.String(object.unversionedAttributeName)
        : "",
    };
  },

  toJSON(message: HasManyFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.foreignNamespace !== "") {
      obj.foreignNamespace = message.foreignNamespace;
    }
    if (message.join !== undefined) {
      obj.join = LogicalExprNode.toJSON(message.join);
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.maxStalenessDuration !== undefined) {
      obj.maxStalenessDuration = Duration.toJSON(message.maxStalenessDuration);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.unversionedAttributeName !== "") {
      obj.unversionedAttributeName = message.unversionedAttributeName;
    }
    return obj;
  },
};

function createBaseFeatureTimeFeatureType(): FeatureTimeFeatureType {
  return {
    name: "",
    namespace: "",
    isAutogenerated: false,
    tags: [],
    description: undefined,
    owner: undefined,
    attributeName: "",
  };
}

export const FeatureTimeFeatureType: MessageFns<FeatureTimeFeatureType> = {
  encode(message: FeatureTimeFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(24).bool(message.isAutogenerated);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(50).string(message.owner);
    }
    if (message.attributeName !== "") {
      writer.uint32(58).string(message.attributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureTimeFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureTimeFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureTimeFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
    };
  },

  toJSON(message: FeatureTimeFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    return obj;
  },
};

function createBaseWindowedFeatureType(): WindowedFeatureType {
  return {
    name: "",
    namespace: "",
    isAutogenerated: false,
    windowDurations: [],
    attributeName: "",
    unversionedAttributeName: "",
  };
}

export const WindowedFeatureType: MessageFns<WindowedFeatureType> = {
  encode(message: WindowedFeatureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.isAutogenerated !== false) {
      writer.uint32(24).bool(message.isAutogenerated);
    }
    for (const v of message.windowDurations) {
      Duration.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.attributeName !== "") {
      writer.uint32(42).string(message.attributeName);
    }
    if (message.unversionedAttributeName !== "") {
      writer.uint32(50).string(message.unversionedAttributeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowedFeatureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowedFeatureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isAutogenerated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowDurations.push(Duration.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.unversionedAttributeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowedFeatureType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      isAutogenerated: isSet(object.isAutogenerated) ? globalThis.Boolean(object.isAutogenerated) : false,
      windowDurations: globalThis.Array.isArray(object?.windowDurations)
        ? object.windowDurations.map((e: any) => Duration.fromJSON(e))
        : [],
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      unversionedAttributeName: isSet(object.unversionedAttributeName)
        ? globalThis.String(object.unversionedAttributeName)
        : "",
    };
  },

  toJSON(message: WindowedFeatureType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.isAutogenerated !== false) {
      obj.isAutogenerated = message.isAutogenerated;
    }
    if (message.windowDurations?.length) {
      obj.windowDurations = message.windowDurations.map((e) => Duration.toJSON(e));
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.unversionedAttributeName !== "") {
      obj.unversionedAttributeName = message.unversionedAttributeName;
    }
    return obj;
  },
};

function createBaseWindowAggregation(): WindowAggregation {
  return {
    namespace: "",
    groupBy: [],
    bucketDuration: undefined,
    aggregation: "",
    aggregateOn: undefined,
    arrowType: undefined,
    filters: [],
    backfillResolver: undefined,
    backfillLookbackDuration: undefined,
    backfillStartTime: undefined,
    continuousResolver: undefined,
    continuousBufferDuration: undefined,
    backfillSchedule: undefined,
    bucketStart: undefined,
  };
}

export const WindowAggregation: MessageFns<WindowAggregation> = {
  encode(message: WindowAggregation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    for (const v of message.groupBy) {
      FeatureReference.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.bucketDuration !== undefined) {
      Duration.encode(message.bucketDuration, writer.uint32(26).fork()).join();
    }
    if (message.aggregation !== "") {
      writer.uint32(34).string(message.aggregation);
    }
    if (message.aggregateOn !== undefined) {
      FeatureReference.encode(message.aggregateOn, writer.uint32(42).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(50).fork()).join();
    }
    for (const v of message.filters) {
      LogicalExprNode.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.backfillResolver !== undefined) {
      writer.uint32(66).string(message.backfillResolver);
    }
    if (message.backfillLookbackDuration !== undefined) {
      Duration.encode(message.backfillLookbackDuration, writer.uint32(74).fork()).join();
    }
    if (message.backfillStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.backfillStartTime), writer.uint32(82).fork()).join();
    }
    if (message.continuousResolver !== undefined) {
      writer.uint32(90).string(message.continuousResolver);
    }
    if (message.continuousBufferDuration !== undefined) {
      Duration.encode(message.continuousBufferDuration, writer.uint32(98).fork()).join();
    }
    if (message.backfillSchedule !== undefined) {
      writer.uint32(106).string(message.backfillSchedule);
    }
    if (message.bucketStart !== undefined) {
      Timestamp.encode(toTimestamp(message.bucketStart), writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowAggregation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowAggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupBy.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bucketDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.aggregation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aggregateOn = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.filters.push(LogicalExprNode.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.backfillResolver = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.backfillLookbackDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.backfillStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.continuousResolver = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.continuousBufferDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.backfillSchedule = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bucketStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowAggregation {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      groupBy: globalThis.Array.isArray(object?.groupBy)
        ? object.groupBy.map((e: any) => FeatureReference.fromJSON(e))
        : [],
      bucketDuration: isSet(object.bucketDuration) ? Duration.fromJSON(object.bucketDuration) : undefined,
      aggregation: isSet(object.aggregation) ? globalThis.String(object.aggregation) : "",
      aggregateOn: isSet(object.aggregateOn) ? FeatureReference.fromJSON(object.aggregateOn) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => LogicalExprNode.fromJSON(e))
        : [],
      backfillResolver: isSet(object.backfillResolver) ? globalThis.String(object.backfillResolver) : undefined,
      backfillLookbackDuration: isSet(object.backfillLookbackDuration)
        ? Duration.fromJSON(object.backfillLookbackDuration)
        : undefined,
      backfillStartTime: isSet(object.backfillStartTime) ? fromJsonTimestamp(object.backfillStartTime) : undefined,
      continuousResolver: isSet(object.continuousResolver) ? globalThis.String(object.continuousResolver) : undefined,
      continuousBufferDuration: isSet(object.continuousBufferDuration)
        ? Duration.fromJSON(object.continuousBufferDuration)
        : undefined,
      backfillSchedule: isSet(object.backfillSchedule) ? globalThis.String(object.backfillSchedule) : undefined,
      bucketStart: isSet(object.bucketStart) ? fromJsonTimestamp(object.bucketStart) : undefined,
    };
  },

  toJSON(message: WindowAggregation): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.groupBy?.length) {
      obj.groupBy = message.groupBy.map((e) => FeatureReference.toJSON(e));
    }
    if (message.bucketDuration !== undefined) {
      obj.bucketDuration = Duration.toJSON(message.bucketDuration);
    }
    if (message.aggregation !== "") {
      obj.aggregation = message.aggregation;
    }
    if (message.aggregateOn !== undefined) {
      obj.aggregateOn = FeatureReference.toJSON(message.aggregateOn);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => LogicalExprNode.toJSON(e));
    }
    if (message.backfillResolver !== undefined) {
      obj.backfillResolver = message.backfillResolver;
    }
    if (message.backfillLookbackDuration !== undefined) {
      obj.backfillLookbackDuration = Duration.toJSON(message.backfillLookbackDuration);
    }
    if (message.backfillStartTime !== undefined) {
      obj.backfillStartTime = message.backfillStartTime.toISOString();
    }
    if (message.continuousResolver !== undefined) {
      obj.continuousResolver = message.continuousResolver;
    }
    if (message.continuousBufferDuration !== undefined) {
      obj.continuousBufferDuration = Duration.toJSON(message.continuousBufferDuration);
    }
    if (message.backfillSchedule !== undefined) {
      obj.backfillSchedule = message.backfillSchedule;
    }
    if (message.bucketStart !== undefined) {
      obj.bucketStart = message.bucketStart.toISOString();
    }
    return obj;
  },
};

function createBaseWindowInfo(): WindowInfo {
  return { duration: undefined, aggregation: undefined };
}

export const WindowInfo: MessageFns<WindowInfo> = {
  encode(message: WindowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    if (message.aggregation !== undefined) {
      WindowAggregation.encode(message.aggregation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aggregation = WindowAggregation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowInfo {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      aggregation: isSet(object.aggregation) ? WindowAggregation.fromJSON(object.aggregation) : undefined,
    };
  },

  toJSON(message: WindowInfo): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.aggregation !== undefined) {
      obj.aggregation = WindowAggregation.toJSON(message.aggregation);
    }
    return obj;
  },
};

function createBaseFeatureInput(): FeatureInput {
  return { feature: undefined, defaultValue: undefined };
}

export const FeatureInput: MessageFns<FeatureInput> = {
  encode(message: FeatureInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      ScalarValue.encode(message.defaultValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultValue = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureInput {
    return {
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
      defaultValue: isSet(object.defaultValue) ? ScalarValue.fromJSON(object.defaultValue) : undefined,
    };
  },

  toJSON(message: FeatureInput): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = ScalarValue.toJSON(message.defaultValue);
    }
    return obj;
  },
};

function createBaseResolverInput(): ResolverInput {
  return { feature: undefined, df: undefined, state: undefined };
}

export const ResolverInput: MessageFns<ResolverInput> = {
  encode(message: ResolverInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureInput.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.df !== undefined) {
      DataFrameType.encode(message.df, writer.uint32(18).fork()).join();
    }
    if (message.state !== undefined) {
      ResolverState.encode(message.state, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolverInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolverInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureInput.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.df = DataFrameType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = ResolverState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolverInput {
    return {
      feature: isSet(object.feature) ? FeatureInput.fromJSON(object.feature) : undefined,
      df: isSet(object.df) ? DataFrameType.fromJSON(object.df) : undefined,
      state: isSet(object.state) ? ResolverState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: ResolverInput): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureInput.toJSON(message.feature);
    }
    if (message.df !== undefined) {
      obj.df = DataFrameType.toJSON(message.df);
    }
    if (message.state !== undefined) {
      obj.state = ResolverState.toJSON(message.state);
    }
    return obj;
  },
};

function createBaseResolverOutput(): ResolverOutput {
  return { feature: undefined, df: undefined };
}

export const ResolverOutput: MessageFns<ResolverOutput> = {
  encode(message: ResolverOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.df !== undefined) {
      DataFrameType.encode(message.df, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolverOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolverOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.df = DataFrameType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolverOutput {
    return {
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
      df: isSet(object.df) ? DataFrameType.fromJSON(object.df) : undefined,
    };
  },

  toJSON(message: ResolverOutput): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    if (message.df !== undefined) {
      obj.df = DataFrameType.toJSON(message.df);
    }
    return obj;
  },
};

function createBaseResolver(): Resolver {
  return {
    fqn: "",
    kind: 0,
    inputs: [],
    outputs: [],
    isGenerator: false,
    dataSources: [],
    machineType: undefined,
    tags: [],
    owner: undefined,
    doc: undefined,
    environments: [],
    timeoutDuration: undefined,
    schedule: undefined,
    when: undefined,
    cronFilter: undefined,
    function: undefined,
    resourceHint: 0,
    isStatic: false,
    isTotal: undefined,
    uniqueOn: [],
    partitionedBy: [],
    dataSourcesV2: [],
    staticOperation: undefined,
    sqlSettings: undefined,
  };
}

export const Resolver: MessageFns<Resolver> = {
  encode(message: Resolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    if (message.kind !== 0) {
      writer.uint32(16).int32(message.kind);
    }
    for (const v of message.inputs) {
      ResolverInput.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.outputs) {
      ResolverOutput.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.isGenerator !== false) {
      writer.uint32(40).bool(message.isGenerator);
    }
    for (const v of message.dataSources) {
      DatabaseSourceReference.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.machineType !== undefined) {
      writer.uint32(58).string(message.machineType);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.owner !== undefined) {
      writer.uint32(74).string(message.owner);
    }
    if (message.doc !== undefined) {
      writer.uint32(82).string(message.doc);
    }
    for (const v of message.environments) {
      writer.uint32(90).string(v!);
    }
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(98).fork()).join();
    }
    if (message.schedule !== undefined) {
      Schedule.encode(message.schedule, writer.uint32(106).fork()).join();
    }
    if (message.when !== undefined) {
      LogicalExprNode.encode(message.when, writer.uint32(114).fork()).join();
    }
    if (message.cronFilter !== undefined) {
      CronFilterWithFeatureArgs.encode(message.cronFilter, writer.uint32(122).fork()).join();
    }
    if (message.function !== undefined) {
      FunctionReference.encode(message.function, writer.uint32(130).fork()).join();
    }
    if (message.resourceHint !== 0) {
      writer.uint32(136).int32(message.resourceHint);
    }
    if (message.isStatic !== false) {
      writer.uint32(144).bool(message.isStatic);
    }
    if (message.isTotal !== undefined) {
      writer.uint32(152).bool(message.isTotal);
    }
    for (const v of message.uniqueOn) {
      writer.uint32(162).string(v!);
    }
    for (const v of message.partitionedBy) {
      writer.uint32(170).string(v!);
    }
    for (const v of message.dataSourcesV2) {
      DatabaseSourceReference3.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.staticOperation !== undefined) {
      LogicalExprNode.encode(message.staticOperation, writer.uint32(186).fork()).join();
    }
    if (message.sqlSettings !== undefined) {
      SQLResolverSettings.encode(message.sqlSettings, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(ResolverInput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputs.push(ResolverOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isGenerator = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dataSources.push(DatabaseSourceReference.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.environments.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.schedule = Schedule.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.when = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.cronFilter = CronFilterWithFeatureArgs.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.function = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.resourceHint = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isStatic = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isTotal = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.uniqueOn.push(reader.string());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.partitionedBy.push(reader.string());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.dataSourcesV2.push(DatabaseSourceReference3.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.staticOperation = LogicalExprNode.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.sqlSettings = SQLResolverSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resolver {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      kind: isSet(object.kind) ? resolverKindFromJSON(object.kind) : 0,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ResolverInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => ResolverOutput.fromJSON(e))
        : [],
      isGenerator: isSet(object.isGenerator) ? globalThis.Boolean(object.isGenerator) : false,
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DatabaseSourceReference.fromJSON(e))
        : [],
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => globalThis.String(e))
        : [],
      timeoutDuration: isSet(object.timeoutDuration) ? Duration.fromJSON(object.timeoutDuration) : undefined,
      schedule: isSet(object.schedule) ? Schedule.fromJSON(object.schedule) : undefined,
      when: isSet(object.when) ? LogicalExprNode.fromJSON(object.when) : undefined,
      cronFilter: isSet(object.cronFilter) ? CronFilterWithFeatureArgs.fromJSON(object.cronFilter) : undefined,
      function: isSet(object.function) ? FunctionReference.fromJSON(object.function) : undefined,
      resourceHint: isSet(object.resourceHint) ? resourceHintFromJSON(object.resourceHint) : 0,
      isStatic: isSet(object.isStatic) ? globalThis.Boolean(object.isStatic) : false,
      isTotal: isSet(object.isTotal) ? globalThis.Boolean(object.isTotal) : undefined,
      uniqueOn: globalThis.Array.isArray(object?.uniqueOn) ? object.uniqueOn.map((e: any) => globalThis.String(e)) : [],
      partitionedBy: globalThis.Array.isArray(object?.partitionedBy)
        ? object.partitionedBy.map((e: any) => globalThis.String(e))
        : [],
      dataSourcesV2: globalThis.Array.isArray(object?.dataSourcesV2)
        ? object.dataSourcesV2.map((e: any) => DatabaseSourceReference3.fromJSON(e))
        : [],
      staticOperation: isSet(object.staticOperation) ? LogicalExprNode.fromJSON(object.staticOperation) : undefined,
      sqlSettings: isSet(object.sqlSettings) ? SQLResolverSettings.fromJSON(object.sqlSettings) : undefined,
    };
  },

  toJSON(message: Resolver): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.kind !== 0) {
      obj.kind = resolverKindToJSON(message.kind);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ResolverInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => ResolverOutput.toJSON(e));
    }
    if (message.isGenerator !== false) {
      obj.isGenerator = message.isGenerator;
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DatabaseSourceReference.toJSON(e));
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.environments?.length) {
      obj.environments = message.environments;
    }
    if (message.timeoutDuration !== undefined) {
      obj.timeoutDuration = Duration.toJSON(message.timeoutDuration);
    }
    if (message.schedule !== undefined) {
      obj.schedule = Schedule.toJSON(message.schedule);
    }
    if (message.when !== undefined) {
      obj.when = LogicalExprNode.toJSON(message.when);
    }
    if (message.cronFilter !== undefined) {
      obj.cronFilter = CronFilterWithFeatureArgs.toJSON(message.cronFilter);
    }
    if (message.function !== undefined) {
      obj.function = FunctionReference.toJSON(message.function);
    }
    if (message.resourceHint !== 0) {
      obj.resourceHint = resourceHintToJSON(message.resourceHint);
    }
    if (message.isStatic !== false) {
      obj.isStatic = message.isStatic;
    }
    if (message.isTotal !== undefined) {
      obj.isTotal = message.isTotal;
    }
    if (message.uniqueOn?.length) {
      obj.uniqueOn = message.uniqueOn;
    }
    if (message.partitionedBy?.length) {
      obj.partitionedBy = message.partitionedBy;
    }
    if (message.dataSourcesV2?.length) {
      obj.dataSourcesV2 = message.dataSourcesV2.map((e) => DatabaseSourceReference3.toJSON(e));
    }
    if (message.staticOperation !== undefined) {
      obj.staticOperation = LogicalExprNode.toJSON(message.staticOperation);
    }
    if (message.sqlSettings !== undefined) {
      obj.sqlSettings = SQLResolverSettings.toJSON(message.sqlSettings);
    }
    return obj;
  },
};

function createBaseSinkResolver(): SinkResolver {
  return {
    fqn: "",
    inputs: [],
    bufferSize: undefined,
    debounceDuration: undefined,
    maxDelayDuration: undefined,
    upsert: false,
    streamSource: undefined,
    databaseSource: undefined,
    streamSourceV2: undefined,
    databaseSourceV2: undefined,
    machineType: undefined,
    doc: undefined,
    owner: undefined,
    environments: [],
    timeoutDuration: undefined,
    function: undefined,
  };
}

export const SinkResolver: MessageFns<SinkResolver> = {
  encode(message: SinkResolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    for (const v of message.inputs) {
      ResolverInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.bufferSize !== undefined) {
      writer.uint32(24).uint64(message.bufferSize);
    }
    if (message.debounceDuration !== undefined) {
      Duration.encode(message.debounceDuration, writer.uint32(34).fork()).join();
    }
    if (message.maxDelayDuration !== undefined) {
      Duration.encode(message.maxDelayDuration, writer.uint32(42).fork()).join();
    }
    if (message.upsert !== false) {
      writer.uint32(48).bool(message.upsert);
    }
    if (message.streamSource !== undefined) {
      StreamSourceReference.encode(message.streamSource, writer.uint32(58).fork()).join();
    }
    if (message.databaseSource !== undefined) {
      DatabaseSourceReference.encode(message.databaseSource, writer.uint32(66).fork()).join();
    }
    if (message.streamSourceV2 !== undefined) {
      StreamSourceReference4.encode(message.streamSourceV2, writer.uint32(122).fork()).join();
    }
    if (message.databaseSourceV2 !== undefined) {
      DatabaseSourceReference3.encode(message.databaseSourceV2, writer.uint32(130).fork()).join();
    }
    if (message.machineType !== undefined) {
      writer.uint32(74).string(message.machineType);
    }
    if (message.doc !== undefined) {
      writer.uint32(82).string(message.doc);
    }
    if (message.owner !== undefined) {
      writer.uint32(90).string(message.owner);
    }
    for (const v of message.environments) {
      writer.uint32(98).string(v!);
    }
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(106).fork()).join();
    }
    if (message.function !== undefined) {
      FunctionReference.encode(message.function, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinkResolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinkResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ResolverInput.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bufferSize = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.debounceDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxDelayDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.upsert = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.streamSource = StreamSourceReference.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.databaseSource = DatabaseSourceReference.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.streamSourceV2 = StreamSourceReference4.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.databaseSourceV2 = DatabaseSourceReference3.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.environments.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.function = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinkResolver {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ResolverInput.fromJSON(e)) : [],
      bufferSize: isSet(object.bufferSize) ? globalThis.Number(object.bufferSize) : undefined,
      debounceDuration: isSet(object.debounceDuration) ? Duration.fromJSON(object.debounceDuration) : undefined,
      maxDelayDuration: isSet(object.maxDelayDuration) ? Duration.fromJSON(object.maxDelayDuration) : undefined,
      upsert: isSet(object.upsert) ? globalThis.Boolean(object.upsert) : false,
      streamSource: isSet(object.streamSource) ? StreamSourceReference.fromJSON(object.streamSource) : undefined,
      databaseSource: isSet(object.databaseSource)
        ? DatabaseSourceReference.fromJSON(object.databaseSource)
        : undefined,
      streamSourceV2: isSet(object.streamSourceV2) ? StreamSourceReference4.fromJSON(object.streamSourceV2) : undefined,
      databaseSourceV2: isSet(object.databaseSourceV2)
        ? DatabaseSourceReference3.fromJSON(object.databaseSourceV2)
        : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => globalThis.String(e))
        : [],
      timeoutDuration: isSet(object.timeoutDuration) ? Duration.fromJSON(object.timeoutDuration) : undefined,
      function: isSet(object.function) ? FunctionReference.fromJSON(object.function) : undefined,
    };
  },

  toJSON(message: SinkResolver): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ResolverInput.toJSON(e));
    }
    if (message.bufferSize !== undefined) {
      obj.bufferSize = Math.round(message.bufferSize);
    }
    if (message.debounceDuration !== undefined) {
      obj.debounceDuration = Duration.toJSON(message.debounceDuration);
    }
    if (message.maxDelayDuration !== undefined) {
      obj.maxDelayDuration = Duration.toJSON(message.maxDelayDuration);
    }
    if (message.upsert !== false) {
      obj.upsert = message.upsert;
    }
    if (message.streamSource !== undefined) {
      obj.streamSource = StreamSourceReference.toJSON(message.streamSource);
    }
    if (message.databaseSource !== undefined) {
      obj.databaseSource = DatabaseSourceReference.toJSON(message.databaseSource);
    }
    if (message.streamSourceV2 !== undefined) {
      obj.streamSourceV2 = StreamSourceReference4.toJSON(message.streamSourceV2);
    }
    if (message.databaseSourceV2 !== undefined) {
      obj.databaseSourceV2 = DatabaseSourceReference3.toJSON(message.databaseSourceV2);
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.environments?.length) {
      obj.environments = message.environments;
    }
    if (message.timeoutDuration !== undefined) {
      obj.timeoutDuration = Duration.toJSON(message.timeoutDuration);
    }
    if (message.function !== undefined) {
      obj.function = FunctionReference.toJSON(message.function);
    }
    return obj;
  },
};

function createBaseParseInfo(): ParseInfo {
  return {
    parseFunction: undefined,
    parseFunctionInputType: undefined,
    parseFunctionOutputType: undefined,
    isParseFunctionOutputOptional: false,
    parseFunctionInputTypeName: "",
    parseFunctionOutputTypeName: "",
  };
}

export const ParseInfo: MessageFns<ParseInfo> = {
  encode(message: ParseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parseFunction !== undefined) {
      FunctionReference.encode(message.parseFunction, writer.uint32(10).fork()).join();
    }
    if (message.parseFunctionInputType !== undefined) {
      ArrowType.encode(message.parseFunctionInputType, writer.uint32(18).fork()).join();
    }
    if (message.parseFunctionOutputType !== undefined) {
      ArrowType.encode(message.parseFunctionOutputType, writer.uint32(26).fork()).join();
    }
    if (message.isParseFunctionOutputOptional !== false) {
      writer.uint32(32).bool(message.isParseFunctionOutputOptional);
    }
    if (message.parseFunctionInputTypeName !== "") {
      writer.uint32(42).string(message.parseFunctionInputTypeName);
    }
    if (message.parseFunctionOutputTypeName !== "") {
      writer.uint32(50).string(message.parseFunctionOutputTypeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parseFunction = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parseFunctionInputType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parseFunctionOutputType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isParseFunctionOutputOptional = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parseFunctionInputTypeName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parseFunctionOutputTypeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseInfo {
    return {
      parseFunction: isSet(object.parseFunction) ? FunctionReference.fromJSON(object.parseFunction) : undefined,
      parseFunctionInputType: isSet(object.parseFunctionInputType)
        ? ArrowType.fromJSON(object.parseFunctionInputType)
        : undefined,
      parseFunctionOutputType: isSet(object.parseFunctionOutputType)
        ? ArrowType.fromJSON(object.parseFunctionOutputType)
        : undefined,
      isParseFunctionOutputOptional: isSet(object.isParseFunctionOutputOptional)
        ? globalThis.Boolean(object.isParseFunctionOutputOptional)
        : false,
      parseFunctionInputTypeName: isSet(object.parseFunctionInputTypeName)
        ? globalThis.String(object.parseFunctionInputTypeName)
        : "",
      parseFunctionOutputTypeName: isSet(object.parseFunctionOutputTypeName)
        ? globalThis.String(object.parseFunctionOutputTypeName)
        : "",
    };
  },

  toJSON(message: ParseInfo): unknown {
    const obj: any = {};
    if (message.parseFunction !== undefined) {
      obj.parseFunction = FunctionReference.toJSON(message.parseFunction);
    }
    if (message.parseFunctionInputType !== undefined) {
      obj.parseFunctionInputType = ArrowType.toJSON(message.parseFunctionInputType);
    }
    if (message.parseFunctionOutputType !== undefined) {
      obj.parseFunctionOutputType = ArrowType.toJSON(message.parseFunctionOutputType);
    }
    if (message.isParseFunctionOutputOptional !== false) {
      obj.isParseFunctionOutputOptional = message.isParseFunctionOutputOptional;
    }
    if (message.parseFunctionInputTypeName !== "") {
      obj.parseFunctionInputTypeName = message.parseFunctionInputTypeName;
    }
    if (message.parseFunctionOutputTypeName !== "") {
      obj.parseFunctionOutputTypeName = message.parseFunctionOutputTypeName;
    }
    return obj;
  },
};

function createBaseStreamResolver(): StreamResolver {
  return {
    fqn: "",
    params: [],
    outputs: [],
    explicitSchema: undefined,
    keys: [],
    source: undefined,
    parseInfo: undefined,
    mode: 0,
    environments: [],
    timeoutDuration: undefined,
    timestampAttributeName: undefined,
    owner: undefined,
    doc: undefined,
    machineType: undefined,
    function: undefined,
    sourceV2: undefined,
    updatesMaterializedAggregations: false,
  };
}

export const StreamResolver: MessageFns<StreamResolver> = {
  encode(message: StreamResolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fqn !== "") {
      writer.uint32(10).string(message.fqn);
    }
    for (const v of message.params) {
      StreamResolverParam.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.outputs) {
      ResolverOutput.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.explicitSchema !== undefined) {
      ArrowType.encode(message.explicitSchema, writer.uint32(34).fork()).join();
    }
    for (const v of message.keys) {
      StreamKey.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.source !== undefined) {
      StreamSourceReference.encode(message.source, writer.uint32(50).fork()).join();
    }
    if (message.parseInfo !== undefined) {
      ParseInfo.encode(message.parseInfo, writer.uint32(58).fork()).join();
    }
    if (message.mode !== 0) {
      writer.uint32(64).int32(message.mode);
    }
    for (const v of message.environments) {
      writer.uint32(74).string(v!);
    }
    if (message.timeoutDuration !== undefined) {
      Duration.encode(message.timeoutDuration, writer.uint32(82).fork()).join();
    }
    if (message.timestampAttributeName !== undefined) {
      writer.uint32(90).string(message.timestampAttributeName);
    }
    if (message.owner !== undefined) {
      writer.uint32(98).string(message.owner);
    }
    if (message.doc !== undefined) {
      writer.uint32(106).string(message.doc);
    }
    if (message.machineType !== undefined) {
      writer.uint32(114).string(message.machineType);
    }
    if (message.function !== undefined) {
      FunctionReference.encode(message.function, writer.uint32(122).fork()).join();
    }
    if (message.sourceV2 !== undefined) {
      StreamSourceReference4.encode(message.sourceV2, writer.uint32(130).fork()).join();
    }
    if (message.updatesMaterializedAggregations !== false) {
      writer.uint32(136).bool(message.updatesMaterializedAggregations);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params.push(StreamResolverParam.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputs.push(ResolverOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.explicitSchema = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.keys.push(StreamKey.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.source = StreamSourceReference.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.parseInfo = ParseInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.environments.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.timeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.timestampAttributeName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.doc = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.function = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sourceV2 = StreamSourceReference4.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.updatesMaterializedAggregations = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolver {
    return {
      fqn: isSet(object.fqn) ? globalThis.String(object.fqn) : "",
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => StreamResolverParam.fromJSON(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => ResolverOutput.fromJSON(e))
        : [],
      explicitSchema: isSet(object.explicitSchema) ? ArrowType.fromJSON(object.explicitSchema) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => StreamKey.fromJSON(e)) : [],
      source: isSet(object.source) ? StreamSourceReference.fromJSON(object.source) : undefined,
      parseInfo: isSet(object.parseInfo) ? ParseInfo.fromJSON(object.parseInfo) : undefined,
      mode: isSet(object.mode) ? windowModeFromJSON(object.mode) : 0,
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => globalThis.String(e))
        : [],
      timeoutDuration: isSet(object.timeoutDuration) ? Duration.fromJSON(object.timeoutDuration) : undefined,
      timestampAttributeName: isSet(object.timestampAttributeName)
        ? globalThis.String(object.timestampAttributeName)
        : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      doc: isSet(object.doc) ? globalThis.String(object.doc) : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      function: isSet(object.function) ? FunctionReference.fromJSON(object.function) : undefined,
      sourceV2: isSet(object.sourceV2) ? StreamSourceReference4.fromJSON(object.sourceV2) : undefined,
      updatesMaterializedAggregations: isSet(object.updatesMaterializedAggregations)
        ? globalThis.Boolean(object.updatesMaterializedAggregations)
        : false,
    };
  },

  toJSON(message: StreamResolver): unknown {
    const obj: any = {};
    if (message.fqn !== "") {
      obj.fqn = message.fqn;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => StreamResolverParam.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => ResolverOutput.toJSON(e));
    }
    if (message.explicitSchema !== undefined) {
      obj.explicitSchema = ArrowType.toJSON(message.explicitSchema);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => StreamKey.toJSON(e));
    }
    if (message.source !== undefined) {
      obj.source = StreamSourceReference.toJSON(message.source);
    }
    if (message.parseInfo !== undefined) {
      obj.parseInfo = ParseInfo.toJSON(message.parseInfo);
    }
    if (message.mode !== 0) {
      obj.mode = windowModeToJSON(message.mode);
    }
    if (message.environments?.length) {
      obj.environments = message.environments;
    }
    if (message.timeoutDuration !== undefined) {
      obj.timeoutDuration = Duration.toJSON(message.timeoutDuration);
    }
    if (message.timestampAttributeName !== undefined) {
      obj.timestampAttributeName = message.timestampAttributeName;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.doc !== undefined) {
      obj.doc = message.doc;
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.function !== undefined) {
      obj.function = FunctionReference.toJSON(message.function);
    }
    if (message.sourceV2 !== undefined) {
      obj.sourceV2 = StreamSourceReference4.toJSON(message.sourceV2);
    }
    if (message.updatesMaterializedAggregations !== false) {
      obj.updatesMaterializedAggregations = message.updatesMaterializedAggregations;
    }
    return obj;
  },
};

function createBaseResolverState(): ResolverState {
  return { initial: undefined, arrowType: undefined };
}

export const ResolverState: MessageFns<ResolverState> = {
  encode(message: ResolverState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial !== undefined) {
      ScalarValue.encode(message.initial, writer.uint32(10).fork()).join();
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolverState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolverState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initial = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolverState {
    return {
      initial: isSet(object.initial) ? ScalarValue.fromJSON(object.initial) : undefined,
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: ResolverState): unknown {
    const obj: any = {};
    if (message.initial !== undefined) {
      obj.initial = ScalarValue.toJSON(message.initial);
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },
};

function createBaseStreamResolverParam(): StreamResolverParam {
  return { message: undefined, messageWindow: undefined, state: undefined };
}

export const StreamResolverParam: MessageFns<StreamResolverParam> = {
  encode(message: StreamResolverParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      StreamResolverParamMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    if (message.messageWindow !== undefined) {
      StreamResolverParamMessageWindow.encode(message.messageWindow, writer.uint32(18).fork()).join();
    }
    if (message.state !== undefined) {
      ResolverState.encode(message.state, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolverParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolverParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = StreamResolverParamMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageWindow = StreamResolverParamMessageWindow.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = ResolverState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolverParam {
    return {
      message: isSet(object.message) ? StreamResolverParamMessage.fromJSON(object.message) : undefined,
      messageWindow: isSet(object.messageWindow)
        ? StreamResolverParamMessageWindow.fromJSON(object.messageWindow)
        : undefined,
      state: isSet(object.state) ? ResolverState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: StreamResolverParam): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = StreamResolverParamMessage.toJSON(message.message);
    }
    if (message.messageWindow !== undefined) {
      obj.messageWindow = StreamResolverParamMessageWindow.toJSON(message.messageWindow);
    }
    if (message.state !== undefined) {
      obj.state = ResolverState.toJSON(message.state);
    }
    return obj;
  },
};

function createBaseStreamResolverParamMessageWindow(): StreamResolverParamMessageWindow {
  return { name: "", arrowType: undefined };
}

export const StreamResolverParamMessageWindow: MessageFns<StreamResolverParamMessageWindow> = {
  encode(message: StreamResolverParamMessageWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolverParamMessageWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolverParamMessageWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolverParamMessageWindow {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: StreamResolverParamMessageWindow): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },
};

function createBaseStreamResolverParamMessage(): StreamResolverParamMessage {
  return { name: "", arrowType: undefined };
}

export const StreamResolverParamMessage: MessageFns<StreamResolverParamMessage> = {
  encode(message: StreamResolverParamMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arrowType !== undefined) {
      ArrowType.encode(message.arrowType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResolverParamMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResolverParamMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrowType = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamResolverParamMessage {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arrowType: isSet(object.arrowType) ? ArrowType.fromJSON(object.arrowType) : undefined,
    };
  },

  toJSON(message: StreamResolverParamMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arrowType !== undefined) {
      obj.arrowType = ArrowType.toJSON(message.arrowType);
    }
    return obj;
  },
};

function createBaseFunctionReference(): FunctionReference {
  return { name: "", module: "", fileName: "", functionDefinition: "", sourceLine: undefined, capturedGlobals: [] };
}

export const FunctionReference: MessageFns<FunctionReference> = {
  encode(message: FunctionReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.module !== "") {
      writer.uint32(18).string(message.module);
    }
    if (message.fileName !== "") {
      writer.uint32(26).string(message.fileName);
    }
    if (message.functionDefinition !== "") {
      writer.uint32(34).string(message.functionDefinition);
    }
    if (message.sourceLine !== undefined) {
      writer.uint32(40).int32(message.sourceLine);
    }
    for (const v of message.capturedGlobals) {
      FunctionReferenceCapturedGlobal.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.functionDefinition = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sourceLine = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.capturedGlobals.push(FunctionReferenceCapturedGlobal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      functionDefinition: isSet(object.functionDefinition) ? globalThis.String(object.functionDefinition) : "",
      sourceLine: isSet(object.sourceLine) ? globalThis.Number(object.sourceLine) : undefined,
      capturedGlobals: globalThis.Array.isArray(object?.capturedGlobals)
        ? object.capturedGlobals.map((e: any) => FunctionReferenceCapturedGlobal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunctionReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.functionDefinition !== "") {
      obj.functionDefinition = message.functionDefinition;
    }
    if (message.sourceLine !== undefined) {
      obj.sourceLine = Math.round(message.sourceLine);
    }
    if (message.capturedGlobals?.length) {
      obj.capturedGlobals = message.capturedGlobals.map((e) => FunctionReferenceCapturedGlobal.toJSON(e));
    }
    return obj;
  },
};

function createBaseFunctionReferenceCapturedGlobal(): FunctionReferenceCapturedGlobal {
  return {
    globalName: "",
    builtin: undefined,
    featureClass: undefined,
    enum: undefined,
    module: undefined,
    moduleMember: undefined,
    function: undefined,
    struct: undefined,
    variable: undefined,
    proto: undefined,
    sourceReference: undefined,
  };
}

export const FunctionReferenceCapturedGlobal: MessageFns<FunctionReferenceCapturedGlobal> = {
  encode(message: FunctionReferenceCapturedGlobal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalName !== "") {
      writer.uint32(26).string(message.globalName);
    }
    if (message.builtin !== undefined) {
      FunctionGlobalCapturedBuiltin.encode(message.builtin, writer.uint32(10).fork()).join();
    }
    if (message.featureClass !== undefined) {
      FunctionGlobalCapturedFeatureClass.encode(message.featureClass, writer.uint32(18).fork()).join();
    }
    if (message.enum !== undefined) {
      FunctionGlobalCapturedEnum.encode(message.enum, writer.uint32(34).fork()).join();
    }
    if (message.module !== undefined) {
      FunctionGlobalCapturedModule.encode(message.module, writer.uint32(42).fork()).join();
    }
    if (message.moduleMember !== undefined) {
      FunctionGlobalCapturedModuleMember.encode(message.moduleMember, writer.uint32(58).fork()).join();
    }
    if (message.function !== undefined) {
      FunctionGlobalCapturedFunction.encode(message.function, writer.uint32(50).fork()).join();
    }
    if (message.struct !== undefined) {
      FunctionGlobalCapturedStruct.encode(message.struct, writer.uint32(66).fork()).join();
    }
    if (message.variable !== undefined) {
      FunctionGlobalCapturedVariable.encode(message.variable, writer.uint32(82).fork()).join();
    }
    if (message.proto !== undefined) {
      FunctionGlobalCapturedProto.encode(message.proto, writer.uint32(90).fork()).join();
    }
    if (message.sourceReference !== undefined) {
      SourceFileReference.encode(message.sourceReference, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionReferenceCapturedGlobal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionReferenceCapturedGlobal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.globalName = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.builtin = FunctionGlobalCapturedBuiltin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.featureClass = FunctionGlobalCapturedFeatureClass.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.enum = FunctionGlobalCapturedEnum.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.module = FunctionGlobalCapturedModule.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.moduleMember = FunctionGlobalCapturedModuleMember.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.function = FunctionGlobalCapturedFunction.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.struct = FunctionGlobalCapturedStruct.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.variable = FunctionGlobalCapturedVariable.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.proto = FunctionGlobalCapturedProto.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sourceReference = SourceFileReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionReferenceCapturedGlobal {
    return {
      globalName: isSet(object.globalName) ? globalThis.String(object.globalName) : "",
      builtin: isSet(object.builtin) ? FunctionGlobalCapturedBuiltin.fromJSON(object.builtin) : undefined,
      featureClass: isSet(object.featureClass)
        ? FunctionGlobalCapturedFeatureClass.fromJSON(object.featureClass)
        : undefined,
      enum: isSet(object.enum) ? FunctionGlobalCapturedEnum.fromJSON(object.enum) : undefined,
      module: isSet(object.module) ? FunctionGlobalCapturedModule.fromJSON(object.module) : undefined,
      moduleMember: isSet(object.moduleMember)
        ? FunctionGlobalCapturedModuleMember.fromJSON(object.moduleMember)
        : undefined,
      function: isSet(object.function) ? FunctionGlobalCapturedFunction.fromJSON(object.function) : undefined,
      struct: isSet(object.struct) ? FunctionGlobalCapturedStruct.fromJSON(object.struct) : undefined,
      variable: isSet(object.variable) ? FunctionGlobalCapturedVariable.fromJSON(object.variable) : undefined,
      proto: isSet(object.proto) ? FunctionGlobalCapturedProto.fromJSON(object.proto) : undefined,
      sourceReference: isSet(object.sourceReference) ? SourceFileReference.fromJSON(object.sourceReference) : undefined,
    };
  },

  toJSON(message: FunctionReferenceCapturedGlobal): unknown {
    const obj: any = {};
    if (message.globalName !== "") {
      obj.globalName = message.globalName;
    }
    if (message.builtin !== undefined) {
      obj.builtin = FunctionGlobalCapturedBuiltin.toJSON(message.builtin);
    }
    if (message.featureClass !== undefined) {
      obj.featureClass = FunctionGlobalCapturedFeatureClass.toJSON(message.featureClass);
    }
    if (message.enum !== undefined) {
      obj.enum = FunctionGlobalCapturedEnum.toJSON(message.enum);
    }
    if (message.module !== undefined) {
      obj.module = FunctionGlobalCapturedModule.toJSON(message.module);
    }
    if (message.moduleMember !== undefined) {
      obj.moduleMember = FunctionGlobalCapturedModuleMember.toJSON(message.moduleMember);
    }
    if (message.function !== undefined) {
      obj.function = FunctionGlobalCapturedFunction.toJSON(message.function);
    }
    if (message.struct !== undefined) {
      obj.struct = FunctionGlobalCapturedStruct.toJSON(message.struct);
    }
    if (message.variable !== undefined) {
      obj.variable = FunctionGlobalCapturedVariable.toJSON(message.variable);
    }
    if (message.proto !== undefined) {
      obj.proto = FunctionGlobalCapturedProto.toJSON(message.proto);
    }
    if (message.sourceReference !== undefined) {
      obj.sourceReference = SourceFileReference.toJSON(message.sourceReference);
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedBuiltin(): FunctionGlobalCapturedBuiltin {
  return { builtinName: "" };
}

export const FunctionGlobalCapturedBuiltin: MessageFns<FunctionGlobalCapturedBuiltin> = {
  encode(message: FunctionGlobalCapturedBuiltin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.builtinName !== "") {
      writer.uint32(10).string(message.builtinName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedBuiltin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedBuiltin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.builtinName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedBuiltin {
    return { builtinName: isSet(object.builtinName) ? globalThis.String(object.builtinName) : "" };
  },

  toJSON(message: FunctionGlobalCapturedBuiltin): unknown {
    const obj: any = {};
    if (message.builtinName !== "") {
      obj.builtinName = message.builtinName;
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedVariable(): FunctionGlobalCapturedVariable {
  return { module: "", name: "" };
}

export const FunctionGlobalCapturedVariable: MessageFns<FunctionGlobalCapturedVariable> = {
  encode(message: FunctionGlobalCapturedVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedVariable {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedVariable): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedStruct(): FunctionGlobalCapturedStruct {
  return { module: "", name: "", paDtype: undefined };
}

export const FunctionGlobalCapturedStruct: MessageFns<FunctionGlobalCapturedStruct> = {
  encode(message: FunctionGlobalCapturedStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.paDtype !== undefined) {
      ArrowType.encode(message.paDtype, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paDtype = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedStruct {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      paDtype: isSet(object.paDtype) ? ArrowType.fromJSON(object.paDtype) : undefined,
    };
  },

  toJSON(message: FunctionGlobalCapturedStruct): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.paDtype !== undefined) {
      obj.paDtype = ArrowType.toJSON(message.paDtype);
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedEnum(): FunctionGlobalCapturedEnum {
  return { module: "", name: "", memberMap: {}, bases: [] };
}

export const FunctionGlobalCapturedEnum: MessageFns<FunctionGlobalCapturedEnum> = {
  encode(message: FunctionGlobalCapturedEnum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.memberMap).forEach(([key, value]) => {
      FunctionGlobalCapturedEnum_MemberMapEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.bases) {
      ArrowType.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedEnum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedEnum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = FunctionGlobalCapturedEnum_MemberMapEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.memberMap[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bases.push(ArrowType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedEnum {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      memberMap: isObject(object.memberMap)
        ? Object.entries(object.memberMap).reduce<{ [key: string]: ScalarValue }>((acc, [key, value]) => {
          acc[key] = ScalarValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      bases: globalThis.Array.isArray(object?.bases) ? object.bases.map((e: any) => ArrowType.fromJSON(e)) : [],
    };
  },

  toJSON(message: FunctionGlobalCapturedEnum): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.memberMap) {
      const entries = Object.entries(message.memberMap);
      if (entries.length > 0) {
        obj.memberMap = {};
        entries.forEach(([k, v]) => {
          obj.memberMap[k] = ScalarValue.toJSON(v);
        });
      }
    }
    if (message.bases?.length) {
      obj.bases = message.bases.map((e) => ArrowType.toJSON(e));
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedEnum_MemberMapEntry(): FunctionGlobalCapturedEnum_MemberMapEntry {
  return { key: "", value: undefined };
}

export const FunctionGlobalCapturedEnum_MemberMapEntry: MessageFns<FunctionGlobalCapturedEnum_MemberMapEntry> = {
  encode(message: FunctionGlobalCapturedEnum_MemberMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalarValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedEnum_MemberMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedEnum_MemberMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedEnum_MemberMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalarValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FunctionGlobalCapturedEnum_MemberMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalarValue.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedFeatureClass(): FunctionGlobalCapturedFeatureClass {
  return { featureClassName: "" };
}

export const FunctionGlobalCapturedFeatureClass: MessageFns<FunctionGlobalCapturedFeatureClass> = {
  encode(message: FunctionGlobalCapturedFeatureClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featureClassName !== "") {
      writer.uint32(10).string(message.featureClassName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedFeatureClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedFeatureClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.featureClassName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedFeatureClass {
    return { featureClassName: isSet(object.featureClassName) ? globalThis.String(object.featureClassName) : "" };
  },

  toJSON(message: FunctionGlobalCapturedFeatureClass): unknown {
    const obj: any = {};
    if (message.featureClassName !== "") {
      obj.featureClassName = message.featureClassName;
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedModule(): FunctionGlobalCapturedModule {
  return { name: "" };
}

export const FunctionGlobalCapturedModule: MessageFns<FunctionGlobalCapturedModule> = {
  encode(message: FunctionGlobalCapturedModule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedModule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedModule {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: FunctionGlobalCapturedModule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedModuleMember(): FunctionGlobalCapturedModuleMember {
  return { moduleName: "", qualname: "" };
}

export const FunctionGlobalCapturedModuleMember: MessageFns<FunctionGlobalCapturedModuleMember> = {
  encode(message: FunctionGlobalCapturedModuleMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.qualname !== "") {
      writer.uint32(18).string(message.qualname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedModuleMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedModuleMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.qualname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedModuleMember {
    return {
      moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
      qualname: isSet(object.qualname) ? globalThis.String(object.qualname) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedModuleMember): unknown {
    const obj: any = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.qualname !== "") {
      obj.qualname = message.qualname;
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedFunction(): FunctionGlobalCapturedFunction {
  return { source: "", capturedGlobals: [], module: undefined, name: "" };
}

export const FunctionGlobalCapturedFunction: MessageFns<FunctionGlobalCapturedFunction> = {
  encode(message: FunctionGlobalCapturedFunction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    for (const v of message.capturedGlobals) {
      FunctionReferenceCapturedGlobal.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.module !== undefined) {
      writer.uint32(26).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedFunction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capturedGlobals.push(FunctionReferenceCapturedGlobal.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedFunction {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      capturedGlobals: globalThis.Array.isArray(object?.capturedGlobals)
        ? object.capturedGlobals.map((e: any) => FunctionReferenceCapturedGlobal.fromJSON(e))
        : [],
      module: isSet(object.module) ? globalThis.String(object.module) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedFunction): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.capturedGlobals?.length) {
      obj.capturedGlobals = message.capturedGlobals.map((e) => FunctionReferenceCapturedGlobal.toJSON(e));
    }
    if (message.module !== undefined) {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

function createBaseFunctionGlobalCapturedProto(): FunctionGlobalCapturedProto {
  return {
    module: "",
    name: "",
    fd: new Uint8Array(0),
    serializedFd: new Uint8Array(0),
    paDtype: undefined,
    fullName: "",
  };
}

export const FunctionGlobalCapturedProto: MessageFns<FunctionGlobalCapturedProto> = {
  encode(message: FunctionGlobalCapturedProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== "") {
      writer.uint32(10).string(message.module);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.fd.length !== 0) {
      writer.uint32(26).bytes(message.fd);
    }
    if (message.serializedFd.length !== 0) {
      writer.uint32(50).bytes(message.serializedFd);
    }
    if (message.paDtype !== undefined) {
      ArrowType.encode(message.paDtype, writer.uint32(34).fork()).join();
    }
    if (message.fullName !== "") {
      writer.uint32(42).string(message.fullName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionGlobalCapturedProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionGlobalCapturedProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fd = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.serializedFd = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paDtype = ArrowType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionGlobalCapturedProto {
    return {
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fd: isSet(object.fd) ? bytesFromBase64(object.fd) : new Uint8Array(0),
      serializedFd: isSet(object.serializedFd) ? bytesFromBase64(object.serializedFd) : new Uint8Array(0),
      paDtype: isSet(object.paDtype) ? ArrowType.fromJSON(object.paDtype) : undefined,
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
    };
  },

  toJSON(message: FunctionGlobalCapturedProto): unknown {
    const obj: any = {};
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fd.length !== 0) {
      obj.fd = base64FromBytes(message.fd);
    }
    if (message.serializedFd.length !== 0) {
      obj.serializedFd = base64FromBytes(message.serializedFd);
    }
    if (message.paDtype !== undefined) {
      obj.paDtype = ArrowType.toJSON(message.paDtype);
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    return obj;
  },
};

function createBaseSourceFileReference(): SourceFileReference {
  return { range: undefined, code: undefined, fileName: "" };
}

export const SourceFileReference: MessageFns<SourceFileReference> = {
  encode(message: SourceFileReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      Range.encode(message.range, writer.uint32(10).fork()).join();
    }
    if (message.code !== undefined) {
      writer.uint32(18).string(message.code);
    }
    if (message.fileName !== "") {
      writer.uint32(26).string(message.fileName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceFileReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceFileReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = Range.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceFileReference {
    return {
      range: isSet(object.range) ? Range.fromJSON(object.range) : undefined,
      code: isSet(object.code) ? globalThis.String(object.code) : undefined,
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
    };
  },

  toJSON(message: SourceFileReference): unknown {
    const obj: any = {};
    if (message.range !== undefined) {
      obj.range = Range.toJSON(message.range);
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    return obj;
  },
};

function createBaseStreamKey(): StreamKey {
  return { key: "", feature: undefined };
}

export const StreamKey: MessageFns<StreamKey> = {
  encode(message: StreamKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
    };
  },

  toJSON(message: StreamKey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    return obj;
  },
};

function createBaseSQLResolverSettings(): SQLResolverSettings {
  return { finalizer: 0, incrementalSettings: undefined, fieldsRootFqn: {}, escapedParamNameToFqn: {} };
}

export const SQLResolverSettings: MessageFns<SQLResolverSettings> = {
  encode(message: SQLResolverSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalizer !== 0) {
      writer.uint32(8).int32(message.finalizer);
    }
    if (message.incrementalSettings !== undefined) {
      IncrementalSettings.encode(message.incrementalSettings, writer.uint32(18).fork()).join();
    }
    Object.entries(message.fieldsRootFqn).forEach(([key, value]) => {
      SQLResolverSettings_FieldsRootFqnEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.escapedParamNameToFqn).forEach(([key, value]) => {
      SQLResolverSettings_EscapedParamNameToFqnEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.finalizer = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.incrementalSettings = IncrementalSettings.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SQLResolverSettings_FieldsRootFqnEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fieldsRootFqn[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SQLResolverSettings_EscapedParamNameToFqnEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.escapedParamNameToFqn[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverSettings {
    return {
      finalizer: isSet(object.finalizer) ? finalizerFromJSON(object.finalizer) : 0,
      incrementalSettings: isSet(object.incrementalSettings)
        ? IncrementalSettings.fromJSON(object.incrementalSettings)
        : undefined,
      fieldsRootFqn: isObject(object.fieldsRootFqn)
        ? Object.entries(object.fieldsRootFqn).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      escapedParamNameToFqn: isObject(object.escapedParamNameToFqn)
        ? Object.entries(object.escapedParamNameToFqn).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SQLResolverSettings): unknown {
    const obj: any = {};
    if (message.finalizer !== 0) {
      obj.finalizer = finalizerToJSON(message.finalizer);
    }
    if (message.incrementalSettings !== undefined) {
      obj.incrementalSettings = IncrementalSettings.toJSON(message.incrementalSettings);
    }
    if (message.fieldsRootFqn) {
      const entries = Object.entries(message.fieldsRootFqn);
      if (entries.length > 0) {
        obj.fieldsRootFqn = {};
        entries.forEach(([k, v]) => {
          obj.fieldsRootFqn[k] = v;
        });
      }
    }
    if (message.escapedParamNameToFqn) {
      const entries = Object.entries(message.escapedParamNameToFqn);
      if (entries.length > 0) {
        obj.escapedParamNameToFqn = {};
        entries.forEach(([k, v]) => {
          obj.escapedParamNameToFqn[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseSQLResolverSettings_FieldsRootFqnEntry(): SQLResolverSettings_FieldsRootFqnEntry {
  return { key: "", value: "" };
}

export const SQLResolverSettings_FieldsRootFqnEntry: MessageFns<SQLResolverSettings_FieldsRootFqnEntry> = {
  encode(message: SQLResolverSettings_FieldsRootFqnEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverSettings_FieldsRootFqnEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverSettings_FieldsRootFqnEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverSettings_FieldsRootFqnEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SQLResolverSettings_FieldsRootFqnEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseSQLResolverSettings_EscapedParamNameToFqnEntry(): SQLResolverSettings_EscapedParamNameToFqnEntry {
  return { key: "", value: "" };
}

export const SQLResolverSettings_EscapedParamNameToFqnEntry: MessageFns<
  SQLResolverSettings_EscapedParamNameToFqnEntry
> = {
  encode(
    message: SQLResolverSettings_EscapedParamNameToFqnEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverSettings_EscapedParamNameToFqnEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverSettings_EscapedParamNameToFqnEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverSettings_EscapedParamNameToFqnEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SQLResolverSettings_EscapedParamNameToFqnEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseIncrementalSettings(): IncrementalSettings {
  return { mode: 0, lookbackPeriod: undefined, incrementalColumn: undefined, timestampMode: 0 };
}

export const IncrementalSettings: MessageFns<IncrementalSettings> = {
  encode(message: IncrementalSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.lookbackPeriod !== undefined) {
      Duration.encode(message.lookbackPeriod, writer.uint32(18).fork()).join();
    }
    if (message.incrementalColumn !== undefined) {
      writer.uint32(26).string(message.incrementalColumn);
    }
    if (message.timestampMode !== 0) {
      writer.uint32(32).int32(message.timestampMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncrementalSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncrementalSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lookbackPeriod = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.incrementalColumn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestampMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncrementalSettings {
    return {
      mode: isSet(object.mode) ? incrementalModeFromJSON(object.mode) : 0,
      lookbackPeriod: isSet(object.lookbackPeriod) ? Duration.fromJSON(object.lookbackPeriod) : undefined,
      incrementalColumn: isSet(object.incrementalColumn) ? globalThis.String(object.incrementalColumn) : undefined,
      timestampMode: isSet(object.timestampMode) ? incrementalTimestampModeFromJSON(object.timestampMode) : 0,
    };
  },

  toJSON(message: IncrementalSettings): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = incrementalModeToJSON(message.mode);
    }
    if (message.lookbackPeriod !== undefined) {
      obj.lookbackPeriod = Duration.toJSON(message.lookbackPeriod);
    }
    if (message.incrementalColumn !== undefined) {
      obj.incrementalColumn = message.incrementalColumn;
    }
    if (message.timestampMode !== 0) {
      obj.timestampMode = incrementalTimestampModeToJSON(message.timestampMode);
    }
    return obj;
  },
};

function createBaseSQLResolverCommentDict(): SQLResolverCommentDict {
  return {
    total: undefined,
    source: undefined,
    resolves: undefined,
    namespace: undefined,
    incremental: undefined,
    tags: [],
    environment: [],
    count: undefined,
    cron: undefined,
    machineType: undefined,
    owner: undefined,
    type: undefined,
    timeout: undefined,
    fields: {},
    uniqueOn: [],
    partitionedBy: [],
  };
}

export const SQLResolverCommentDict: MessageFns<SQLResolverCommentDict> = {
  encode(message: SQLResolverCommentDict, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== undefined) {
      writer.uint32(8).bool(message.total);
    }
    if (message.source !== undefined) {
      writer.uint32(18).string(message.source);
    }
    if (message.resolves !== undefined) {
      writer.uint32(26).string(message.resolves);
    }
    if (message.namespace !== undefined) {
      writer.uint32(34).string(message.namespace);
    }
    if (message.incremental !== undefined) {
      IncrementalSettings.encode(message.incremental, writer.uint32(42).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.environment) {
      writer.uint32(58).string(v!);
    }
    if (message.count !== undefined) {
      writer.uint32(64).int32(message.count);
    }
    if (message.cron !== undefined) {
      Schedule.encode(message.cron, writer.uint32(74).fork()).join();
    }
    if (message.machineType !== undefined) {
      writer.uint32(82).string(message.machineType);
    }
    if (message.owner !== undefined) {
      writer.uint32(90).string(message.owner);
    }
    if (message.type !== undefined) {
      writer.uint32(98).string(message.type);
    }
    if (message.timeout !== undefined) {
      writer.uint32(106).string(message.timeout);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      SQLResolverCommentDict_FieldsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    for (const v of message.uniqueOn) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.partitionedBy) {
      writer.uint32(130).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverCommentDict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverCommentDict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resolves = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.incremental = IncrementalSettings.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environment.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.count = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cron = Schedule.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.machineType = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.timeout = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = SQLResolverCommentDict_FieldsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.fields[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.uniqueOn.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.partitionedBy.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverCommentDict {
    return {
      total: isSet(object.total) ? globalThis.Boolean(object.total) : undefined,
      source: isSet(object.source) ? globalThis.String(object.source) : undefined,
      resolves: isSet(object.resolves) ? globalThis.String(object.resolves) : undefined,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      incremental: isSet(object.incremental) ? IncrementalSettings.fromJSON(object.incremental) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      environment: globalThis.Array.isArray(object?.environment)
        ? object.environment.map((e: any) => globalThis.String(e))
        : [],
      count: isSet(object.count) ? finalizerFromJSON(object.count) : undefined,
      cron: isSet(object.cron) ? Schedule.fromJSON(object.cron) : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      timeout: isSet(object.timeout) ? globalThis.String(object.timeout) : undefined,
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      uniqueOn: globalThis.Array.isArray(object?.uniqueOn) ? object.uniqueOn.map((e: any) => globalThis.String(e)) : [],
      partitionedBy: globalThis.Array.isArray(object?.partitionedBy)
        ? object.partitionedBy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SQLResolverCommentDict): unknown {
    const obj: any = {};
    if (message.total !== undefined) {
      obj.total = message.total;
    }
    if (message.source !== undefined) {
      obj.source = message.source;
    }
    if (message.resolves !== undefined) {
      obj.resolves = message.resolves;
    }
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.incremental !== undefined) {
      obj.incremental = IncrementalSettings.toJSON(message.incremental);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.environment?.length) {
      obj.environment = message.environment;
    }
    if (message.count !== undefined) {
      obj.count = finalizerToJSON(message.count);
    }
    if (message.cron !== undefined) {
      obj.cron = Schedule.toJSON(message.cron);
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.timeout !== undefined) {
      obj.timeout = message.timeout;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
    }
    if (message.uniqueOn?.length) {
      obj.uniqueOn = message.uniqueOn;
    }
    if (message.partitionedBy?.length) {
      obj.partitionedBy = message.partitionedBy;
    }
    return obj;
  },
};

function createBaseSQLResolverCommentDict_FieldsEntry(): SQLResolverCommentDict_FieldsEntry {
  return { key: "", value: "" };
}

export const SQLResolverCommentDict_FieldsEntry: MessageFns<SQLResolverCommentDict_FieldsEntry> = {
  encode(message: SQLResolverCommentDict_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverCommentDict_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverCommentDict_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverCommentDict_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SQLResolverCommentDict_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseSQLResolverInfo(): SQLResolverInfo {
  return { name: "", filepath: undefined, sqlString: "", overrideCommentDict: undefined };
}

export const SQLResolverInfo: MessageFns<SQLResolverInfo> = {
  encode(message: SQLResolverInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filepath !== undefined) {
      writer.uint32(18).string(message.filepath);
    }
    if (message.sqlString !== "") {
      writer.uint32(26).string(message.sqlString);
    }
    if (message.overrideCommentDict !== undefined) {
      SQLResolverCommentDict.encode(message.overrideCommentDict, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLResolverInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLResolverInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sqlString = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.overrideCommentDict = SQLResolverCommentDict.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SQLResolverInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : undefined,
      sqlString: isSet(object.sqlString) ? globalThis.String(object.sqlString) : "",
      overrideCommentDict: isSet(object.overrideCommentDict)
        ? SQLResolverCommentDict.fromJSON(object.overrideCommentDict)
        : undefined,
    };
  },

  toJSON(message: SQLResolverInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filepath !== undefined) {
      obj.filepath = message.filepath;
    }
    if (message.sqlString !== "") {
      obj.sqlString = message.sqlString;
    }
    if (message.overrideCommentDict !== undefined) {
      obj.overrideCommentDict = SQLResolverCommentDict.toJSON(message.overrideCommentDict);
    }
    return obj;
  },
};

function createBaseCronFilterWithFeatureArgs(): CronFilterWithFeatureArgs {
  return { filter: undefined, args: [] };
}

export const CronFilterWithFeatureArgs: MessageFns<CronFilterWithFeatureArgs> = {
  encode(message: CronFilterWithFeatureArgs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      FunctionReference.encode(message.filter, writer.uint32(10).fork()).join();
    }
    for (const v of message.args) {
      FeatureReference.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronFilterWithFeatureArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronFilterWithFeatureArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args.push(FeatureReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronFilterWithFeatureArgs {
    return {
      filter: isSet(object.filter) ? FunctionReference.fromJSON(object.filter) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => FeatureReference.fromJSON(e)) : [],
    };
  },

  toJSON(message: CronFilterWithFeatureArgs): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = FunctionReference.toJSON(message.filter);
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => FeatureReference.toJSON(e));
    }
    return obj;
  },
};

function createBaseSchedule(): Schedule {
  return { crontab: undefined, duration: undefined, filter: undefined, sample: undefined };
}

export const Schedule: MessageFns<Schedule> = {
  encode(message: Schedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crontab !== undefined) {
      writer.uint32(10).string(message.crontab);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.filter !== undefined) {
      FunctionReference.encode(message.filter, writer.uint32(26).fork()).join();
    }
    if (message.sample !== undefined) {
      FunctionReference.encode(message.sample, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.crontab = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sample = FunctionReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schedule {
    return {
      crontab: isSet(object.crontab) ? globalThis.String(object.crontab) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      filter: isSet(object.filter) ? FunctionReference.fromJSON(object.filter) : undefined,
      sample: isSet(object.sample) ? FunctionReference.fromJSON(object.sample) : undefined,
    };
  },

  toJSON(message: Schedule): unknown {
    const obj: any = {};
    if (message.crontab !== undefined) {
      obj.crontab = message.crontab;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.filter !== undefined) {
      obj.filter = FunctionReference.toJSON(message.filter);
    }
    if (message.sample !== undefined) {
      obj.sample = FunctionReference.toJSON(message.sample);
    }
    return obj;
  },
};

function createBaseFeatureValidation(): FeatureValidation {
  return {
    min: undefined,
    max: undefined,
    minLength: undefined,
    maxLength: undefined,
    minArrow: undefined,
    maxArrow: undefined,
    minLengthArrow: undefined,
    maxLengthArrow: undefined,
    contains: undefined,
    strict: false,
  };
}

export const FeatureValidation: MessageFns<FeatureValidation> = {
  encode(message: FeatureValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== undefined) {
      writer.uint32(21).float(message.max);
    }
    if (message.minLength !== undefined) {
      writer.uint32(24).uint32(message.minLength);
    }
    if (message.maxLength !== undefined) {
      writer.uint32(32).uint32(message.maxLength);
    }
    if (message.minArrow !== undefined) {
      ScalarValue.encode(message.minArrow, writer.uint32(50).fork()).join();
    }
    if (message.maxArrow !== undefined) {
      ScalarValue.encode(message.maxArrow, writer.uint32(58).fork()).join();
    }
    if (message.minLengthArrow !== undefined) {
      ScalarValue.encode(message.minLengthArrow, writer.uint32(66).fork()).join();
    }
    if (message.maxLengthArrow !== undefined) {
      ScalarValue.encode(message.maxLengthArrow, writer.uint32(74).fork()).join();
    }
    if (message.contains !== undefined) {
      ScalarValue.encode(message.contains, writer.uint32(82).fork()).join();
    }
    if (message.strict !== false) {
      writer.uint32(40).bool(message.strict);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minLength = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxLength = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.minArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.minLengthArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.maxLengthArrow = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.contains = ScalarValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.strict = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureValidation {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : undefined,
      max: isSet(object.max) ? globalThis.Number(object.max) : undefined,
      minLength: isSet(object.minLength) ? globalThis.Number(object.minLength) : undefined,
      maxLength: isSet(object.maxLength) ? globalThis.Number(object.maxLength) : undefined,
      minArrow: isSet(object.minArrow) ? ScalarValue.fromJSON(object.minArrow) : undefined,
      maxArrow: isSet(object.maxArrow) ? ScalarValue.fromJSON(object.maxArrow) : undefined,
      minLengthArrow: isSet(object.minLengthArrow) ? ScalarValue.fromJSON(object.minLengthArrow) : undefined,
      maxLengthArrow: isSet(object.maxLengthArrow) ? ScalarValue.fromJSON(object.maxLengthArrow) : undefined,
      contains: isSet(object.contains) ? ScalarValue.fromJSON(object.contains) : undefined,
      strict: isSet(object.strict) ? globalThis.Boolean(object.strict) : false,
    };
  },

  toJSON(message: FeatureValidation): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = message.min;
    }
    if (message.max !== undefined) {
      obj.max = message.max;
    }
    if (message.minLength !== undefined) {
      obj.minLength = Math.round(message.minLength);
    }
    if (message.maxLength !== undefined) {
      obj.maxLength = Math.round(message.maxLength);
    }
    if (message.minArrow !== undefined) {
      obj.minArrow = ScalarValue.toJSON(message.minArrow);
    }
    if (message.maxArrow !== undefined) {
      obj.maxArrow = ScalarValue.toJSON(message.maxArrow);
    }
    if (message.minLengthArrow !== undefined) {
      obj.minLengthArrow = ScalarValue.toJSON(message.minLengthArrow);
    }
    if (message.maxLengthArrow !== undefined) {
      obj.maxLengthArrow = ScalarValue.toJSON(message.maxLengthArrow);
    }
    if (message.contains !== undefined) {
      obj.contains = ScalarValue.toJSON(message.contains);
    }
    if (message.strict !== false) {
      obj.strict = message.strict;
    }
    return obj;
  },
};

function createBaseVersionInfo(): VersionInfo {
  return { default: 0, maximum: 0 };
}

export const VersionInfo: MessageFns<VersionInfo> = {
  encode(message: VersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.default !== 0) {
      writer.uint32(8).uint32(message.default);
    }
    if (message.maximum !== 0) {
      writer.uint32(16).uint32(message.maximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.default = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maximum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionInfo {
    return {
      default: isSet(object.default) ? globalThis.Number(object.default) : 0,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : 0,
    };
  },

  toJSON(message: VersionInfo): unknown {
    const obj: any = {};
    if (message.default !== 0) {
      obj.default = Math.round(message.default);
    }
    if (message.maximum !== 0) {
      obj.maximum = Math.round(message.maximum);
    }
    return obj;
  },
};

function createBaseStrictValidation(): StrictValidation {
  return { feature: undefined, validations: [] };
}

export const StrictValidation: MessageFns<StrictValidation> = {
  encode(message: StrictValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureReference.encode(message.feature, writer.uint32(10).fork()).join();
    }
    for (const v of message.validations) {
      FeatureValidation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrictValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrictValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validations.push(FeatureValidation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrictValidation {
    return {
      feature: isSet(object.feature) ? FeatureReference.fromJSON(object.feature) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => FeatureValidation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrictValidation): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureReference.toJSON(message.feature);
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => FeatureValidation.toJSON(e));
    }
    return obj;
  },
};

function createBaseFeatureEncoder(): FeatureEncoder {
  return { globalFunctionReference: undefined };
}

export const FeatureEncoder: MessageFns<FeatureEncoder> = {
  encode(message: FeatureEncoder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalFunctionReference !== undefined) {
      FunctionGlobalCapturedFunction.encode(message.globalFunctionReference, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureEncoder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureEncoder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.globalFunctionReference = FunctionGlobalCapturedFunction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureEncoder {
    return {
      globalFunctionReference: isSet(object.globalFunctionReference)
        ? FunctionGlobalCapturedFunction.fromJSON(object.globalFunctionReference)
        : undefined,
    };
  },

  toJSON(message: FeatureEncoder): unknown {
    const obj: any = {};
    if (message.globalFunctionReference !== undefined) {
      obj.globalFunctionReference = FunctionGlobalCapturedFunction.toJSON(message.globalFunctionReference);
    }
    return obj;
  },
};

function createBaseFeatureDecoder(): FeatureDecoder {
  return { globalFunctionReference: undefined };
}

export const FeatureDecoder: MessageFns<FeatureDecoder> = {
  encode(message: FeatureDecoder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalFunctionReference !== undefined) {
      FunctionGlobalCapturedFunction.encode(message.globalFunctionReference, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureDecoder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureDecoder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.globalFunctionReference = FunctionGlobalCapturedFunction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureDecoder {
    return {
      globalFunctionReference: isSet(object.globalFunctionReference)
        ? FunctionGlobalCapturedFunction.fromJSON(object.globalFunctionReference)
        : undefined,
    };
  },

  toJSON(message: FeatureDecoder): unknown {
    const obj: any = {};
    if (message.globalFunctionReference !== undefined) {
      obj.globalFunctionReference = FunctionGlobalCapturedFunction.toJSON(message.globalFunctionReference);
    }
    return obj;
  },
};

function createBaseRichClassType(): RichClassType {
  return { moduleName: "", qualname: "", params: [] };
}

export const RichClassType: MessageFns<RichClassType> = {
  encode(message: RichClassType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.qualname !== "") {
      writer.uint32(18).string(message.qualname);
    }
    for (const v of message.params) {
      RichClassType.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RichClassType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRichClassType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.qualname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.params.push(RichClassType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RichClassType {
    return {
      moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
      qualname: isSet(object.qualname) ? globalThis.String(object.qualname) : "",
      params: globalThis.Array.isArray(object?.params) ? object.params.map((e: any) => RichClassType.fromJSON(e)) : [],
    };
  },

  toJSON(message: RichClassType): unknown {
    const obj: any = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.qualname !== "") {
      obj.qualname = message.qualname;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => RichClassType.toJSON(e));
    }
    return obj;
  },
};

function createBaseFeatureRichType(): FeatureRichType {
  return { classType: undefined };
}

export const FeatureRichType: MessageFns<FeatureRichType> = {
  encode(message: FeatureRichType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.classType !== undefined) {
      RichClassType.encode(message.classType, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureRichType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureRichType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.classType = RichClassType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureRichType {
    return { classType: isSet(object.classType) ? RichClassType.fromJSON(object.classType) : undefined };
  },

  toJSON(message: FeatureRichType): unknown {
    const obj: any = {};
    if (message.classType !== undefined) {
      obj.classType = RichClassType.toJSON(message.classType);
    }
    return obj;
  },
};

function createBaseFeatureRichTypeInfo(): FeatureRichTypeInfo {
  return {
    richTypeIsSameAsPrimitiveType: false,
    encoder: undefined,
    decoder: undefined,
    richType: undefined,
    richTypeName: undefined,
  };
}

export const FeatureRichTypeInfo: MessageFns<FeatureRichTypeInfo> = {
  encode(message: FeatureRichTypeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.richTypeIsSameAsPrimitiveType !== false) {
      writer.uint32(8).bool(message.richTypeIsSameAsPrimitiveType);
    }
    if (message.encoder !== undefined) {
      FeatureEncoder.encode(message.encoder, writer.uint32(18).fork()).join();
    }
    if (message.decoder !== undefined) {
      FeatureDecoder.encode(message.decoder, writer.uint32(26).fork()).join();
    }
    if (message.richType !== undefined) {
      FeatureRichType.encode(message.richType, writer.uint32(34).fork()).join();
    }
    if (message.richTypeName !== undefined) {
      writer.uint32(42).string(message.richTypeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureRichTypeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureRichTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.richTypeIsSameAsPrimitiveType = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encoder = FeatureEncoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.decoder = FeatureDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.richType = FeatureRichType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.richTypeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureRichTypeInfo {
    return {
      richTypeIsSameAsPrimitiveType: isSet(object.richTypeIsSameAsPrimitiveType)
        ? globalThis.Boolean(object.richTypeIsSameAsPrimitiveType)
        : false,
      encoder: isSet(object.encoder) ? FeatureEncoder.fromJSON(object.encoder) : undefined,
      decoder: isSet(object.decoder) ? FeatureDecoder.fromJSON(object.decoder) : undefined,
      richType: isSet(object.richType) ? FeatureRichType.fromJSON(object.richType) : undefined,
      richTypeName: isSet(object.richTypeName) ? globalThis.String(object.richTypeName) : undefined,
    };
  },

  toJSON(message: FeatureRichTypeInfo): unknown {
    const obj: any = {};
    if (message.richTypeIsSameAsPrimitiveType !== false) {
      obj.richTypeIsSameAsPrimitiveType = message.richTypeIsSameAsPrimitiveType;
    }
    if (message.encoder !== undefined) {
      obj.encoder = FeatureEncoder.toJSON(message.encoder);
    }
    if (message.decoder !== undefined) {
      obj.decoder = FeatureDecoder.toJSON(message.decoder);
    }
    if (message.richType !== undefined) {
      obj.richType = FeatureRichType.toJSON(message.richType);
    }
    if (message.richTypeName !== undefined) {
      obj.richTypeName = message.richTypeName;
    }
    return obj;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
