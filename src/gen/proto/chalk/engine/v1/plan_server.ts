// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/engine/v1/plan_server.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { OnlineQueryRequest, OnlineQueryResponse } from "../../common/v1/online_query";
import { Plan } from "./plan";

export const protobufPackage = "chalk.engine.v1";

export interface GetPlanRequest {
  onlineQueryRequest: OnlineQueryRequest | undefined;
}

export interface GetPlanResponse {
  plan: Plan | undefined;
}

export interface ExecuteQueryRequest {
  onlineQueryRequest: OnlineQueryRequest | undefined;
}

export interface ExecuteQueryResponse {
  onlineQueryResponse: OnlineQueryResponse | undefined;
}

function createBaseGetPlanRequest(): GetPlanRequest {
  return { onlineQueryRequest: undefined };
}

export const GetPlanRequest: MessageFns<GetPlanRequest> = {
  encode(message: GetPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onlineQueryRequest !== undefined) {
      OnlineQueryRequest.encode(message.onlineQueryRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onlineQueryRequest = OnlineQueryRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPlanRequest {
    return {
      onlineQueryRequest: isSet(object.onlineQueryRequest)
        ? OnlineQueryRequest.fromJSON(object.onlineQueryRequest)
        : undefined,
    };
  },

  toJSON(message: GetPlanRequest): unknown {
    const obj: any = {};
    if (message.onlineQueryRequest !== undefined) {
      obj.onlineQueryRequest = OnlineQueryRequest.toJSON(message.onlineQueryRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPlanRequest>, I>>(base?: I): GetPlanRequest {
    return GetPlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPlanRequest>, I>>(object: I): GetPlanRequest {
    const message = createBaseGetPlanRequest();
    message.onlineQueryRequest = (object.onlineQueryRequest !== undefined && object.onlineQueryRequest !== null)
      ? OnlineQueryRequest.fromPartial(object.onlineQueryRequest)
      : undefined;
    return message;
  },
};

function createBaseGetPlanResponse(): GetPlanResponse {
  return { plan: undefined };
}

export const GetPlanResponse: MessageFns<GetPlanResponse> = {
  encode(message: GetPlanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plan !== undefined) {
      Plan.encode(message.plan, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPlanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plan = Plan.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPlanResponse {
    return { plan: isSet(object.plan) ? Plan.fromJSON(object.plan) : undefined };
  },

  toJSON(message: GetPlanResponse): unknown {
    const obj: any = {};
    if (message.plan !== undefined) {
      obj.plan = Plan.toJSON(message.plan);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPlanResponse>, I>>(base?: I): GetPlanResponse {
    return GetPlanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPlanResponse>, I>>(object: I): GetPlanResponse {
    const message = createBaseGetPlanResponse();
    message.plan = (object.plan !== undefined && object.plan !== null) ? Plan.fromPartial(object.plan) : undefined;
    return message;
  },
};

function createBaseExecuteQueryRequest(): ExecuteQueryRequest {
  return { onlineQueryRequest: undefined };
}

export const ExecuteQueryRequest: MessageFns<ExecuteQueryRequest> = {
  encode(message: ExecuteQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onlineQueryRequest !== undefined) {
      OnlineQueryRequest.encode(message.onlineQueryRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onlineQueryRequest = OnlineQueryRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryRequest {
    return {
      onlineQueryRequest: isSet(object.onlineQueryRequest)
        ? OnlineQueryRequest.fromJSON(object.onlineQueryRequest)
        : undefined,
    };
  },

  toJSON(message: ExecuteQueryRequest): unknown {
    const obj: any = {};
    if (message.onlineQueryRequest !== undefined) {
      obj.onlineQueryRequest = OnlineQueryRequest.toJSON(message.onlineQueryRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteQueryRequest>, I>>(base?: I): ExecuteQueryRequest {
    return ExecuteQueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteQueryRequest>, I>>(object: I): ExecuteQueryRequest {
    const message = createBaseExecuteQueryRequest();
    message.onlineQueryRequest = (object.onlineQueryRequest !== undefined && object.onlineQueryRequest !== null)
      ? OnlineQueryRequest.fromPartial(object.onlineQueryRequest)
      : undefined;
    return message;
  },
};

function createBaseExecuteQueryResponse(): ExecuteQueryResponse {
  return { onlineQueryResponse: undefined };
}

export const ExecuteQueryResponse: MessageFns<ExecuteQueryResponse> = {
  encode(message: ExecuteQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onlineQueryResponse !== undefined) {
      OnlineQueryResponse.encode(message.onlineQueryResponse, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.onlineQueryResponse = OnlineQueryResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryResponse {
    return {
      onlineQueryResponse: isSet(object.onlineQueryResponse)
        ? OnlineQueryResponse.fromJSON(object.onlineQueryResponse)
        : undefined,
    };
  },

  toJSON(message: ExecuteQueryResponse): unknown {
    const obj: any = {};
    if (message.onlineQueryResponse !== undefined) {
      obj.onlineQueryResponse = OnlineQueryResponse.toJSON(message.onlineQueryResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteQueryResponse>, I>>(base?: I): ExecuteQueryResponse {
    return ExecuteQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteQueryResponse>, I>>(object: I): ExecuteQueryResponse {
    const message = createBaseExecuteQueryResponse();
    message.onlineQueryResponse = (object.onlineQueryResponse !== undefined && object.onlineQueryResponse !== null)
      ? OnlineQueryResponse.fromPartial(object.onlineQueryResponse)
      : undefined;
    return message;
  },
};

export type PlanServiceService = typeof PlanServiceService;
export const PlanServiceService = {
  getPlan: {
    path: "/chalk.engine.v1.PlanService/GetPlan",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPlanRequest) => Buffer.from(GetPlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPlanRequest.decode(value),
    responseSerialize: (value: GetPlanResponse) => Buffer.from(GetPlanResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPlanResponse.decode(value),
  },
  /** Fall-back for executing queries on the python engine */
  executeQuery: {
    path: "/chalk.engine.v1.PlanService/ExecuteQuery",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteQueryRequest) => Buffer.from(ExecuteQueryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExecuteQueryRequest.decode(value),
    responseSerialize: (value: ExecuteQueryResponse) => Buffer.from(ExecuteQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExecuteQueryResponse.decode(value),
  },
} as const;

export interface PlanServiceServer extends UntypedServiceImplementation {
  getPlan: handleUnaryCall<GetPlanRequest, GetPlanResponse>;
  /** Fall-back for executing queries on the python engine */
  executeQuery: handleUnaryCall<ExecuteQueryRequest, ExecuteQueryResponse>;
}

export interface PlanServiceClient extends Client {
  getPlan(
    request: GetPlanRequest,
    callback: (error: ServiceError | null, response: GetPlanResponse) => void,
  ): ClientUnaryCall;
  getPlan(
    request: GetPlanRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPlanResponse) => void,
  ): ClientUnaryCall;
  getPlan(
    request: GetPlanRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPlanResponse) => void,
  ): ClientUnaryCall;
  /** Fall-back for executing queries on the python engine */
  executeQuery(
    request: ExecuteQueryRequest,
    callback: (error: ServiceError | null, response: ExecuteQueryResponse) => void,
  ): ClientUnaryCall;
  executeQuery(
    request: ExecuteQueryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecuteQueryResponse) => void,
  ): ClientUnaryCall;
  executeQuery(
    request: ExecuteQueryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecuteQueryResponse) => void,
  ): ClientUnaryCall;
}

export const PlanServiceClient = makeGenericClientConstructor(
  PlanServiceService,
  "chalk.engine.v1.PlanService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PlanServiceClient;
  service: typeof PlanServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
