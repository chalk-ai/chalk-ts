// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: chalk/engine/v1/plan.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ArrowType } from "../../arrow/v1/arrow.pb";

export const protobufPackage = "chalk.engine.v1";

/** Arbitrary computed column that does not correspond to a feature (e.g. for computing a sum(...) ) */
export interface RawColumnKey {
  name: string;
}

/**
 * Represents a feature in the graph that corresponds to a single column in a table, i.e. not a has-many or a dataframe.
 * Basically a "scalar" but shouldn't be confused w/ ScalarFeatureType
 */
export interface FeatureColumnKey {
  rootFqn: string;
}

export interface HasManyFeatureKey {
  rootFqn: string;
  df: DataFrame | undefined;
}

export interface DataFrameFeatureKey {
  rootNamespace: string;
  df: DataFrame | undefined;
}

export interface DataFrame {
  optionalColumns: FeatureColumnKey[];
  requiredColumns: FeatureColumnKey[];
  /** optional Filter filter = 4; // TODO, represents filters on dfs/has-manys like (transaction.amount < 10) */
  limit?: number | undefined;
}

export interface ColumnKey {
  feature?: FeatureColumnKey | undefined;
  raw?: RawColumnKey | undefined;
}

export interface TableKey {
  hasMany?: HasManyFeatureKey | undefined;
  dataFrame?: DataFrameFeatureKey | undefined;
}

export interface Key {
  rawColumn?: RawColumnKey | undefined;
  scalar?: FeatureColumnKey | undefined;
  hasMany?: HasManyFeatureKey | undefined;
  dataframe?: DataFrameFeatureKey | undefined;
}

export interface PyArrowSchema {
  scalars: PyArrowSchema_ColumnSchema[];
  groups: PyArrowSchema_TableSchema[];
}

export interface PyArrowSchema_TableSchema {
  key: TableKey | undefined;
  schema: { [key: string]: ArrowType };
}

export interface PyArrowSchema_TableSchema_SchemaEntry {
  key: string;
  value: ArrowType | undefined;
}

export interface PyArrowSchema_ColumnSchema {
  key: ColumnKey | undefined;
  schema: ArrowType | undefined;
}

export interface Plan {
  nodes: Node[];
  rootNodeIdx: number;
  pyarrowSchema: PyArrowSchema | undefined;
}

export interface Node {
  /** Corresponds to indices in Plan.nodes */
  childrenIndices: number[];
  impl: NodeImpl | undefined;
}

export interface NodeImpl {
  unknown?: UnknownNode | undefined;
  givensScan?: GivensScan | undefined;
  project?: Project | undefined;
  chalkProject?: ChalkProject | undefined;
  defaultInjector?: DefaultInjector | undefined;
}

export interface UnknownNode {
  typeName: string;
}

export interface GivensScan {
  /**
   * / TODO I think there's some discussion as to how exactly Givens will be implemented
   * One option is basically a "project" where it lists expected fields, and caller passes in an actual PlanBatch during execution
   */
  fields: Key[];
}

export interface ChalkProject {
  fields: Key[];
  promoteTsToFeatureTime: boolean;
}

export interface Project {
  fields: Key[];
}

export interface DefaultInjector {
  /** Note: actual default values should be pulled from the graph */
  defaultingFeatures: Key[];
}

function createBaseRawColumnKey(): RawColumnKey {
  return { name: "" };
}

export const RawColumnKey: MessageFns<RawColumnKey> = {
  encode(message: RawColumnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawColumnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawColumnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawColumnKey {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RawColumnKey): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

function createBaseFeatureColumnKey(): FeatureColumnKey {
  return { rootFqn: "" };
}

export const FeatureColumnKey: MessageFns<FeatureColumnKey> = {
  encode(message: FeatureColumnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootFqn !== "") {
      writer.uint32(10).string(message.rootFqn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureColumnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureColumnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootFqn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureColumnKey {
    return { rootFqn: isSet(object.rootFqn) ? globalThis.String(object.rootFqn) : "" };
  },

  toJSON(message: FeatureColumnKey): unknown {
    const obj: any = {};
    if (message.rootFqn !== "") {
      obj.rootFqn = message.rootFqn;
    }
    return obj;
  },
};

function createBaseHasManyFeatureKey(): HasManyFeatureKey {
  return { rootFqn: "", df: undefined };
}

export const HasManyFeatureKey: MessageFns<HasManyFeatureKey> = {
  encode(message: HasManyFeatureKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootFqn !== "") {
      writer.uint32(10).string(message.rootFqn);
    }
    if (message.df !== undefined) {
      DataFrame.encode(message.df, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HasManyFeatureKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHasManyFeatureKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootFqn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.df = DataFrame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HasManyFeatureKey {
    return {
      rootFqn: isSet(object.rootFqn) ? globalThis.String(object.rootFqn) : "",
      df: isSet(object.df) ? DataFrame.fromJSON(object.df) : undefined,
    };
  },

  toJSON(message: HasManyFeatureKey): unknown {
    const obj: any = {};
    if (message.rootFqn !== "") {
      obj.rootFqn = message.rootFqn;
    }
    if (message.df !== undefined) {
      obj.df = DataFrame.toJSON(message.df);
    }
    return obj;
  },
};

function createBaseDataFrameFeatureKey(): DataFrameFeatureKey {
  return { rootNamespace: "", df: undefined };
}

export const DataFrameFeatureKey: MessageFns<DataFrameFeatureKey> = {
  encode(message: DataFrameFeatureKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootNamespace !== "") {
      writer.uint32(10).string(message.rootNamespace);
    }
    if (message.df !== undefined) {
      DataFrame.encode(message.df, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataFrameFeatureKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataFrameFeatureKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootNamespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.df = DataFrame.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataFrameFeatureKey {
    return {
      rootNamespace: isSet(object.rootNamespace) ? globalThis.String(object.rootNamespace) : "",
      df: isSet(object.df) ? DataFrame.fromJSON(object.df) : undefined,
    };
  },

  toJSON(message: DataFrameFeatureKey): unknown {
    const obj: any = {};
    if (message.rootNamespace !== "") {
      obj.rootNamespace = message.rootNamespace;
    }
    if (message.df !== undefined) {
      obj.df = DataFrame.toJSON(message.df);
    }
    return obj;
  },
};

function createBaseDataFrame(): DataFrame {
  return { optionalColumns: [], requiredColumns: [], limit: undefined };
}

export const DataFrame: MessageFns<DataFrame> = {
  encode(message: DataFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.optionalColumns) {
      FeatureColumnKey.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.requiredColumns) {
      FeatureColumnKey.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.limit !== undefined) {
      writer.uint32(24).uint64(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.optionalColumns.push(FeatureColumnKey.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requiredColumns.push(FeatureColumnKey.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataFrame {
    return {
      optionalColumns: globalThis.Array.isArray(object?.optionalColumns)
        ? object.optionalColumns.map((e: any) => FeatureColumnKey.fromJSON(e))
        : [],
      requiredColumns: globalThis.Array.isArray(object?.requiredColumns)
        ? object.requiredColumns.map((e: any) => FeatureColumnKey.fromJSON(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: DataFrame): unknown {
    const obj: any = {};
    if (message.optionalColumns?.length) {
      obj.optionalColumns = message.optionalColumns.map((e) => FeatureColumnKey.toJSON(e));
    }
    if (message.requiredColumns?.length) {
      obj.requiredColumns = message.requiredColumns.map((e) => FeatureColumnKey.toJSON(e));
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },
};

function createBaseColumnKey(): ColumnKey {
  return { feature: undefined, raw: undefined };
}

export const ColumnKey: MessageFns<ColumnKey> = {
  encode(message: ColumnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feature !== undefined) {
      FeatureColumnKey.encode(message.feature, writer.uint32(10).fork()).join();
    }
    if (message.raw !== undefined) {
      RawColumnKey.encode(message.raw, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feature = FeatureColumnKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.raw = RawColumnKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnKey {
    return {
      feature: isSet(object.feature) ? FeatureColumnKey.fromJSON(object.feature) : undefined,
      raw: isSet(object.raw) ? RawColumnKey.fromJSON(object.raw) : undefined,
    };
  },

  toJSON(message: ColumnKey): unknown {
    const obj: any = {};
    if (message.feature !== undefined) {
      obj.feature = FeatureColumnKey.toJSON(message.feature);
    }
    if (message.raw !== undefined) {
      obj.raw = RawColumnKey.toJSON(message.raw);
    }
    return obj;
  },
};

function createBaseTableKey(): TableKey {
  return { hasMany: undefined, dataFrame: undefined };
}

export const TableKey: MessageFns<TableKey> = {
  encode(message: TableKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasMany !== undefined) {
      HasManyFeatureKey.encode(message.hasMany, writer.uint32(10).fork()).join();
    }
    if (message.dataFrame !== undefined) {
      DataFrameFeatureKey.encode(message.dataFrame, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hasMany = HasManyFeatureKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataFrame = DataFrameFeatureKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableKey {
    return {
      hasMany: isSet(object.hasMany) ? HasManyFeatureKey.fromJSON(object.hasMany) : undefined,
      dataFrame: isSet(object.dataFrame) ? DataFrameFeatureKey.fromJSON(object.dataFrame) : undefined,
    };
  },

  toJSON(message: TableKey): unknown {
    const obj: any = {};
    if (message.hasMany !== undefined) {
      obj.hasMany = HasManyFeatureKey.toJSON(message.hasMany);
    }
    if (message.dataFrame !== undefined) {
      obj.dataFrame = DataFrameFeatureKey.toJSON(message.dataFrame);
    }
    return obj;
  },
};

function createBaseKey(): Key {
  return { rawColumn: undefined, scalar: undefined, hasMany: undefined, dataframe: undefined };
}

export const Key: MessageFns<Key> = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawColumn !== undefined) {
      RawColumnKey.encode(message.rawColumn, writer.uint32(10).fork()).join();
    }
    if (message.scalar !== undefined) {
      FeatureColumnKey.encode(message.scalar, writer.uint32(18).fork()).join();
    }
    if (message.hasMany !== undefined) {
      HasManyFeatureKey.encode(message.hasMany, writer.uint32(26).fork()).join();
    }
    if (message.dataframe !== undefined) {
      DataFrameFeatureKey.encode(message.dataframe, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawColumn = RawColumnKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scalar = FeatureColumnKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hasMany = HasManyFeatureKey.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dataframe = DataFrameFeatureKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      rawColumn: isSet(object.rawColumn) ? RawColumnKey.fromJSON(object.rawColumn) : undefined,
      scalar: isSet(object.scalar) ? FeatureColumnKey.fromJSON(object.scalar) : undefined,
      hasMany: isSet(object.hasMany) ? HasManyFeatureKey.fromJSON(object.hasMany) : undefined,
      dataframe: isSet(object.dataframe) ? DataFrameFeatureKey.fromJSON(object.dataframe) : undefined,
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.rawColumn !== undefined) {
      obj.rawColumn = RawColumnKey.toJSON(message.rawColumn);
    }
    if (message.scalar !== undefined) {
      obj.scalar = FeatureColumnKey.toJSON(message.scalar);
    }
    if (message.hasMany !== undefined) {
      obj.hasMany = HasManyFeatureKey.toJSON(message.hasMany);
    }
    if (message.dataframe !== undefined) {
      obj.dataframe = DataFrameFeatureKey.toJSON(message.dataframe);
    }
    return obj;
  },
};

function createBasePyArrowSchema(): PyArrowSchema {
  return { scalars: [], groups: [] };
}

export const PyArrowSchema: MessageFns<PyArrowSchema> = {
  encode(message: PyArrowSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scalars) {
      PyArrowSchema_ColumnSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.groups) {
      PyArrowSchema_TableSchema.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PyArrowSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePyArrowSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scalars.push(PyArrowSchema_ColumnSchema.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groups.push(PyArrowSchema_TableSchema.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PyArrowSchema {
    return {
      scalars: globalThis.Array.isArray(object?.scalars)
        ? object.scalars.map((e: any) => PyArrowSchema_ColumnSchema.fromJSON(e))
        : [],
      groups: globalThis.Array.isArray(object?.groups)
        ? object.groups.map((e: any) => PyArrowSchema_TableSchema.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PyArrowSchema): unknown {
    const obj: any = {};
    if (message.scalars?.length) {
      obj.scalars = message.scalars.map((e) => PyArrowSchema_ColumnSchema.toJSON(e));
    }
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => PyArrowSchema_TableSchema.toJSON(e));
    }
    return obj;
  },
};

function createBasePyArrowSchema_TableSchema(): PyArrowSchema_TableSchema {
  return { key: undefined, schema: {} };
}

export const PyArrowSchema_TableSchema: MessageFns<PyArrowSchema_TableSchema> = {
  encode(message: PyArrowSchema_TableSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      TableKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    Object.entries(message.schema).forEach(([key, value]) => {
      PyArrowSchema_TableSchema_SchemaEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PyArrowSchema_TableSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePyArrowSchema_TableSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = TableKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = PyArrowSchema_TableSchema_SchemaEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.schema[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PyArrowSchema_TableSchema {
    return {
      key: isSet(object.key) ? TableKey.fromJSON(object.key) : undefined,
      schema: isObject(object.schema)
        ? Object.entries(object.schema).reduce<{ [key: string]: ArrowType }>((acc, [key, value]) => {
          acc[key] = ArrowType.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PyArrowSchema_TableSchema): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = TableKey.toJSON(message.key);
    }
    if (message.schema) {
      const entries = Object.entries(message.schema);
      if (entries.length > 0) {
        obj.schema = {};
        entries.forEach(([k, v]) => {
          obj.schema[k] = ArrowType.toJSON(v);
        });
      }
    }
    return obj;
  },
};

function createBasePyArrowSchema_TableSchema_SchemaEntry(): PyArrowSchema_TableSchema_SchemaEntry {
  return { key: "", value: undefined };
}

export const PyArrowSchema_TableSchema_SchemaEntry: MessageFns<PyArrowSchema_TableSchema_SchemaEntry> = {
  encode(message: PyArrowSchema_TableSchema_SchemaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ArrowType.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PyArrowSchema_TableSchema_SchemaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePyArrowSchema_TableSchema_SchemaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PyArrowSchema_TableSchema_SchemaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ArrowType.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PyArrowSchema_TableSchema_SchemaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ArrowType.toJSON(message.value);
    }
    return obj;
  },
};

function createBasePyArrowSchema_ColumnSchema(): PyArrowSchema_ColumnSchema {
  return { key: undefined, schema: undefined };
}

export const PyArrowSchema_ColumnSchema: MessageFns<PyArrowSchema_ColumnSchema> = {
  encode(message: PyArrowSchema_ColumnSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      ColumnKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.schema !== undefined) {
      ArrowType.encode(message.schema, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PyArrowSchema_ColumnSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePyArrowSchema_ColumnSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = ColumnKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = ArrowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PyArrowSchema_ColumnSchema {
    return {
      key: isSet(object.key) ? ColumnKey.fromJSON(object.key) : undefined,
      schema: isSet(object.schema) ? ArrowType.fromJSON(object.schema) : undefined,
    };
  },

  toJSON(message: PyArrowSchema_ColumnSchema): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = ColumnKey.toJSON(message.key);
    }
    if (message.schema !== undefined) {
      obj.schema = ArrowType.toJSON(message.schema);
    }
    return obj;
  },
};

function createBasePlan(): Plan {
  return { nodes: [], rootNodeIdx: 0, pyarrowSchema: undefined };
}

export const Plan: MessageFns<Plan> = {
  encode(message: Plan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.rootNodeIdx !== 0) {
      writer.uint32(16).uint32(message.rootNodeIdx);
    }
    if (message.pyarrowSchema !== undefined) {
      PyArrowSchema.encode(message.pyarrowSchema, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Plan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rootNodeIdx = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pyarrowSchema = PyArrowSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Plan {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      rootNodeIdx: isSet(object.rootNodeIdx) ? globalThis.Number(object.rootNodeIdx) : 0,
      pyarrowSchema: isSet(object.pyarrowSchema) ? PyArrowSchema.fromJSON(object.pyarrowSchema) : undefined,
    };
  },

  toJSON(message: Plan): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.rootNodeIdx !== 0) {
      obj.rootNodeIdx = Math.round(message.rootNodeIdx);
    }
    if (message.pyarrowSchema !== undefined) {
      obj.pyarrowSchema = PyArrowSchema.toJSON(message.pyarrowSchema);
    }
    return obj;
  },
};

function createBaseNode(): Node {
  return { childrenIndices: [], impl: undefined };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.childrenIndices) {
      writer.uint32(v);
    }
    writer.join();
    if (message.impl !== undefined) {
      NodeImpl.encode(message.impl, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.childrenIndices.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.childrenIndices.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.impl = NodeImpl.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      childrenIndices: globalThis.Array.isArray(object?.childrenIndices)
        ? object.childrenIndices.map((e: any) => globalThis.Number(e))
        : [],
      impl: isSet(object.impl) ? NodeImpl.fromJSON(object.impl) : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.childrenIndices?.length) {
      obj.childrenIndices = message.childrenIndices.map((e) => Math.round(e));
    }
    if (message.impl !== undefined) {
      obj.impl = NodeImpl.toJSON(message.impl);
    }
    return obj;
  },
};

function createBaseNodeImpl(): NodeImpl {
  return {
    unknown: undefined,
    givensScan: undefined,
    project: undefined,
    chalkProject: undefined,
    defaultInjector: undefined,
  };
}

export const NodeImpl: MessageFns<NodeImpl> = {
  encode(message: NodeImpl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      UnknownNode.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.givensScan !== undefined) {
      GivensScan.encode(message.givensScan, writer.uint32(18).fork()).join();
    }
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(26).fork()).join();
    }
    if (message.chalkProject !== undefined) {
      ChalkProject.encode(message.chalkProject, writer.uint32(34).fork()).join();
    }
    if (message.defaultInjector !== undefined) {
      DefaultInjector.encode(message.defaultInjector, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeImpl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeImpl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = UnknownNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.givensScan = GivensScan.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.project = Project.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chalkProject = ChalkProject.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultInjector = DefaultInjector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeImpl {
    return {
      unknown: isSet(object.unknown) ? UnknownNode.fromJSON(object.unknown) : undefined,
      givensScan: isSet(object.givensScan) ? GivensScan.fromJSON(object.givensScan) : undefined,
      project: isSet(object.project) ? Project.fromJSON(object.project) : undefined,
      chalkProject: isSet(object.chalkProject) ? ChalkProject.fromJSON(object.chalkProject) : undefined,
      defaultInjector: isSet(object.defaultInjector) ? DefaultInjector.fromJSON(object.defaultInjector) : undefined,
    };
  },

  toJSON(message: NodeImpl): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = UnknownNode.toJSON(message.unknown);
    }
    if (message.givensScan !== undefined) {
      obj.givensScan = GivensScan.toJSON(message.givensScan);
    }
    if (message.project !== undefined) {
      obj.project = Project.toJSON(message.project);
    }
    if (message.chalkProject !== undefined) {
      obj.chalkProject = ChalkProject.toJSON(message.chalkProject);
    }
    if (message.defaultInjector !== undefined) {
      obj.defaultInjector = DefaultInjector.toJSON(message.defaultInjector);
    }
    return obj;
  },
};

function createBaseUnknownNode(): UnknownNode {
  return { typeName: "" };
}

export const UnknownNode: MessageFns<UnknownNode> = {
  encode(message: UnknownNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeName !== "") {
      writer.uint32(10).string(message.typeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.typeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnknownNode {
    return { typeName: isSet(object.typeName) ? globalThis.String(object.typeName) : "" };
  },

  toJSON(message: UnknownNode): unknown {
    const obj: any = {};
    if (message.typeName !== "") {
      obj.typeName = message.typeName;
    }
    return obj;
  },
};

function createBaseGivensScan(): GivensScan {
  return { fields: [] };
}

export const GivensScan: MessageFns<GivensScan> = {
  encode(message: GivensScan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GivensScan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGivensScan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fields.push(Key.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GivensScan {
    return { fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Key.fromJSON(e)) : [] };
  },

  toJSON(message: GivensScan): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Key.toJSON(e));
    }
    return obj;
  },
};

function createBaseChalkProject(): ChalkProject {
  return { fields: [], promoteTsToFeatureTime: false };
}

export const ChalkProject: MessageFns<ChalkProject> = {
  encode(message: ChalkProject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.promoteTsToFeatureTime !== false) {
      writer.uint32(16).bool(message.promoteTsToFeatureTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChalkProject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChalkProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fields.push(Key.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.promoteTsToFeatureTime = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChalkProject {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Key.fromJSON(e)) : [],
      promoteTsToFeatureTime: isSet(object.promoteTsToFeatureTime)
        ? globalThis.Boolean(object.promoteTsToFeatureTime)
        : false,
    };
  },

  toJSON(message: ChalkProject): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Key.toJSON(e));
    }
    if (message.promoteTsToFeatureTime !== false) {
      obj.promoteTsToFeatureTime = message.promoteTsToFeatureTime;
    }
    return obj;
  },
};

function createBaseProject(): Project {
  return { fields: [] };
}

export const Project: MessageFns<Project> = {
  encode(message: Project, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Project {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fields.push(Key.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Project {
    return { fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Key.fromJSON(e)) : [] };
  },

  toJSON(message: Project): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Key.toJSON(e));
    }
    return obj;
  },
};

function createBaseDefaultInjector(): DefaultInjector {
  return { defaultingFeatures: [] };
}

export const DefaultInjector: MessageFns<DefaultInjector> = {
  encode(message: DefaultInjector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.defaultingFeatures) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultInjector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultInjector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.defaultingFeatures.push(Key.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultInjector {
    return {
      defaultingFeatures: globalThis.Array.isArray(object?.defaultingFeatures)
        ? object.defaultingFeatures.map((e: any) => Key.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DefaultInjector): unknown {
    const obj: any = {};
    if (message.defaultingFeatures?.length) {
      obj.defaultingFeatures = message.defaultingFeatures.map((e) => Key.toJSON(e));
    }
    return obj;
  },
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
