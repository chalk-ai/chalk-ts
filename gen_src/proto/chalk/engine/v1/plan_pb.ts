// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/engine/v1/plan.proto (package chalk.engine.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ArrowType } from "../../arrow/v1/arrow_pb";

/**
 * Arbitrary computed column that does not correspond to a feature (e.g. for computing a sum(...) )
 *
 * @generated from message chalk.engine.v1.RawColumnKey
 */
export class RawColumnKey extends Message<RawColumnKey> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<RawColumnKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.RawColumnKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RawColumnKey {
    return new RawColumnKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RawColumnKey {
    return new RawColumnKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RawColumnKey {
    return new RawColumnKey().fromJsonString(jsonString, options);
  }

  static equals(a: RawColumnKey | PlainMessage<RawColumnKey> | undefined, b: RawColumnKey | PlainMessage<RawColumnKey> | undefined): boolean {
    return proto3.util.equals(RawColumnKey, a, b);
  }
}

/**
 * Represents a feature in the graph that corresponds to a single column in a table, i.e. not a has-many or a dataframe.
 * Basically a "scalar" but shouldn't be confused w/ ScalarFeatureType
 *
 * @generated from message chalk.engine.v1.FeatureColumnKey
 */
export class FeatureColumnKey extends Message<FeatureColumnKey> {
  /**
   * @generated from field: string root_fqn = 1;
   */
  rootFqn = "";

  constructor(data?: PartialMessage<FeatureColumnKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.FeatureColumnKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_fqn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeatureColumnKey {
    return new FeatureColumnKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeatureColumnKey {
    return new FeatureColumnKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeatureColumnKey {
    return new FeatureColumnKey().fromJsonString(jsonString, options);
  }

  static equals(a: FeatureColumnKey | PlainMessage<FeatureColumnKey> | undefined, b: FeatureColumnKey | PlainMessage<FeatureColumnKey> | undefined): boolean {
    return proto3.util.equals(FeatureColumnKey, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.HasManyFeatureKey
 */
export class HasManyFeatureKey extends Message<HasManyFeatureKey> {
  /**
   * @generated from field: string root_fqn = 1;
   */
  rootFqn = "";

  /**
   * @generated from field: chalk.engine.v1.DataFrame df = 2;
   */
  df?: DataFrame;

  constructor(data?: PartialMessage<HasManyFeatureKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.HasManyFeatureKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_fqn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "df", kind: "message", T: DataFrame },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HasManyFeatureKey {
    return new HasManyFeatureKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HasManyFeatureKey {
    return new HasManyFeatureKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HasManyFeatureKey {
    return new HasManyFeatureKey().fromJsonString(jsonString, options);
  }

  static equals(a: HasManyFeatureKey | PlainMessage<HasManyFeatureKey> | undefined, b: HasManyFeatureKey | PlainMessage<HasManyFeatureKey> | undefined): boolean {
    return proto3.util.equals(HasManyFeatureKey, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.DataFrameFeatureKey
 */
export class DataFrameFeatureKey extends Message<DataFrameFeatureKey> {
  /**
   * @generated from field: string root_namespace = 1;
   */
  rootNamespace = "";

  /**
   * @generated from field: chalk.engine.v1.DataFrame df = 2;
   */
  df?: DataFrame;

  constructor(data?: PartialMessage<DataFrameFeatureKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.DataFrameFeatureKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "df", kind: "message", T: DataFrame },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataFrameFeatureKey {
    return new DataFrameFeatureKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataFrameFeatureKey {
    return new DataFrameFeatureKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataFrameFeatureKey {
    return new DataFrameFeatureKey().fromJsonString(jsonString, options);
  }

  static equals(a: DataFrameFeatureKey | PlainMessage<DataFrameFeatureKey> | undefined, b: DataFrameFeatureKey | PlainMessage<DataFrameFeatureKey> | undefined): boolean {
    return proto3.util.equals(DataFrameFeatureKey, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.DataFrame
 */
export class DataFrame extends Message<DataFrame> {
  /**
   * @generated from field: repeated chalk.engine.v1.FeatureColumnKey optional_columns = 1;
   */
  optionalColumns: FeatureColumnKey[] = [];

  /**
   * @generated from field: repeated chalk.engine.v1.FeatureColumnKey required_columns = 2;
   */
  requiredColumns: FeatureColumnKey[] = [];

  /**
   * optional Filter filter = 4; // TODO, represents filters on dfs/has-manys like (transaction.amount < 10)
   *
   * @generated from field: optional uint64 limit = 3;
   */
  limit?: bigint;

  constructor(data?: PartialMessage<DataFrame>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.DataFrame";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "optional_columns", kind: "message", T: FeatureColumnKey, repeated: true },
    { no: 2, name: "required_columns", kind: "message", T: FeatureColumnKey, repeated: true },
    { no: 3, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataFrame {
    return new DataFrame().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataFrame {
    return new DataFrame().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataFrame {
    return new DataFrame().fromJsonString(jsonString, options);
  }

  static equals(a: DataFrame | PlainMessage<DataFrame> | undefined, b: DataFrame | PlainMessage<DataFrame> | undefined): boolean {
    return proto3.util.equals(DataFrame, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.ColumnKey
 */
export class ColumnKey extends Message<ColumnKey> {
  /**
   * @generated from oneof chalk.engine.v1.ColumnKey.key
   */
  key: {
    /**
     * @generated from field: chalk.engine.v1.FeatureColumnKey feature = 1;
     */
    value: FeatureColumnKey;
    case: "feature";
  } | {
    /**
     * @generated from field: chalk.engine.v1.RawColumnKey raw = 2;
     */
    value: RawColumnKey;
    case: "raw";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ColumnKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.ColumnKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feature", kind: "message", T: FeatureColumnKey, oneof: "key" },
    { no: 2, name: "raw", kind: "message", T: RawColumnKey, oneof: "key" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnKey {
    return new ColumnKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnKey {
    return new ColumnKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnKey {
    return new ColumnKey().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnKey | PlainMessage<ColumnKey> | undefined, b: ColumnKey | PlainMessage<ColumnKey> | undefined): boolean {
    return proto3.util.equals(ColumnKey, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.TableKey
 */
export class TableKey extends Message<TableKey> {
  /**
   * @generated from oneof chalk.engine.v1.TableKey.key
   */
  key: {
    /**
     * @generated from field: chalk.engine.v1.HasManyFeatureKey has_many = 1;
     */
    value: HasManyFeatureKey;
    case: "hasMany";
  } | {
    /**
     * @generated from field: chalk.engine.v1.DataFrameFeatureKey data_frame = 2;
     */
    value: DataFrameFeatureKey;
    case: "dataFrame";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TableKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.TableKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "has_many", kind: "message", T: HasManyFeatureKey, oneof: "key" },
    { no: 2, name: "data_frame", kind: "message", T: DataFrameFeatureKey, oneof: "key" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableKey {
    return new TableKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableKey {
    return new TableKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableKey {
    return new TableKey().fromJsonString(jsonString, options);
  }

  static equals(a: TableKey | PlainMessage<TableKey> | undefined, b: TableKey | PlainMessage<TableKey> | undefined): boolean {
    return proto3.util.equals(TableKey, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.Key
 */
export class Key extends Message<Key> {
  /**
   * @generated from oneof chalk.engine.v1.Key.impl
   */
  impl: {
    /**
     * @generated from field: chalk.engine.v1.RawColumnKey raw_column = 1;
     */
    value: RawColumnKey;
    case: "rawColumn";
  } | {
    /**
     * @generated from field: chalk.engine.v1.FeatureColumnKey scalar = 2;
     */
    value: FeatureColumnKey;
    case: "scalar";
  } | {
    /**
     * @generated from field: chalk.engine.v1.HasManyFeatureKey has_many = 3;
     */
    value: HasManyFeatureKey;
    case: "hasMany";
  } | {
    /**
     * @generated from field: chalk.engine.v1.DataFrameFeatureKey dataframe = 4;
     */
    value: DataFrameFeatureKey;
    case: "dataframe";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Key>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.Key";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "raw_column", kind: "message", T: RawColumnKey, oneof: "impl" },
    { no: 2, name: "scalar", kind: "message", T: FeatureColumnKey, oneof: "impl" },
    { no: 3, name: "has_many", kind: "message", T: HasManyFeatureKey, oneof: "impl" },
    { no: 4, name: "dataframe", kind: "message", T: DataFrameFeatureKey, oneof: "impl" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Key {
    return new Key().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJsonString(jsonString, options);
  }

  static equals(a: Key | PlainMessage<Key> | undefined, b: Key | PlainMessage<Key> | undefined): boolean {
    return proto3.util.equals(Key, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.PyArrowSchema
 */
export class PyArrowSchema extends Message<PyArrowSchema> {
  /**
   * @generated from field: repeated chalk.engine.v1.PyArrowSchema.ColumnSchema scalars = 1;
   */
  scalars: PyArrowSchema_ColumnSchema[] = [];

  /**
   * @generated from field: repeated chalk.engine.v1.PyArrowSchema.TableSchema groups = 2;
   */
  groups: PyArrowSchema_TableSchema[] = [];

  constructor(data?: PartialMessage<PyArrowSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.PyArrowSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalars", kind: "message", T: PyArrowSchema_ColumnSchema, repeated: true },
    { no: 2, name: "groups", kind: "message", T: PyArrowSchema_TableSchema, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PyArrowSchema {
    return new PyArrowSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PyArrowSchema {
    return new PyArrowSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PyArrowSchema {
    return new PyArrowSchema().fromJsonString(jsonString, options);
  }

  static equals(a: PyArrowSchema | PlainMessage<PyArrowSchema> | undefined, b: PyArrowSchema | PlainMessage<PyArrowSchema> | undefined): boolean {
    return proto3.util.equals(PyArrowSchema, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.PyArrowSchema.TableSchema
 */
export class PyArrowSchema_TableSchema extends Message<PyArrowSchema_TableSchema> {
  /**
   * @generated from field: chalk.engine.v1.TableKey key = 1;
   */
  key?: TableKey;

  /**
   * @generated from field: map<string, chalk.arrow.v1.ArrowType> schema = 2;
   */
  schema: { [key: string]: ArrowType } = {};

  constructor(data?: PartialMessage<PyArrowSchema_TableSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.PyArrowSchema.TableSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: TableKey },
    { no: 2, name: "schema", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ArrowType} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PyArrowSchema_TableSchema {
    return new PyArrowSchema_TableSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PyArrowSchema_TableSchema {
    return new PyArrowSchema_TableSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PyArrowSchema_TableSchema {
    return new PyArrowSchema_TableSchema().fromJsonString(jsonString, options);
  }

  static equals(a: PyArrowSchema_TableSchema | PlainMessage<PyArrowSchema_TableSchema> | undefined, b: PyArrowSchema_TableSchema | PlainMessage<PyArrowSchema_TableSchema> | undefined): boolean {
    return proto3.util.equals(PyArrowSchema_TableSchema, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.PyArrowSchema.ColumnSchema
 */
export class PyArrowSchema_ColumnSchema extends Message<PyArrowSchema_ColumnSchema> {
  /**
   * @generated from field: chalk.engine.v1.ColumnKey key = 1;
   */
  key?: ColumnKey;

  /**
   * @generated from field: chalk.arrow.v1.ArrowType schema = 2;
   */
  schema?: ArrowType;

  constructor(data?: PartialMessage<PyArrowSchema_ColumnSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.PyArrowSchema.ColumnSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: ColumnKey },
    { no: 2, name: "schema", kind: "message", T: ArrowType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PyArrowSchema_ColumnSchema {
    return new PyArrowSchema_ColumnSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PyArrowSchema_ColumnSchema {
    return new PyArrowSchema_ColumnSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PyArrowSchema_ColumnSchema {
    return new PyArrowSchema_ColumnSchema().fromJsonString(jsonString, options);
  }

  static equals(a: PyArrowSchema_ColumnSchema | PlainMessage<PyArrowSchema_ColumnSchema> | undefined, b: PyArrowSchema_ColumnSchema | PlainMessage<PyArrowSchema_ColumnSchema> | undefined): boolean {
    return proto3.util.equals(PyArrowSchema_ColumnSchema, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.Plan
 */
export class Plan extends Message<Plan> {
  /**
   * @generated from field: repeated chalk.engine.v1.Node nodes = 1;
   */
  nodes: Node[] = [];

  /**
   * @generated from field: uint32 root_node_idx = 2;
   */
  rootNodeIdx = 0;

  /**
   * @generated from field: chalk.engine.v1.PyArrowSchema pyarrow_schema = 3;
   */
  pyarrowSchema?: PyArrowSchema;

  constructor(data?: PartialMessage<Plan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.Plan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Node, repeated: true },
    { no: 2, name: "root_node_idx", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "pyarrow_schema", kind: "message", T: PyArrowSchema },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plan {
    return new Plan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plan {
    return new Plan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plan {
    return new Plan().fromJsonString(jsonString, options);
  }

  static equals(a: Plan | PlainMessage<Plan> | undefined, b: Plan | PlainMessage<Plan> | undefined): boolean {
    return proto3.util.equals(Plan, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.Node
 */
export class Node extends Message<Node> {
  /**
   * Corresponds to indices in Plan.nodes
   *
   * @generated from field: repeated uint32 children_indices = 1;
   */
  childrenIndices: number[] = [];

  /**
   * @generated from field: chalk.engine.v1.NodeImpl impl = 2;
   */
  impl?: NodeImpl;

  constructor(data?: PartialMessage<Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "children_indices", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 2, name: "impl", kind: "message", T: NodeImpl },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node {
    return new Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJsonString(jsonString, options);
  }

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean {
    return proto3.util.equals(Node, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.NodeImpl
 */
export class NodeImpl extends Message<NodeImpl> {
  /**
   * @generated from oneof chalk.engine.v1.NodeImpl.impl
   */
  impl: {
    /**
     * @generated from field: chalk.engine.v1.UnknownNode unknown = 1;
     */
    value: UnknownNode;
    case: "unknown";
  } | {
    /**
     * @generated from field: chalk.engine.v1.GivensScan givens_scan = 2;
     */
    value: GivensScan;
    case: "givensScan";
  } | {
    /**
     * @generated from field: chalk.engine.v1.Project project = 3;
     */
    value: Project;
    case: "project";
  } | {
    /**
     * @generated from field: chalk.engine.v1.ChalkProject chalk_project = 4;
     */
    value: ChalkProject;
    case: "chalkProject";
  } | {
    /**
     * @generated from field: chalk.engine.v1.DefaultInjector default_injector = 5;
     */
    value: DefaultInjector;
    case: "defaultInjector";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NodeImpl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.NodeImpl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unknown", kind: "message", T: UnknownNode, oneof: "impl" },
    { no: 2, name: "givens_scan", kind: "message", T: GivensScan, oneof: "impl" },
    { no: 3, name: "project", kind: "message", T: Project, oneof: "impl" },
    { no: 4, name: "chalk_project", kind: "message", T: ChalkProject, oneof: "impl" },
    { no: 5, name: "default_injector", kind: "message", T: DefaultInjector, oneof: "impl" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeImpl {
    return new NodeImpl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeImpl {
    return new NodeImpl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeImpl {
    return new NodeImpl().fromJsonString(jsonString, options);
  }

  static equals(a: NodeImpl | PlainMessage<NodeImpl> | undefined, b: NodeImpl | PlainMessage<NodeImpl> | undefined): boolean {
    return proto3.util.equals(NodeImpl, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.UnknownNode
 */
export class UnknownNode extends Message<UnknownNode> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  constructor(data?: PartialMessage<UnknownNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.UnknownNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnknownNode {
    return new UnknownNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnknownNode {
    return new UnknownNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnknownNode {
    return new UnknownNode().fromJsonString(jsonString, options);
  }

  static equals(a: UnknownNode | PlainMessage<UnknownNode> | undefined, b: UnknownNode | PlainMessage<UnknownNode> | undefined): boolean {
    return proto3.util.equals(UnknownNode, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.GivensScan
 */
export class GivensScan extends Message<GivensScan> {
  /**
   * / TODO I think there's some discussion as to how exactly Givens will be implemented
   * One option is basically a "project" where it lists expected fields, and caller passes in an actual PlanBatch during execution
   *
   * @generated from field: repeated chalk.engine.v1.Key fields = 1;
   */
  fields: Key[] = [];

  constructor(data?: PartialMessage<GivensScan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.GivensScan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GivensScan {
    return new GivensScan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GivensScan {
    return new GivensScan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GivensScan {
    return new GivensScan().fromJsonString(jsonString, options);
  }

  static equals(a: GivensScan | PlainMessage<GivensScan> | undefined, b: GivensScan | PlainMessage<GivensScan> | undefined): boolean {
    return proto3.util.equals(GivensScan, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.ChalkProject
 */
export class ChalkProject extends Message<ChalkProject> {
  /**
   * @generated from field: repeated chalk.engine.v1.Key fields = 1;
   */
  fields: Key[] = [];

  /**
   * @generated from field: bool promote_ts_to_feature_time = 2;
   */
  promoteTsToFeatureTime = false;

  constructor(data?: PartialMessage<ChalkProject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.ChalkProject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "message", T: Key, repeated: true },
    { no: 2, name: "promote_ts_to_feature_time", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChalkProject {
    return new ChalkProject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChalkProject {
    return new ChalkProject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChalkProject {
    return new ChalkProject().fromJsonString(jsonString, options);
  }

  static equals(a: ChalkProject | PlainMessage<ChalkProject> | undefined, b: ChalkProject | PlainMessage<ChalkProject> | undefined): boolean {
    return proto3.util.equals(ChalkProject, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.Project
 */
export class Project extends Message<Project> {
  /**
   * @generated from field: repeated chalk.engine.v1.Key fields = 1;
   */
  fields: Key[] = [];

  constructor(data?: PartialMessage<Project>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.Project";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Project {
    return new Project().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Project {
    return new Project().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Project {
    return new Project().fromJsonString(jsonString, options);
  }

  static equals(a: Project | PlainMessage<Project> | undefined, b: Project | PlainMessage<Project> | undefined): boolean {
    return proto3.util.equals(Project, a, b);
  }
}

/**
 * @generated from message chalk.engine.v1.DefaultInjector
 */
export class DefaultInjector extends Message<DefaultInjector> {
  /**
   * Note: actual default values should be pulled from the graph
   *
   * @generated from field: repeated chalk.engine.v1.Key defaulting_features = 1;
   */
  defaultingFeatures: Key[] = [];

  constructor(data?: PartialMessage<DefaultInjector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.engine.v1.DefaultInjector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "defaulting_features", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DefaultInjector {
    return new DefaultInjector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DefaultInjector {
    return new DefaultInjector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DefaultInjector {
    return new DefaultInjector().fromJsonString(jsonString, options);
  }

  static equals(a: DefaultInjector | PlainMessage<DefaultInjector> | undefined, b: DefaultInjector | PlainMessage<DefaultInjector> | undefined): boolean {
    return proto3.util.equals(DefaultInjector, a, b);
  }
}

