// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/expression/v1/expression.proto (package chalk.expression.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ArrowType, ScalarValue } from "../../arrow/v1/arrow_pb";

/**
 * @generated from enum chalk.expression.v1.ScalarFunction
 */
export enum ScalarFunction {
  /**
   * @generated from enum value: SCALAR_FUNCTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ABS = 1;
   */
  ABS = 1,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ACOS = 2;
   */
  ACOS = 2,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ASIN = 3;
   */
  ASIN = 3,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ATAN = 4;
   */
  ATAN = 4,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ASCII = 5;
   */
  ASCII = 5,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CEIL = 6;
   */
  CEIL = 6,

  /**
   * @generated from enum value: SCALAR_FUNCTION_COS = 7;
   */
  COS = 7,

  /**
   * @generated from enum value: SCALAR_FUNCTION_DIGEST = 8;
   */
  DIGEST = 8,

  /**
   * @generated from enum value: SCALAR_FUNCTION_EXP = 9;
   */
  EXP = 9,

  /**
   * @generated from enum value: SCALAR_FUNCTION_FLOOR = 10;
   */
  FLOOR = 10,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LN = 11;
   */
  LN = 11,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LOG = 12;
   */
  LOG = 12,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LOG10 = 13;
   */
  LOG10 = 13,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LOG2 = 14;
   */
  LOG2 = 14,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ROUND = 15;
   */
  ROUND = 15,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SIGNUM = 16;
   */
  SIGNUM = 16,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SIN = 17;
   */
  SIN = 17,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SQRT = 18;
   */
  SQRT = 18,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TAN = 19;
   */
  TAN = 19,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TRUNC = 20;
   */
  TRUNC = 20,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY = 21;
   */
  ARRAY = 21,

  /**
   * @generated from enum value: SCALAR_FUNCTION_REGEXP_MATCH = 22;
   */
  REGEXP_MATCH = 22,

  /**
   * @generated from enum value: SCALAR_FUNCTION_BIT_LENGTH = 23;
   */
  BIT_LENGTH = 23,

  /**
   * @generated from enum value: SCALAR_FUNCTION_BTRIM = 24;
   */
  BTRIM = 24,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CHARACTER_LENGTH = 25;
   */
  CHARACTER_LENGTH = 25,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CHR = 26;
   */
  CHR = 26,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CONCAT = 27;
   */
  CONCAT = 27,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR = 28;
   */
  CONCAT_WITH_SEPARATOR = 28,

  /**
   * @generated from enum value: SCALAR_FUNCTION_DATE_PART = 29;
   */
  DATE_PART = 29,

  /**
   * @generated from enum value: SCALAR_FUNCTION_DATE_TRUNC = 30;
   */
  DATE_TRUNC = 30,

  /**
   * @generated from enum value: SCALAR_FUNCTION_INIT_CAP = 31;
   */
  INIT_CAP = 31,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LEFT = 32;
   */
  LEFT = 32,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LPAD = 33;
   */
  LPAD = 33,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LOWER = 34;
   */
  LOWER = 34,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LTRIM = 35;
   */
  LTRIM = 35,

  /**
   * @generated from enum value: SCALAR_FUNCTION_MD5 = 36;
   */
  MD5 = 36,

  /**
   * @generated from enum value: SCALAR_FUNCTION_NULL_IF = 37;
   */
  NULL_IF = 37,

  /**
   * @generated from enum value: SCALAR_FUNCTION_OCTET_LENGTH = 38;
   */
  OCTET_LENGTH = 38,

  /**
   * @generated from enum value: SCALAR_FUNCTION_RANDOM = 39;
   */
  RANDOM = 39,

  /**
   * @generated from enum value: SCALAR_FUNCTION_REGEXP_REPLACE = 40;
   */
  REGEXP_REPLACE = 40,

  /**
   * @generated from enum value: SCALAR_FUNCTION_REPEAT = 41;
   */
  REPEAT = 41,

  /**
   * @generated from enum value: SCALAR_FUNCTION_REPLACE = 42;
   */
  REPLACE = 42,

  /**
   * @generated from enum value: SCALAR_FUNCTION_REVERSE = 43;
   */
  REVERSE = 43,

  /**
   * @generated from enum value: SCALAR_FUNCTION_RIGHT = 44;
   */
  RIGHT = 44,

  /**
   * @generated from enum value: SCALAR_FUNCTION_RPAD = 45;
   */
  RPAD = 45,

  /**
   * @generated from enum value: SCALAR_FUNCTION_RTRIM = 46;
   */
  RTRIM = 46,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SHA224 = 47;
   */
  SHA224 = 47,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SHA256 = 48;
   */
  SHA256 = 48,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SHA384 = 49;
   */
  SHA384 = 49,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SHA512 = 50;
   */
  SHA512 = 50,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SPLIT_PART = 51;
   */
  SPLIT_PART = 51,

  /**
   * @generated from enum value: SCALAR_FUNCTION_STARTS_WITH = 52;
   */
  STARTS_WITH = 52,

  /**
   * @generated from enum value: SCALAR_FUNCTION_STRPOS = 53;
   */
  STRPOS = 53,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SUBSTR = 54;
   */
  SUBSTR = 54,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TO_HEX = 55;
   */
  TO_HEX = 55,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TO_TIMESTAMP = 56;
   */
  TO_TIMESTAMP = 56,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS = 57;
   */
  TO_TIMESTAMP_MILLIS = 57,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TO_TIMESTAMP_MICROS = 58;
   */
  TO_TIMESTAMP_MICROS = 58,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS = 59;
   */
  TO_TIMESTAMP_SECONDS = 59,

  /**
   * @generated from enum value: SCALAR_FUNCTION_NOW = 60;
   */
  NOW = 60,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TRANSLATE = 61;
   */
  TRANSLATE = 61,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TRIM = 62;
   */
  TRIM = 62,

  /**
   * @generated from enum value: SCALAR_FUNCTION_UPPER = 63;
   */
  UPPER = 63,

  /**
   * @generated from enum value: SCALAR_FUNCTION_COALESCE = 64;
   */
  COALESCE = 64,

  /**
   * @generated from enum value: SCALAR_FUNCTION_POWER = 65;
   */
  POWER = 65,

  /**
   * @generated from enum value: SCALAR_FUNCTION_STRUCT_FUN = 66;
   */
  STRUCT_FUN = 66,

  /**
   * @generated from enum value: SCALAR_FUNCTION_FROM_UNIXTIME = 67;
   */
  FROM_UNIXTIME = 67,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ATAN2 = 68;
   */
  ATAN2 = 68,

  /**
   * @generated from enum value: SCALAR_FUNCTION_DATE_BIN = 69;
   */
  DATE_BIN = 69,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARROW_TYPEOF = 70;
   */
  ARROW_TYPEOF = 70,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CURRENT_DATE = 71;
   */
  CURRENT_DATE = 71,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CURRENT_TIME = 72;
   */
  CURRENT_TIME = 72,

  /**
   * @generated from enum value: SCALAR_FUNCTION_UUID = 73;
   */
  UUID = 73,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CBRT = 74;
   */
  CBRT = 74,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ACOSH = 75;
   */
  ACOSH = 75,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ASINH = 76;
   */
  ASINH = 76,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ATANH = 77;
   */
  ATANH = 77,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SINH = 78;
   */
  SINH = 78,

  /**
   * @generated from enum value: SCALAR_FUNCTION_COSH = 79;
   */
  COSH = 79,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TANH = 80;
   */
  TANH = 80,

  /**
   * @generated from enum value: SCALAR_FUNCTION_PI = 81;
   */
  PI = 81,

  /**
   * @generated from enum value: SCALAR_FUNCTION_DEGREES = 82;
   */
  DEGREES = 82,

  /**
   * @generated from enum value: SCALAR_FUNCTION_RADIANS = 83;
   */
  RADIANS = 83,

  /**
   * @generated from enum value: SCALAR_FUNCTION_FACTORIAL = 84;
   */
  FACTORIAL = 84,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LCM = 85;
   */
  LCM = 85,

  /**
   * @generated from enum value: SCALAR_FUNCTION_GCD = 86;
   */
  GCD = 86,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_APPEND = 87;
   */
  ARRAY_APPEND = 87,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_CONCAT = 88;
   */
  ARRAY_CONCAT = 88,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_DIMS = 89;
   */
  ARRAY_DIMS = 89,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REPEAT = 90;
   */
  ARRAY_REPEAT = 90,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_LENGTH = 91;
   */
  ARRAY_LENGTH = 91,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_NDIMS = 92;
   */
  ARRAY_NDIMS = 92,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_POSITION = 93;
   */
  ARRAY_POSITION = 93,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_POSITIONS = 94;
   */
  ARRAY_POSITIONS = 94,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_PREPEND = 95;
   */
  ARRAY_PREPEND = 95,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REMOVE = 96;
   */
  ARRAY_REMOVE = 96,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REPLACE = 97;
   */
  ARRAY_REPLACE = 97,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_TO_STRING = 98;
   */
  ARRAY_TO_STRING = 98,

  /**
   * @generated from enum value: SCALAR_FUNCTION_CARDINALITY = 99;
   */
  CARDINALITY = 99,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_ELEMENT = 100;
   */
  ARRAY_ELEMENT = 100,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_SLICE = 101;
   */
  ARRAY_SLICE = 101,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ENCODE = 102;
   */
  ENCODE = 102,

  /**
   * @generated from enum value: SCALAR_FUNCTION_DECODE = 103;
   */
  DECODE = 103,

  /**
   * @generated from enum value: SCALAR_FUNCTION_COT = 104;
   */
  COT = 104,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_HAS = 105;
   */
  ARRAY_HAS = 105,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_HAS_ANY = 106;
   */
  ARRAY_HAS_ANY = 106,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_HAS_ALL = 107;
   */
  ARRAY_HAS_ALL = 107,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REMOVE_N = 108;
   */
  ARRAY_REMOVE_N = 108,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REPLACE_N = 109;
   */
  ARRAY_REPLACE_N = 109,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REMOVE_ALL = 110;
   */
  ARRAY_REMOVE_ALL = 110,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_REPLACE_ALL = 111;
   */
  ARRAY_REPLACE_ALL = 111,

  /**
   * @generated from enum value: SCALAR_FUNCTION_NANVL = 112;
   */
  NANVL = 112,

  /**
   * @generated from enum value: SCALAR_FUNCTION_FLATTEN = 113;
   */
  FLATTEN = 113,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ISNAN = 114;
   */
  ISNAN = 114,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ISZERO = 115;
   */
  ISZERO = 115,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_EMPTY = 116;
   */
  ARRAY_EMPTY = 116,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_POP_BACK = 117;
   */
  ARRAY_POP_BACK = 117,

  /**
   * @generated from enum value: SCALAR_FUNCTION_STRING_TO_ARRAY = 118;
   */
  STRING_TO_ARRAY = 118,

  /**
   * @generated from enum value: SCALAR_FUNCTION_TO_TIMESTAMP_NANOS = 119;
   */
  TO_TIMESTAMP_NANOS = 119,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_INTERSECT = 120;
   */
  ARRAY_INTERSECT = 120,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_UNION = 121;
   */
  ARRAY_UNION = 121,

  /**
   * @generated from enum value: SCALAR_FUNCTION_OVER_LAY = 122;
   */
  OVER_LAY = 122,

  /**
   * @generated from enum value: SCALAR_FUNCTION_RANGE = 123;
   */
  RANGE = 123,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_EXCEPT = 124;
   */
  ARRAY_EXCEPT = 124,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_POP_FRONT = 125;
   */
  ARRAY_POP_FRONT = 125,

  /**
   * @generated from enum value: SCALAR_FUNCTION_LEVENSHTEIN = 126;
   */
  LEVENSHTEIN = 126,

  /**
   * @generated from enum value: SCALAR_FUNCTION_SUBSTR_INDEX = 127;
   */
  SUBSTR_INDEX = 127,

  /**
   * @generated from enum value: SCALAR_FUNCTION_FIND_IN_SET = 128;
   */
  FIND_IN_SET = 128,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_SORT = 129;
   */
  ARRAY_SORT = 129,

  /**
   * @generated from enum value: SCALAR_FUNCTION_ARRAY_DISTINCT = 130;
   */
  ARRAY_DISTINCT = 130,
}
// Retrieve enum metadata with: proto3.getEnumType(ScalarFunction)
proto3.util.setEnumType(ScalarFunction, "chalk.expression.v1.ScalarFunction", [
  { no: 0, name: "SCALAR_FUNCTION_UNSPECIFIED" },
  { no: 1, name: "SCALAR_FUNCTION_ABS" },
  { no: 2, name: "SCALAR_FUNCTION_ACOS" },
  { no: 3, name: "SCALAR_FUNCTION_ASIN" },
  { no: 4, name: "SCALAR_FUNCTION_ATAN" },
  { no: 5, name: "SCALAR_FUNCTION_ASCII" },
  { no: 6, name: "SCALAR_FUNCTION_CEIL" },
  { no: 7, name: "SCALAR_FUNCTION_COS" },
  { no: 8, name: "SCALAR_FUNCTION_DIGEST" },
  { no: 9, name: "SCALAR_FUNCTION_EXP" },
  { no: 10, name: "SCALAR_FUNCTION_FLOOR" },
  { no: 11, name: "SCALAR_FUNCTION_LN" },
  { no: 12, name: "SCALAR_FUNCTION_LOG" },
  { no: 13, name: "SCALAR_FUNCTION_LOG10" },
  { no: 14, name: "SCALAR_FUNCTION_LOG2" },
  { no: 15, name: "SCALAR_FUNCTION_ROUND" },
  { no: 16, name: "SCALAR_FUNCTION_SIGNUM" },
  { no: 17, name: "SCALAR_FUNCTION_SIN" },
  { no: 18, name: "SCALAR_FUNCTION_SQRT" },
  { no: 19, name: "SCALAR_FUNCTION_TAN" },
  { no: 20, name: "SCALAR_FUNCTION_TRUNC" },
  { no: 21, name: "SCALAR_FUNCTION_ARRAY" },
  { no: 22, name: "SCALAR_FUNCTION_REGEXP_MATCH" },
  { no: 23, name: "SCALAR_FUNCTION_BIT_LENGTH" },
  { no: 24, name: "SCALAR_FUNCTION_BTRIM" },
  { no: 25, name: "SCALAR_FUNCTION_CHARACTER_LENGTH" },
  { no: 26, name: "SCALAR_FUNCTION_CHR" },
  { no: 27, name: "SCALAR_FUNCTION_CONCAT" },
  { no: 28, name: "SCALAR_FUNCTION_CONCAT_WITH_SEPARATOR" },
  { no: 29, name: "SCALAR_FUNCTION_DATE_PART" },
  { no: 30, name: "SCALAR_FUNCTION_DATE_TRUNC" },
  { no: 31, name: "SCALAR_FUNCTION_INIT_CAP" },
  { no: 32, name: "SCALAR_FUNCTION_LEFT" },
  { no: 33, name: "SCALAR_FUNCTION_LPAD" },
  { no: 34, name: "SCALAR_FUNCTION_LOWER" },
  { no: 35, name: "SCALAR_FUNCTION_LTRIM" },
  { no: 36, name: "SCALAR_FUNCTION_MD5" },
  { no: 37, name: "SCALAR_FUNCTION_NULL_IF" },
  { no: 38, name: "SCALAR_FUNCTION_OCTET_LENGTH" },
  { no: 39, name: "SCALAR_FUNCTION_RANDOM" },
  { no: 40, name: "SCALAR_FUNCTION_REGEXP_REPLACE" },
  { no: 41, name: "SCALAR_FUNCTION_REPEAT" },
  { no: 42, name: "SCALAR_FUNCTION_REPLACE" },
  { no: 43, name: "SCALAR_FUNCTION_REVERSE" },
  { no: 44, name: "SCALAR_FUNCTION_RIGHT" },
  { no: 45, name: "SCALAR_FUNCTION_RPAD" },
  { no: 46, name: "SCALAR_FUNCTION_RTRIM" },
  { no: 47, name: "SCALAR_FUNCTION_SHA224" },
  { no: 48, name: "SCALAR_FUNCTION_SHA256" },
  { no: 49, name: "SCALAR_FUNCTION_SHA384" },
  { no: 50, name: "SCALAR_FUNCTION_SHA512" },
  { no: 51, name: "SCALAR_FUNCTION_SPLIT_PART" },
  { no: 52, name: "SCALAR_FUNCTION_STARTS_WITH" },
  { no: 53, name: "SCALAR_FUNCTION_STRPOS" },
  { no: 54, name: "SCALAR_FUNCTION_SUBSTR" },
  { no: 55, name: "SCALAR_FUNCTION_TO_HEX" },
  { no: 56, name: "SCALAR_FUNCTION_TO_TIMESTAMP" },
  { no: 57, name: "SCALAR_FUNCTION_TO_TIMESTAMP_MILLIS" },
  { no: 58, name: "SCALAR_FUNCTION_TO_TIMESTAMP_MICROS" },
  { no: 59, name: "SCALAR_FUNCTION_TO_TIMESTAMP_SECONDS" },
  { no: 60, name: "SCALAR_FUNCTION_NOW" },
  { no: 61, name: "SCALAR_FUNCTION_TRANSLATE" },
  { no: 62, name: "SCALAR_FUNCTION_TRIM" },
  { no: 63, name: "SCALAR_FUNCTION_UPPER" },
  { no: 64, name: "SCALAR_FUNCTION_COALESCE" },
  { no: 65, name: "SCALAR_FUNCTION_POWER" },
  { no: 66, name: "SCALAR_FUNCTION_STRUCT_FUN" },
  { no: 67, name: "SCALAR_FUNCTION_FROM_UNIXTIME" },
  { no: 68, name: "SCALAR_FUNCTION_ATAN2" },
  { no: 69, name: "SCALAR_FUNCTION_DATE_BIN" },
  { no: 70, name: "SCALAR_FUNCTION_ARROW_TYPEOF" },
  { no: 71, name: "SCALAR_FUNCTION_CURRENT_DATE" },
  { no: 72, name: "SCALAR_FUNCTION_CURRENT_TIME" },
  { no: 73, name: "SCALAR_FUNCTION_UUID" },
  { no: 74, name: "SCALAR_FUNCTION_CBRT" },
  { no: 75, name: "SCALAR_FUNCTION_ACOSH" },
  { no: 76, name: "SCALAR_FUNCTION_ASINH" },
  { no: 77, name: "SCALAR_FUNCTION_ATANH" },
  { no: 78, name: "SCALAR_FUNCTION_SINH" },
  { no: 79, name: "SCALAR_FUNCTION_COSH" },
  { no: 80, name: "SCALAR_FUNCTION_TANH" },
  { no: 81, name: "SCALAR_FUNCTION_PI" },
  { no: 82, name: "SCALAR_FUNCTION_DEGREES" },
  { no: 83, name: "SCALAR_FUNCTION_RADIANS" },
  { no: 84, name: "SCALAR_FUNCTION_FACTORIAL" },
  { no: 85, name: "SCALAR_FUNCTION_LCM" },
  { no: 86, name: "SCALAR_FUNCTION_GCD" },
  { no: 87, name: "SCALAR_FUNCTION_ARRAY_APPEND" },
  { no: 88, name: "SCALAR_FUNCTION_ARRAY_CONCAT" },
  { no: 89, name: "SCALAR_FUNCTION_ARRAY_DIMS" },
  { no: 90, name: "SCALAR_FUNCTION_ARRAY_REPEAT" },
  { no: 91, name: "SCALAR_FUNCTION_ARRAY_LENGTH" },
  { no: 92, name: "SCALAR_FUNCTION_ARRAY_NDIMS" },
  { no: 93, name: "SCALAR_FUNCTION_ARRAY_POSITION" },
  { no: 94, name: "SCALAR_FUNCTION_ARRAY_POSITIONS" },
  { no: 95, name: "SCALAR_FUNCTION_ARRAY_PREPEND" },
  { no: 96, name: "SCALAR_FUNCTION_ARRAY_REMOVE" },
  { no: 97, name: "SCALAR_FUNCTION_ARRAY_REPLACE" },
  { no: 98, name: "SCALAR_FUNCTION_ARRAY_TO_STRING" },
  { no: 99, name: "SCALAR_FUNCTION_CARDINALITY" },
  { no: 100, name: "SCALAR_FUNCTION_ARRAY_ELEMENT" },
  { no: 101, name: "SCALAR_FUNCTION_ARRAY_SLICE" },
  { no: 102, name: "SCALAR_FUNCTION_ENCODE" },
  { no: 103, name: "SCALAR_FUNCTION_DECODE" },
  { no: 104, name: "SCALAR_FUNCTION_COT" },
  { no: 105, name: "SCALAR_FUNCTION_ARRAY_HAS" },
  { no: 106, name: "SCALAR_FUNCTION_ARRAY_HAS_ANY" },
  { no: 107, name: "SCALAR_FUNCTION_ARRAY_HAS_ALL" },
  { no: 108, name: "SCALAR_FUNCTION_ARRAY_REMOVE_N" },
  { no: 109, name: "SCALAR_FUNCTION_ARRAY_REPLACE_N" },
  { no: 110, name: "SCALAR_FUNCTION_ARRAY_REMOVE_ALL" },
  { no: 111, name: "SCALAR_FUNCTION_ARRAY_REPLACE_ALL" },
  { no: 112, name: "SCALAR_FUNCTION_NANVL" },
  { no: 113, name: "SCALAR_FUNCTION_FLATTEN" },
  { no: 114, name: "SCALAR_FUNCTION_ISNAN" },
  { no: 115, name: "SCALAR_FUNCTION_ISZERO" },
  { no: 116, name: "SCALAR_FUNCTION_ARRAY_EMPTY" },
  { no: 117, name: "SCALAR_FUNCTION_ARRAY_POP_BACK" },
  { no: 118, name: "SCALAR_FUNCTION_STRING_TO_ARRAY" },
  { no: 119, name: "SCALAR_FUNCTION_TO_TIMESTAMP_NANOS" },
  { no: 120, name: "SCALAR_FUNCTION_ARRAY_INTERSECT" },
  { no: 121, name: "SCALAR_FUNCTION_ARRAY_UNION" },
  { no: 122, name: "SCALAR_FUNCTION_OVER_LAY" },
  { no: 123, name: "SCALAR_FUNCTION_RANGE" },
  { no: 124, name: "SCALAR_FUNCTION_ARRAY_EXCEPT" },
  { no: 125, name: "SCALAR_FUNCTION_ARRAY_POP_FRONT" },
  { no: 126, name: "SCALAR_FUNCTION_LEVENSHTEIN" },
  { no: 127, name: "SCALAR_FUNCTION_SUBSTR_INDEX" },
  { no: 128, name: "SCALAR_FUNCTION_FIND_IN_SET" },
  { no: 129, name: "SCALAR_FUNCTION_ARRAY_SORT" },
  { no: 130, name: "SCALAR_FUNCTION_ARRAY_DISTINCT" },
]);

/**
 * @generated from enum chalk.expression.v1.AggregateFunction
 */
export enum AggregateFunction {
  /**
   * @generated from enum value: AGGREGATE_FUNCTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_MIN = 1;
   */
  MIN = 1,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_MAX = 2;
   */
  MAX = 2,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_SUM = 3;
   */
  SUM = 3,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_AVG = 4;
   */
  AVG = 4,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_COUNT = 5;
   */
  COUNT = 5,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_APPROX_DISTINCT = 6;
   */
  APPROX_DISTINCT = 6,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_ARRAY = 7;
   */
  ARRAY = 7,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_VARIANCE = 8;
   */
  VARIANCE = 8,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_VARIANCE_POP = 9;
   */
  VARIANCE_POP = 9,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_COVARIANCE = 10;
   */
  COVARIANCE = 10,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_COVARIANCE_POP = 11;
   */
  COVARIANCE_POP = 11,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_STDDEV = 12;
   */
  STDDEV = 12,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_STDDEV_POP = 13;
   */
  STDDEV_POP = 13,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_CORRELATION = 14;
   */
  CORRELATION = 14,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT = 15;
   */
  APPROX_PERCENTILE_CONT = 15,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_APPROX_MEDIAN = 16;
   */
  APPROX_MEDIAN = 16,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT = 17;
   */
  APPROX_PERCENTILE_CONT_WITH_WEIGHT = 17,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_GROUPING = 18;
   */
  GROUPING = 18,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_MEDIAN = 19;
   */
  MEDIAN = 19,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_BIT_AND = 20;
   */
  BIT_AND = 20,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_BIT_OR = 21;
   */
  BIT_OR = 21,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_BIT_XOR = 22;
   */
  BIT_XOR = 22,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_BOOL_AND = 23;
   */
  BOOL_AND = 23,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_BOOL_OR = 24;
   */
  BOOL_OR = 24,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_FIRST_VALUE = 25;
   */
  FIRST_VALUE = 25,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_LAST_VALUE = 26;
   */
  LAST_VALUE = 26,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_SLOPE = 27;
   */
  REGR_SLOPE = 27,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_INTERCEPT = 28;
   */
  REGR_INTERCEPT = 28,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_COUNT = 29;
   */
  REGR_COUNT = 29,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_R2 = 30;
   */
  REGR_R2 = 30,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_AVGX = 31;
   */
  REGR_AVGX = 31,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_AVGY = 32;
   */
  REGR_AVGY = 32,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_SXX = 33;
   */
  REGR_SXX = 33,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_SYY = 34;
   */
  REGR_SYY = 34,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_REGR_SXY = 35;
   */
  REGR_SXY = 35,

  /**
   * @generated from enum value: AGGREGATE_FUNCTION_STRING = 36;
   */
  STRING = 36,
}
// Retrieve enum metadata with: proto3.getEnumType(AggregateFunction)
proto3.util.setEnumType(AggregateFunction, "chalk.expression.v1.AggregateFunction", [
  { no: 0, name: "AGGREGATE_FUNCTION_UNSPECIFIED" },
  { no: 1, name: "AGGREGATE_FUNCTION_MIN" },
  { no: 2, name: "AGGREGATE_FUNCTION_MAX" },
  { no: 3, name: "AGGREGATE_FUNCTION_SUM" },
  { no: 4, name: "AGGREGATE_FUNCTION_AVG" },
  { no: 5, name: "AGGREGATE_FUNCTION_COUNT" },
  { no: 6, name: "AGGREGATE_FUNCTION_APPROX_DISTINCT" },
  { no: 7, name: "AGGREGATE_FUNCTION_ARRAY" },
  { no: 8, name: "AGGREGATE_FUNCTION_VARIANCE" },
  { no: 9, name: "AGGREGATE_FUNCTION_VARIANCE_POP" },
  { no: 10, name: "AGGREGATE_FUNCTION_COVARIANCE" },
  { no: 11, name: "AGGREGATE_FUNCTION_COVARIANCE_POP" },
  { no: 12, name: "AGGREGATE_FUNCTION_STDDEV" },
  { no: 13, name: "AGGREGATE_FUNCTION_STDDEV_POP" },
  { no: 14, name: "AGGREGATE_FUNCTION_CORRELATION" },
  { no: 15, name: "AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT" },
  { no: 16, name: "AGGREGATE_FUNCTION_APPROX_MEDIAN" },
  { no: 17, name: "AGGREGATE_FUNCTION_APPROX_PERCENTILE_CONT_WITH_WEIGHT" },
  { no: 18, name: "AGGREGATE_FUNCTION_GROUPING" },
  { no: 19, name: "AGGREGATE_FUNCTION_MEDIAN" },
  { no: 20, name: "AGGREGATE_FUNCTION_BIT_AND" },
  { no: 21, name: "AGGREGATE_FUNCTION_BIT_OR" },
  { no: 22, name: "AGGREGATE_FUNCTION_BIT_XOR" },
  { no: 23, name: "AGGREGATE_FUNCTION_BOOL_AND" },
  { no: 24, name: "AGGREGATE_FUNCTION_BOOL_OR" },
  { no: 25, name: "AGGREGATE_FUNCTION_FIRST_VALUE" },
  { no: 26, name: "AGGREGATE_FUNCTION_LAST_VALUE" },
  { no: 27, name: "AGGREGATE_FUNCTION_REGR_SLOPE" },
  { no: 28, name: "AGGREGATE_FUNCTION_REGR_INTERCEPT" },
  { no: 29, name: "AGGREGATE_FUNCTION_REGR_COUNT" },
  { no: 30, name: "AGGREGATE_FUNCTION_REGR_R2" },
  { no: 31, name: "AGGREGATE_FUNCTION_REGR_AVGX" },
  { no: 32, name: "AGGREGATE_FUNCTION_REGR_AVGY" },
  { no: 33, name: "AGGREGATE_FUNCTION_REGR_SXX" },
  { no: 34, name: "AGGREGATE_FUNCTION_REGR_SYY" },
  { no: 35, name: "AGGREGATE_FUNCTION_REGR_SXY" },
  { no: 36, name: "AGGREGATE_FUNCTION_STRING" },
]);

/**
 * @generated from enum chalk.expression.v1.BuiltInWindowFunction
 */
export enum BuiltInWindowFunction {
  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER = 1;
   */
  ROW_NUMBER = 1,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_RANK = 2;
   */
  RANK = 2,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_DENSE_RANK = 3;
   */
  DENSE_RANK = 3,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK = 4;
   */
  PERCENT_RANK = 4,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_CUME_DIST = 5;
   */
  CUME_DIST = 5,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_NTILE = 6;
   */
  NTILE = 6,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_LAG = 7;
   */
  LAG = 7,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_LEAD = 8;
   */
  LEAD = 8,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE = 9;
   */
  FIRST_VALUE = 9,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_LAST_VALUE = 10;
   */
  LAST_VALUE = 10,

  /**
   * @generated from enum value: BUILT_IN_WINDOW_FUNCTION_NTH_VALUE = 11;
   */
  NTH_VALUE = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(BuiltInWindowFunction)
proto3.util.setEnumType(BuiltInWindowFunction, "chalk.expression.v1.BuiltInWindowFunction", [
  { no: 0, name: "BUILT_IN_WINDOW_FUNCTION_UNSPECIFIED" },
  { no: 1, name: "BUILT_IN_WINDOW_FUNCTION_ROW_NUMBER" },
  { no: 2, name: "BUILT_IN_WINDOW_FUNCTION_RANK" },
  { no: 3, name: "BUILT_IN_WINDOW_FUNCTION_DENSE_RANK" },
  { no: 4, name: "BUILT_IN_WINDOW_FUNCTION_PERCENT_RANK" },
  { no: 5, name: "BUILT_IN_WINDOW_FUNCTION_CUME_DIST" },
  { no: 6, name: "BUILT_IN_WINDOW_FUNCTION_NTILE" },
  { no: 7, name: "BUILT_IN_WINDOW_FUNCTION_LAG" },
  { no: 8, name: "BUILT_IN_WINDOW_FUNCTION_LEAD" },
  { no: 9, name: "BUILT_IN_WINDOW_FUNCTION_FIRST_VALUE" },
  { no: 10, name: "BUILT_IN_WINDOW_FUNCTION_LAST_VALUE" },
  { no: 11, name: "BUILT_IN_WINDOW_FUNCTION_NTH_VALUE" },
]);

/**
 * @generated from enum chalk.expression.v1.WindowFrameUnits
 */
export enum WindowFrameUnits {
  /**
   * @generated from enum value: WINDOW_FRAME_UNITS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: WINDOW_FRAME_UNITS_ROWS = 1;
   */
  ROWS = 1,

  /**
   * @generated from enum value: WINDOW_FRAME_UNITS_RANGE = 2;
   */
  RANGE = 2,

  /**
   * @generated from enum value: WINDOW_FRAME_UNITS_GROUPS = 3;
   */
  GROUPS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(WindowFrameUnits)
proto3.util.setEnumType(WindowFrameUnits, "chalk.expression.v1.WindowFrameUnits", [
  { no: 0, name: "WINDOW_FRAME_UNITS_UNSPECIFIED" },
  { no: 1, name: "WINDOW_FRAME_UNITS_ROWS" },
  { no: 2, name: "WINDOW_FRAME_UNITS_RANGE" },
  { no: 3, name: "WINDOW_FRAME_UNITS_GROUPS" },
]);

/**
 * @generated from enum chalk.expression.v1.WindowFrameBoundType
 */
export enum WindowFrameBoundType {
  /**
   * @generated from enum value: WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW = 1;
   */
  CURRENT_ROW = 1,

  /**
   * @generated from enum value: WINDOW_FRAME_BOUND_TYPE_PRECEDING = 2;
   */
  PRECEDING = 2,

  /**
   * @generated from enum value: WINDOW_FRAME_BOUND_TYPE_FOLLOWING = 3;
   */
  FOLLOWING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(WindowFrameBoundType)
proto3.util.setEnumType(WindowFrameBoundType, "chalk.expression.v1.WindowFrameBoundType", [
  { no: 0, name: "WINDOW_FRAME_BOUND_TYPE_UNSPECIFIED" },
  { no: 1, name: "WINDOW_FRAME_BOUND_TYPE_CURRENT_ROW" },
  { no: 2, name: "WINDOW_FRAME_BOUND_TYPE_PRECEDING" },
  { no: 3, name: "WINDOW_FRAME_BOUND_TYPE_FOLLOWING" },
]);

/**
 * @generated from message chalk.expression.v1.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * A field-access expression, like `arr.length`.
 *
 * @generated from message chalk.expression.v1.ExprGetAttribute
 */
export class ExprGetAttribute extends Message<ExprGetAttribute> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode parent = 1;
   */
  parent?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.Identifier attribute = 2;
   */
  attribute?: Identifier;

  constructor(data?: PartialMessage<ExprGetAttribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ExprGetAttribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "message", T: LogicalExprNode },
    { no: 2, name: "attribute", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExprGetAttribute {
    return new ExprGetAttribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExprGetAttribute {
    return new ExprGetAttribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExprGetAttribute {
    return new ExprGetAttribute().fromJsonString(jsonString, options);
  }

  static equals(a: ExprGetAttribute | PlainMessage<ExprGetAttribute> | undefined, b: ExprGetAttribute | PlainMessage<ExprGetAttribute> | undefined): boolean {
    return proto3.util.equals(ExprGetAttribute, a, b);
  }
}

/**
 * A key-lookup expression, like `hash[name]` or `matrix[r, c]`.
 *
 * @generated from message chalk.expression.v1.ExprGetSubscript
 */
export class ExprGetSubscript extends Message<ExprGetSubscript> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode parent = 1;
   */
  parent?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode subscript = 2;
   */
  subscript: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<ExprGetSubscript>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ExprGetSubscript";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "message", T: LogicalExprNode },
    { no: 2, name: "subscript", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExprGetSubscript {
    return new ExprGetSubscript().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExprGetSubscript {
    return new ExprGetSubscript().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExprGetSubscript {
    return new ExprGetSubscript().fromJsonString(jsonString, options);
  }

  static equals(a: ExprGetSubscript | PlainMessage<ExprGetSubscript> | undefined, b: ExprGetSubscript | PlainMessage<ExprGetSubscript> | undefined): boolean {
    return proto3.util.equals(ExprGetSubscript, a, b);
  }
}

/**
 * A function call, like `abs(x)` or `arr.indexof(6)` or `a + b`.
 *
 * In function calls, like `abs(x)`, the `func` will be an identifier with the
 * specified name.
 *
 * In method calls, like `arr.indexof(6)`, the `func` will be a get-attribute
 * expression.
 *
 * In operator expressions, the `func` will be an identifier with the operator
 * as its name e.g. `"+"`.
 *
 * @generated from message chalk.expression.v1.ExprCall
 */
export class ExprCall extends Message<ExprCall> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode func = 1;
   */
  func?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode args = 2;
   */
  args: LogicalExprNode[] = [];

  /**
   * @generated from field: map<string, chalk.expression.v1.LogicalExprNode> kwargs = 3;
   */
  kwargs: { [key: string]: LogicalExprNode } = {};

  constructor(data?: PartialMessage<ExprCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ExprCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "func", kind: "message", T: LogicalExprNode },
    { no: 2, name: "args", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 3, name: "kwargs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LogicalExprNode} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExprCall {
    return new ExprCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExprCall {
    return new ExprCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExprCall {
    return new ExprCall().fromJsonString(jsonString, options);
  }

  static equals(a: ExprCall | PlainMessage<ExprCall> | undefined, b: ExprCall | PlainMessage<ExprCall> | undefined): boolean {
    return proto3.util.equals(ExprCall, a, b);
  }
}

/**
 * A literal expression.
 *
 * @generated from message chalk.expression.v1.ExprLiteral
 */
export class ExprLiteral extends Message<ExprLiteral> {
  /**
   * @generated from field: chalk.arrow.v1.ScalarValue value = 1;
   */
  value?: ScalarValue;

  /**
   * All Python literal values are encoded as arrow scalar values.
   * - If this bool is `False`, then the decoded value was originally a plain
   * Python value.
   * - If this bool is `True`, then the decoded value should be a
   * `pyarrow.Scalar` value.
   *
   * @generated from field: bool is_arrow_scalar_object = 2;
   */
  isArrowScalarObject = false;

  constructor(data?: PartialMessage<ExprLiteral>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ExprLiteral";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: ScalarValue },
    { no: 2, name: "is_arrow_scalar_object", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExprLiteral {
    return new ExprLiteral().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExprLiteral {
    return new ExprLiteral().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExprLiteral {
    return new ExprLiteral().fromJsonString(jsonString, options);
  }

  static equals(a: ExprLiteral | PlainMessage<ExprLiteral> | undefined, b: ExprLiteral | PlainMessage<ExprLiteral> | undefined): boolean {
    return proto3.util.equals(ExprLiteral, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.LogicalExprNode
 */
export class LogicalExprNode extends Message<LogicalExprNode> {
  /**
   * Each expression has a form, which is one of the following.
   *
   * These forms are deliberately purely syntactic - additional semantic
   * information, like types, are dependent on the feature graph, which may
   * therefore be out-of-date when decoding an expression message.
   *
   * Consumers must always perform additional parsing and validation, so
   * semantic information should not be stored in the proto message itself.
   *
   * @generated from oneof chalk.expression.v1.LogicalExprNode.expr_form
   */
  exprForm: {
    /**
     * @generated from field: chalk.expression.v1.Identifier identifier = 35;
     */
    value: Identifier;
    case: "identifier";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ExprGetAttribute get_attribute = 36;
     */
    value: ExprGetAttribute;
    case: "getAttribute";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ExprGetSubscript get_subscript = 37;
     */
    value: ExprGetSubscript;
    case: "getSubscript";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ExprCall call = 38;
     */
    value: ExprCall;
    case: "call";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ExprLiteral literal_value = 39;
     */
    value: ExprLiteral;
    case: "literalValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The memory ID of this node. Nodes with equal id share are *identical*, sharing any nondeterminism and mutations.
   *
   * @generated from field: string expr_id = 40;
   */
  exprId = "";

  /**
   * All of these expression forms are deprecated.
   * A simpler syntactic representation is used now.
   *
   * @generated from oneof chalk.expression.v1.LogicalExprNode.expr_type
   */
  exprType: {
    /**
     * column references
     *
     * @generated from field: chalk.expression.v1.Column column = 1 [deprecated = true];
     * @deprecated
     */
    value: Column;
    case: "column";
  } | {
    /**
     * alias
     *
     * @generated from field: chalk.expression.v1.AliasNode alias = 2 [deprecated = true];
     * @deprecated
     */
    value: AliasNode;
    case: "alias";
  } | {
    /**
     * @generated from field: chalk.arrow.v1.ScalarValue literal = 3 [deprecated = true];
     * @deprecated
     */
    value: ScalarValue;
    case: "literal";
  } | {
    /**
     * binary expressions
     *
     * @generated from field: chalk.expression.v1.BinaryExprNode binary_expr = 4 [deprecated = true];
     * @deprecated
     */
    value: BinaryExprNode;
    case: "binaryExpr";
  } | {
    /**
     * aggregate expressions
     *
     * @generated from field: chalk.expression.v1.AggregateExprNode aggregate_expr = 5 [deprecated = true];
     * @deprecated
     */
    value: AggregateExprNode;
    case: "aggregateExpr";
  } | {
    /**
     * null checks
     *
     * @generated from field: chalk.expression.v1.IsNull is_null_expr = 6 [deprecated = true];
     * @deprecated
     */
    value: IsNull;
    case: "isNullExpr";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsNotNull is_not_null_expr = 7 [deprecated = true];
     * @deprecated
     */
    value: IsNotNull;
    case: "isNotNullExpr";
  } | {
    /**
     * @generated from field: chalk.expression.v1.Not not_expr = 8 [deprecated = true];
     * @deprecated
     */
    value: Not;
    case: "notExpr";
  } | {
    /**
     * @generated from field: chalk.expression.v1.BetweenNode between = 9 [deprecated = true];
     * @deprecated
     */
    value: BetweenNode;
    case: "between";
  } | {
    /**
     * @generated from field: chalk.expression.v1.CaseNode case = 10 [deprecated = true];
     * @deprecated
     */
    value: CaseNode;
    case: "case";
  } | {
    /**
     * @generated from field: chalk.expression.v1.CastNode cast = 11 [deprecated = true];
     * @deprecated
     */
    value: CastNode;
    case: "cast";
  } | {
    /**
     * @generated from field: chalk.expression.v1.SortExprNode sort = 12 [deprecated = true];
     * @deprecated
     */
    value: SortExprNode;
    case: "sort";
  } | {
    /**
     * @generated from field: chalk.expression.v1.NegativeNode negative = 13 [deprecated = true];
     * @deprecated
     */
    value: NegativeNode;
    case: "negative";
  } | {
    /**
     * @generated from field: chalk.expression.v1.InListNode in_list = 14 [deprecated = true];
     * @deprecated
     */
    value: InListNode;
    case: "inList";
  } | {
    /**
     * @generated from field: chalk.expression.v1.Wildcard wildcard = 15 [deprecated = true];
     * @deprecated
     */
    value: Wildcard;
    case: "wildcard";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ScalarFunctionNode scalar_function = 16 [deprecated = true];
     * @deprecated
     */
    value: ScalarFunctionNode;
    case: "scalarFunction";
  } | {
    /**
     * @generated from field: chalk.expression.v1.TryCastNode try_cast = 17 [deprecated = true];
     * @deprecated
     */
    value: TryCastNode;
    case: "tryCast";
  } | {
    /**
     * window expressions
     *
     * @generated from field: chalk.expression.v1.WindowExprNode window_expr = 18 [deprecated = true];
     * @deprecated
     */
    value: WindowExprNode;
    case: "windowExpr";
  } | {
    /**
     * AggregateUDF expressions
     *
     * @generated from field: chalk.expression.v1.AggregateUDFExprNode aggregate_udf_expr = 19 [deprecated = true];
     * @deprecated
     */
    value: AggregateUDFExprNode;
    case: "aggregateUdfExpr";
  } | {
    /**
     * Scalar UDF expressions
     *
     * @generated from field: chalk.expression.v1.ScalarUDFExprNode scalar_udf_expr = 20 [deprecated = true];
     * @deprecated
     */
    value: ScalarUDFExprNode;
    case: "scalarUdfExpr";
  } | {
    /**
     * @generated from field: chalk.expression.v1.GetIndexedField get_indexed_field = 21 [deprecated = true];
     * @deprecated
     */
    value: GetIndexedField;
    case: "getIndexedField";
  } | {
    /**
     * @generated from field: chalk.expression.v1.GroupingSetNode grouping_set = 22 [deprecated = true];
     * @deprecated
     */
    value: GroupingSetNode;
    case: "groupingSet";
  } | {
    /**
     * @generated from field: chalk.expression.v1.CubeNode cube = 23 [deprecated = true];
     * @deprecated
     */
    value: CubeNode;
    case: "cube";
  } | {
    /**
     * @generated from field: chalk.expression.v1.RollupNode rollup = 24 [deprecated = true];
     * @deprecated
     */
    value: RollupNode;
    case: "rollup";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsTrue is_true = 25 [deprecated = true];
     * @deprecated
     */
    value: IsTrue;
    case: "isTrue";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsFalse is_false = 26 [deprecated = true];
     * @deprecated
     */
    value: IsFalse;
    case: "isFalse";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsUnknown is_unknown = 27 [deprecated = true];
     * @deprecated
     */
    value: IsUnknown;
    case: "isUnknown";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsNotTrue is_not_true = 28 [deprecated = true];
     * @deprecated
     */
    value: IsNotTrue;
    case: "isNotTrue";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsNotFalse is_not_false = 29 [deprecated = true];
     * @deprecated
     */
    value: IsNotFalse;
    case: "isNotFalse";
  } | {
    /**
     * @generated from field: chalk.expression.v1.IsNotUnknown is_not_unknown = 30 [deprecated = true];
     * @deprecated
     */
    value: IsNotUnknown;
    case: "isNotUnknown";
  } | {
    /**
     * @generated from field: chalk.expression.v1.LikeNode like = 31 [deprecated = true];
     * @deprecated
     */
    value: LikeNode;
    case: "like";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ILikeNode ilike = 32 [deprecated = true];
     * @deprecated
     */
    value: ILikeNode;
    case: "ilike";
  } | {
    /**
     * @generated from field: chalk.expression.v1.SimilarToNode similar_to = 33 [deprecated = true];
     * @deprecated
     */
    value: SimilarToNode;
    case: "similarTo";
  } | {
    /**
     * @generated from field: chalk.expression.v1.PlaceholderNode placeholder = 34 [deprecated = true];
     * @deprecated
     */
    value: PlaceholderNode;
    case: "placeholder";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LogicalExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.LogicalExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 35, name: "identifier", kind: "message", T: Identifier, oneof: "expr_form" },
    { no: 36, name: "get_attribute", kind: "message", T: ExprGetAttribute, oneof: "expr_form" },
    { no: 37, name: "get_subscript", kind: "message", T: ExprGetSubscript, oneof: "expr_form" },
    { no: 38, name: "call", kind: "message", T: ExprCall, oneof: "expr_form" },
    { no: 39, name: "literal_value", kind: "message", T: ExprLiteral, oneof: "expr_form" },
    { no: 40, name: "expr_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "column", kind: "message", T: Column, oneof: "expr_type" },
    { no: 2, name: "alias", kind: "message", T: AliasNode, oneof: "expr_type" },
    { no: 3, name: "literal", kind: "message", T: ScalarValue, oneof: "expr_type" },
    { no: 4, name: "binary_expr", kind: "message", T: BinaryExprNode, oneof: "expr_type" },
    { no: 5, name: "aggregate_expr", kind: "message", T: AggregateExprNode, oneof: "expr_type" },
    { no: 6, name: "is_null_expr", kind: "message", T: IsNull, oneof: "expr_type" },
    { no: 7, name: "is_not_null_expr", kind: "message", T: IsNotNull, oneof: "expr_type" },
    { no: 8, name: "not_expr", kind: "message", T: Not, oneof: "expr_type" },
    { no: 9, name: "between", kind: "message", T: BetweenNode, oneof: "expr_type" },
    { no: 10, name: "case", kind: "message", T: CaseNode, oneof: "expr_type" },
    { no: 11, name: "cast", kind: "message", T: CastNode, oneof: "expr_type" },
    { no: 12, name: "sort", kind: "message", T: SortExprNode, oneof: "expr_type" },
    { no: 13, name: "negative", kind: "message", T: NegativeNode, oneof: "expr_type" },
    { no: 14, name: "in_list", kind: "message", T: InListNode, oneof: "expr_type" },
    { no: 15, name: "wildcard", kind: "message", T: Wildcard, oneof: "expr_type" },
    { no: 16, name: "scalar_function", kind: "message", T: ScalarFunctionNode, oneof: "expr_type" },
    { no: 17, name: "try_cast", kind: "message", T: TryCastNode, oneof: "expr_type" },
    { no: 18, name: "window_expr", kind: "message", T: WindowExprNode, oneof: "expr_type" },
    { no: 19, name: "aggregate_udf_expr", kind: "message", T: AggregateUDFExprNode, oneof: "expr_type" },
    { no: 20, name: "scalar_udf_expr", kind: "message", T: ScalarUDFExprNode, oneof: "expr_type" },
    { no: 21, name: "get_indexed_field", kind: "message", T: GetIndexedField, oneof: "expr_type" },
    { no: 22, name: "grouping_set", kind: "message", T: GroupingSetNode, oneof: "expr_type" },
    { no: 23, name: "cube", kind: "message", T: CubeNode, oneof: "expr_type" },
    { no: 24, name: "rollup", kind: "message", T: RollupNode, oneof: "expr_type" },
    { no: 25, name: "is_true", kind: "message", T: IsTrue, oneof: "expr_type" },
    { no: 26, name: "is_false", kind: "message", T: IsFalse, oneof: "expr_type" },
    { no: 27, name: "is_unknown", kind: "message", T: IsUnknown, oneof: "expr_type" },
    { no: 28, name: "is_not_true", kind: "message", T: IsNotTrue, oneof: "expr_type" },
    { no: 29, name: "is_not_false", kind: "message", T: IsNotFalse, oneof: "expr_type" },
    { no: 30, name: "is_not_unknown", kind: "message", T: IsNotUnknown, oneof: "expr_type" },
    { no: 31, name: "like", kind: "message", T: LikeNode, oneof: "expr_type" },
    { no: 32, name: "ilike", kind: "message", T: ILikeNode, oneof: "expr_type" },
    { no: 33, name: "similar_to", kind: "message", T: SimilarToNode, oneof: "expr_type" },
    { no: 34, name: "placeholder", kind: "message", T: PlaceholderNode, oneof: "expr_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogicalExprNode {
    return new LogicalExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogicalExprNode {
    return new LogicalExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogicalExprNode {
    return new LogicalExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: LogicalExprNode | PlainMessage<LogicalExprNode> | undefined, b: LogicalExprNode | PlainMessage<LogicalExprNode> | undefined): boolean {
    return proto3.util.equals(LogicalExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.ColumnRelation
 */
export class ColumnRelation extends Message<ColumnRelation> {
  /**
   * @generated from field: string relation = 1;
   */
  relation = "";

  constructor(data?: PartialMessage<ColumnRelation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ColumnRelation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnRelation {
    return new ColumnRelation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnRelation {
    return new ColumnRelation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnRelation {
    return new ColumnRelation().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnRelation | PlainMessage<ColumnRelation> | undefined, b: ColumnRelation | PlainMessage<ColumnRelation> | undefined): boolean {
    return proto3.util.equals(ColumnRelation, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.Column
 */
export class Column extends Message<Column> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: chalk.expression.v1.ColumnRelation relation = 2;
   */
  relation?: ColumnRelation;

  constructor(data?: PartialMessage<Column>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.Column";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relation", kind: "message", T: ColumnRelation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Column {
    return new Column().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Column {
    return new Column().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Column {
    return new Column().fromJsonString(jsonString, options);
  }

  static equals(a: Column | PlainMessage<Column> | undefined, b: Column | PlainMessage<Column> | undefined): boolean {
    return proto3.util.equals(Column, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.Wildcard
 */
export class Wildcard extends Message<Wildcard> {
  /**
   * @generated from field: optional string qualifier = 1;
   */
  qualifier?: string;

  constructor(data?: PartialMessage<Wildcard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.Wildcard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "qualifier", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Wildcard {
    return new Wildcard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Wildcard {
    return new Wildcard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Wildcard {
    return new Wildcard().fromJsonString(jsonString, options);
  }

  static equals(a: Wildcard | PlainMessage<Wildcard> | undefined, b: Wildcard | PlainMessage<Wildcard> | undefined): boolean {
    return proto3.util.equals(Wildcard, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.PlaceholderNode
 */
export class PlaceholderNode extends Message<PlaceholderNode> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: chalk.arrow.v1.ArrowType data_type = 2;
   */
  dataType?: ArrowType;

  constructor(data?: PartialMessage<PlaceholderNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.PlaceholderNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data_type", kind: "message", T: ArrowType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlaceholderNode {
    return new PlaceholderNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlaceholderNode {
    return new PlaceholderNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlaceholderNode {
    return new PlaceholderNode().fromJsonString(jsonString, options);
  }

  static equals(a: PlaceholderNode | PlainMessage<PlaceholderNode> | undefined, b: PlaceholderNode | PlainMessage<PlaceholderNode> | undefined): boolean {
    return proto3.util.equals(PlaceholderNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.LogicalExprList
 */
export class LogicalExprList extends Message<LogicalExprList> {
  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<LogicalExprList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.LogicalExprList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogicalExprList {
    return new LogicalExprList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogicalExprList {
    return new LogicalExprList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogicalExprList {
    return new LogicalExprList().fromJsonString(jsonString, options);
  }

  static equals(a: LogicalExprList | PlainMessage<LogicalExprList> | undefined, b: LogicalExprList | PlainMessage<LogicalExprList> | undefined): boolean {
    return proto3.util.equals(LogicalExprList, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.GroupingSetNode
 */
export class GroupingSetNode extends Message<GroupingSetNode> {
  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprList expr = 1;
   */
  expr: LogicalExprList[] = [];

  constructor(data?: PartialMessage<GroupingSetNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.GroupingSetNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupingSetNode {
    return new GroupingSetNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupingSetNode {
    return new GroupingSetNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupingSetNode {
    return new GroupingSetNode().fromJsonString(jsonString, options);
  }

  static equals(a: GroupingSetNode | PlainMessage<GroupingSetNode> | undefined, b: GroupingSetNode | PlainMessage<GroupingSetNode> | undefined): boolean {
    return proto3.util.equals(GroupingSetNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.CubeNode
 */
export class CubeNode extends Message<CubeNode> {
  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<CubeNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.CubeNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CubeNode {
    return new CubeNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CubeNode {
    return new CubeNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CubeNode {
    return new CubeNode().fromJsonString(jsonString, options);
  }

  static equals(a: CubeNode | PlainMessage<CubeNode> | undefined, b: CubeNode | PlainMessage<CubeNode> | undefined): boolean {
    return proto3.util.equals(CubeNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.RollupNode
 */
export class RollupNode extends Message<RollupNode> {
  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<RollupNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.RollupNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollupNode {
    return new RollupNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollupNode {
    return new RollupNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollupNode {
    return new RollupNode().fromJsonString(jsonString, options);
  }

  static equals(a: RollupNode | PlainMessage<RollupNode> | undefined, b: RollupNode | PlainMessage<RollupNode> | undefined): boolean {
    return proto3.util.equals(RollupNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.NamedStructField
 */
export class NamedStructField extends Message<NamedStructField> {
  /**
   * @generated from field: chalk.arrow.v1.ScalarValue name = 1;
   */
  name?: ScalarValue;

  constructor(data?: PartialMessage<NamedStructField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.NamedStructField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "message", T: ScalarValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedStructField {
    return new NamedStructField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedStructField {
    return new NamedStructField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedStructField {
    return new NamedStructField().fromJsonString(jsonString, options);
  }

  static equals(a: NamedStructField | PlainMessage<NamedStructField> | undefined, b: NamedStructField | PlainMessage<NamedStructField> | undefined): boolean {
    return proto3.util.equals(NamedStructField, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.ListIndex
 */
export class ListIndex extends Message<ListIndex> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode key = 1;
   */
  key?: LogicalExprNode;

  constructor(data?: PartialMessage<ListIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ListIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIndex {
    return new ListIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIndex {
    return new ListIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIndex {
    return new ListIndex().fromJsonString(jsonString, options);
  }

  static equals(a: ListIndex | PlainMessage<ListIndex> | undefined, b: ListIndex | PlainMessage<ListIndex> | undefined): boolean {
    return proto3.util.equals(ListIndex, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.ListRange
 */
export class ListRange extends Message<ListRange> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode start = 1;
   */
  start?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode stop = 2;
   */
  stop?: LogicalExprNode;

  constructor(data?: PartialMessage<ListRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ListRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: LogicalExprNode },
    { no: 2, name: "stop", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRange {
    return new ListRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRange {
    return new ListRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRange {
    return new ListRange().fromJsonString(jsonString, options);
  }

  static equals(a: ListRange | PlainMessage<ListRange> | undefined, b: ListRange | PlainMessage<ListRange> | undefined): boolean {
    return proto3.util.equals(ListRange, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.GetIndexedField
 */
export class GetIndexedField extends Message<GetIndexedField> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from oneof chalk.expression.v1.GetIndexedField.field
   */
  field: {
    /**
     * @generated from field: chalk.expression.v1.NamedStructField named_struct_field = 2;
     */
    value: NamedStructField;
    case: "namedStructField";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ListIndex list_index = 3;
     */
    value: ListIndex;
    case: "listIndex";
  } | {
    /**
     * @generated from field: chalk.expression.v1.ListRange list_range = 4;
     */
    value: ListRange;
    case: "listRange";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetIndexedField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.GetIndexedField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "named_struct_field", kind: "message", T: NamedStructField, oneof: "field" },
    { no: 3, name: "list_index", kind: "message", T: ListIndex, oneof: "field" },
    { no: 4, name: "list_range", kind: "message", T: ListRange, oneof: "field" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexedField {
    return new GetIndexedField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexedField {
    return new GetIndexedField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexedField {
    return new GetIndexedField().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexedField | PlainMessage<GetIndexedField> | undefined, b: GetIndexedField | PlainMessage<GetIndexedField> | undefined): boolean {
    return proto3.util.equals(GetIndexedField, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsNull
 */
export class IsNull extends Message<IsNull> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsNull>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsNull";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsNull {
    return new IsNull().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsNull {
    return new IsNull().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsNull {
    return new IsNull().fromJsonString(jsonString, options);
  }

  static equals(a: IsNull | PlainMessage<IsNull> | undefined, b: IsNull | PlainMessage<IsNull> | undefined): boolean {
    return proto3.util.equals(IsNull, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsNotNull
 */
export class IsNotNull extends Message<IsNotNull> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsNotNull>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsNotNull";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsNotNull {
    return new IsNotNull().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsNotNull {
    return new IsNotNull().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsNotNull {
    return new IsNotNull().fromJsonString(jsonString, options);
  }

  static equals(a: IsNotNull | PlainMessage<IsNotNull> | undefined, b: IsNotNull | PlainMessage<IsNotNull> | undefined): boolean {
    return proto3.util.equals(IsNotNull, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsTrue
 */
export class IsTrue extends Message<IsTrue> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsTrue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsTrue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsTrue {
    return new IsTrue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsTrue {
    return new IsTrue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsTrue {
    return new IsTrue().fromJsonString(jsonString, options);
  }

  static equals(a: IsTrue | PlainMessage<IsTrue> | undefined, b: IsTrue | PlainMessage<IsTrue> | undefined): boolean {
    return proto3.util.equals(IsTrue, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsFalse
 */
export class IsFalse extends Message<IsFalse> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsFalse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsFalse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsFalse {
    return new IsFalse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsFalse {
    return new IsFalse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsFalse {
    return new IsFalse().fromJsonString(jsonString, options);
  }

  static equals(a: IsFalse | PlainMessage<IsFalse> | undefined, b: IsFalse | PlainMessage<IsFalse> | undefined): boolean {
    return proto3.util.equals(IsFalse, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsUnknown
 */
export class IsUnknown extends Message<IsUnknown> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsUnknown>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsUnknown";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsUnknown {
    return new IsUnknown().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsUnknown {
    return new IsUnknown().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsUnknown {
    return new IsUnknown().fromJsonString(jsonString, options);
  }

  static equals(a: IsUnknown | PlainMessage<IsUnknown> | undefined, b: IsUnknown | PlainMessage<IsUnknown> | undefined): boolean {
    return proto3.util.equals(IsUnknown, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsNotTrue
 */
export class IsNotTrue extends Message<IsNotTrue> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsNotTrue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsNotTrue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsNotTrue {
    return new IsNotTrue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsNotTrue {
    return new IsNotTrue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsNotTrue {
    return new IsNotTrue().fromJsonString(jsonString, options);
  }

  static equals(a: IsNotTrue | PlainMessage<IsNotTrue> | undefined, b: IsNotTrue | PlainMessage<IsNotTrue> | undefined): boolean {
    return proto3.util.equals(IsNotTrue, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsNotFalse
 */
export class IsNotFalse extends Message<IsNotFalse> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsNotFalse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsNotFalse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsNotFalse {
    return new IsNotFalse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsNotFalse {
    return new IsNotFalse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsNotFalse {
    return new IsNotFalse().fromJsonString(jsonString, options);
  }

  static equals(a: IsNotFalse | PlainMessage<IsNotFalse> | undefined, b: IsNotFalse | PlainMessage<IsNotFalse> | undefined): boolean {
    return proto3.util.equals(IsNotFalse, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.IsNotUnknown
 */
export class IsNotUnknown extends Message<IsNotUnknown> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<IsNotUnknown>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.IsNotUnknown";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsNotUnknown {
    return new IsNotUnknown().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsNotUnknown {
    return new IsNotUnknown().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsNotUnknown {
    return new IsNotUnknown().fromJsonString(jsonString, options);
  }

  static equals(a: IsNotUnknown | PlainMessage<IsNotUnknown> | undefined, b: IsNotUnknown | PlainMessage<IsNotUnknown> | undefined): boolean {
    return proto3.util.equals(IsNotUnknown, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.Not
 */
export class Not extends Message<Not> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<Not>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.Not";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Not {
    return new Not().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Not {
    return new Not().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Not {
    return new Not().fromJsonString(jsonString, options);
  }

  static equals(a: Not | PlainMessage<Not> | undefined, b: Not | PlainMessage<Not> | undefined): boolean {
    return proto3.util.equals(Not, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.AliasNode
 */
export class AliasNode extends Message<AliasNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: string alias = 2;
   */
  alias = "";

  /**
   * @generated from field: repeated chalk.expression.v1.OwnedTableReference relation = 3;
   */
  relation: OwnedTableReference[] = [];

  constructor(data?: PartialMessage<AliasNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.AliasNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relation", kind: "message", T: OwnedTableReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasNode {
    return new AliasNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasNode {
    return new AliasNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasNode {
    return new AliasNode().fromJsonString(jsonString, options);
  }

  static equals(a: AliasNode | PlainMessage<AliasNode> | undefined, b: AliasNode | PlainMessage<AliasNode> | undefined): boolean {
    return proto3.util.equals(AliasNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.BareTableReference
 */
export class BareTableReference extends Message<BareTableReference> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  constructor(data?: PartialMessage<BareTableReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.BareTableReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BareTableReference {
    return new BareTableReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BareTableReference {
    return new BareTableReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BareTableReference {
    return new BareTableReference().fromJsonString(jsonString, options);
  }

  static equals(a: BareTableReference | PlainMessage<BareTableReference> | undefined, b: BareTableReference | PlainMessage<BareTableReference> | undefined): boolean {
    return proto3.util.equals(BareTableReference, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.PartialTableReference
 */
export class PartialTableReference extends Message<PartialTableReference> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  constructor(data?: PartialMessage<PartialTableReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.PartialTableReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PartialTableReference {
    return new PartialTableReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PartialTableReference {
    return new PartialTableReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PartialTableReference {
    return new PartialTableReference().fromJsonString(jsonString, options);
  }

  static equals(a: PartialTableReference | PlainMessage<PartialTableReference> | undefined, b: PartialTableReference | PlainMessage<PartialTableReference> | undefined): boolean {
    return proto3.util.equals(PartialTableReference, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.FullTableReference
 */
export class FullTableReference extends Message<FullTableReference> {
  /**
   * @generated from field: string catalog = 1;
   */
  catalog = "";

  /**
   * @generated from field: string schema = 2;
   */
  schema = "";

  /**
   * @generated from field: string table = 3;
   */
  table = "";

  constructor(data?: PartialMessage<FullTableReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.FullTableReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "catalog", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FullTableReference {
    return new FullTableReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FullTableReference {
    return new FullTableReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FullTableReference {
    return new FullTableReference().fromJsonString(jsonString, options);
  }

  static equals(a: FullTableReference | PlainMessage<FullTableReference> | undefined, b: FullTableReference | PlainMessage<FullTableReference> | undefined): boolean {
    return proto3.util.equals(FullTableReference, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.OwnedTableReference
 */
export class OwnedTableReference extends Message<OwnedTableReference> {
  /**
   * @generated from oneof chalk.expression.v1.OwnedTableReference.table_reference_enum
   */
  tableReferenceEnum: {
    /**
     * @generated from field: chalk.expression.v1.BareTableReference bare = 1;
     */
    value: BareTableReference;
    case: "bare";
  } | {
    /**
     * @generated from field: chalk.expression.v1.PartialTableReference partial = 2;
     */
    value: PartialTableReference;
    case: "partial";
  } | {
    /**
     * @generated from field: chalk.expression.v1.FullTableReference full = 3;
     */
    value: FullTableReference;
    case: "full";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OwnedTableReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.OwnedTableReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bare", kind: "message", T: BareTableReference, oneof: "table_reference_enum" },
    { no: 2, name: "partial", kind: "message", T: PartialTableReference, oneof: "table_reference_enum" },
    { no: 3, name: "full", kind: "message", T: FullTableReference, oneof: "table_reference_enum" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OwnedTableReference {
    return new OwnedTableReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OwnedTableReference {
    return new OwnedTableReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OwnedTableReference {
    return new OwnedTableReference().fromJsonString(jsonString, options);
  }

  static equals(a: OwnedTableReference | PlainMessage<OwnedTableReference> | undefined, b: OwnedTableReference | PlainMessage<OwnedTableReference> | undefined): boolean {
    return proto3.util.equals(OwnedTableReference, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.BinaryExprNode
 */
export class BinaryExprNode extends Message<BinaryExprNode> {
  /**
   * Represents the operands from the left inner most expression
   * to the right outer most expression where each of them are chained
   * with the operator 'op'.
   *
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode operands = 1;
   */
  operands: LogicalExprNode[] = [];

  /**
   * @generated from field: string op = 3;
   */
  op = "";

  constructor(data?: PartialMessage<BinaryExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.BinaryExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operands", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 3, name: "op", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryExprNode {
    return new BinaryExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryExprNode {
    return new BinaryExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryExprNode {
    return new BinaryExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryExprNode | PlainMessage<BinaryExprNode> | undefined, b: BinaryExprNode | PlainMessage<BinaryExprNode> | undefined): boolean {
    return proto3.util.equals(BinaryExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.NegativeNode
 */
export class NegativeNode extends Message<NegativeNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  constructor(data?: PartialMessage<NegativeNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.NegativeNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NegativeNode {
    return new NegativeNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NegativeNode {
    return new NegativeNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NegativeNode {
    return new NegativeNode().fromJsonString(jsonString, options);
  }

  static equals(a: NegativeNode | PlainMessage<NegativeNode> | undefined, b: NegativeNode | PlainMessage<NegativeNode> | undefined): boolean {
    return proto3.util.equals(NegativeNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.InListNode
 */
export class InListNode extends Message<InListNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode list = 2;
   */
  list: LogicalExprNode[] = [];

  /**
   * @generated from field: bool negated = 3;
   */
  negated = false;

  constructor(data?: PartialMessage<InListNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.InListNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "list", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 3, name: "negated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InListNode {
    return new InListNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InListNode {
    return new InListNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InListNode {
    return new InListNode().fromJsonString(jsonString, options);
  }

  static equals(a: InListNode | PlainMessage<InListNode> | undefined, b: InListNode | PlainMessage<InListNode> | undefined): boolean {
    return proto3.util.equals(InListNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.ScalarFunctionNode
 */
export class ScalarFunctionNode extends Message<ScalarFunctionNode> {
  /**
   * @generated from field: chalk.expression.v1.ScalarFunction fun = 1;
   */
  fun = ScalarFunction.UNSPECIFIED;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode args = 2;
   */
  args: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<ScalarFunctionNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ScalarFunctionNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fun", kind: "enum", T: proto3.getEnumType(ScalarFunction) },
    { no: 2, name: "args", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScalarFunctionNode {
    return new ScalarFunctionNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScalarFunctionNode {
    return new ScalarFunctionNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScalarFunctionNode {
    return new ScalarFunctionNode().fromJsonString(jsonString, options);
  }

  static equals(a: ScalarFunctionNode | PlainMessage<ScalarFunctionNode> | undefined, b: ScalarFunctionNode | PlainMessage<ScalarFunctionNode> | undefined): boolean {
    return proto3.util.equals(ScalarFunctionNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.AggregateExprNode
 */
export class AggregateExprNode extends Message<AggregateExprNode> {
  /**
   * @generated from field: chalk.expression.v1.AggregateFunction aggr_function = 1;
   */
  aggrFunction = AggregateFunction.UNSPECIFIED;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode expr = 2;
   */
  expr: LogicalExprNode[] = [];

  /**
   * @generated from field: bool distinct = 3;
   */
  distinct = false;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode filter = 4;
   */
  filter?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode order_by = 5;
   */
  orderBy: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<AggregateExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.AggregateExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggr_function", kind: "enum", T: proto3.getEnumType(AggregateFunction) },
    { no: 2, name: "expr", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 3, name: "distinct", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "filter", kind: "message", T: LogicalExprNode },
    { no: 5, name: "order_by", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateExprNode {
    return new AggregateExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateExprNode {
    return new AggregateExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateExprNode {
    return new AggregateExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateExprNode | PlainMessage<AggregateExprNode> | undefined, b: AggregateExprNode | PlainMessage<AggregateExprNode> | undefined): boolean {
    return proto3.util.equals(AggregateExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.AggregateUDFExprNode
 */
export class AggregateUDFExprNode extends Message<AggregateUDFExprNode> {
  /**
   * @generated from field: string fun_name = 1;
   */
  funName = "";

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode args = 2;
   */
  args: LogicalExprNode[] = [];

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode filter = 3;
   */
  filter?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode order_by = 4;
   */
  orderBy: LogicalExprNode[] = [];

  /**
   * @generated from field: map<string, chalk.expression.v1.LogicalExprNode> kwargs = 5;
   */
  kwargs: { [key: string]: LogicalExprNode } = {};

  constructor(data?: PartialMessage<AggregateUDFExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.AggregateUDFExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fun_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 3, name: "filter", kind: "message", T: LogicalExprNode },
    { no: 4, name: "order_by", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 5, name: "kwargs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LogicalExprNode} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateUDFExprNode {
    return new AggregateUDFExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateUDFExprNode {
    return new AggregateUDFExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateUDFExprNode {
    return new AggregateUDFExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateUDFExprNode | PlainMessage<AggregateUDFExprNode> | undefined, b: AggregateUDFExprNode | PlainMessage<AggregateUDFExprNode> | undefined): boolean {
    return proto3.util.equals(AggregateUDFExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.ScalarUDFExprNode
 */
export class ScalarUDFExprNode extends Message<ScalarUDFExprNode> {
  /**
   * @generated from field: string fun_name = 1;
   */
  funName = "";

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode args = 2;
   */
  args: LogicalExprNode[] = [];

  constructor(data?: PartialMessage<ScalarUDFExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ScalarUDFExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fun_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "message", T: LogicalExprNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScalarUDFExprNode {
    return new ScalarUDFExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScalarUDFExprNode {
    return new ScalarUDFExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScalarUDFExprNode {
    return new ScalarUDFExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: ScalarUDFExprNode | PlainMessage<ScalarUDFExprNode> | undefined, b: ScalarUDFExprNode | PlainMessage<ScalarUDFExprNode> | undefined): boolean {
    return proto3.util.equals(ScalarUDFExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.WindowExprNode
 */
export class WindowExprNode extends Message<WindowExprNode> {
  /**
   * @generated from oneof chalk.expression.v1.WindowExprNode.window_function
   */
  windowFunction: {
    /**
     * @generated from field: chalk.expression.v1.AggregateFunction aggr_function = 1;
     */
    value: AggregateFunction;
    case: "aggrFunction";
  } | {
    /**
     * @generated from field: chalk.expression.v1.BuiltInWindowFunction built_in_function = 2;
     */
    value: BuiltInWindowFunction;
    case: "builtInFunction";
  } | {
    /**
     * @generated from field: string udaf = 3;
     */
    value: string;
    case: "udaf";
  } | {
    /**
     * @generated from field: string udwf = 9;
     */
    value: string;
    case: "udwf";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 4;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode partition_by = 5;
   */
  partitionBy: LogicalExprNode[] = [];

  /**
   * @generated from field: repeated chalk.expression.v1.LogicalExprNode order_by = 6;
   */
  orderBy: LogicalExprNode[] = [];

  /**
   * repeated LogicalExprNode filter = 7;
   *
   * @generated from field: chalk.expression.v1.WindowFrame window_frame = 8;
   */
  windowFrame?: WindowFrame;

  constructor(data?: PartialMessage<WindowExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.WindowExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggr_function", kind: "enum", T: proto3.getEnumType(AggregateFunction), oneof: "window_function" },
    { no: 2, name: "built_in_function", kind: "enum", T: proto3.getEnumType(BuiltInWindowFunction), oneof: "window_function" },
    { no: 3, name: "udaf", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "window_function" },
    { no: 9, name: "udwf", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "window_function" },
    { no: 4, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 5, name: "partition_by", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 6, name: "order_by", kind: "message", T: LogicalExprNode, repeated: true },
    { no: 8, name: "window_frame", kind: "message", T: WindowFrame },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowExprNode {
    return new WindowExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowExprNode {
    return new WindowExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowExprNode {
    return new WindowExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: WindowExprNode | PlainMessage<WindowExprNode> | undefined, b: WindowExprNode | PlainMessage<WindowExprNode> | undefined): boolean {
    return proto3.util.equals(WindowExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.BetweenNode
 */
export class BetweenNode extends Message<BetweenNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: bool negated = 2;
   */
  negated = false;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode low = 3;
   */
  low?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode high = 4;
   */
  high?: LogicalExprNode;

  constructor(data?: PartialMessage<BetweenNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.BetweenNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "negated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "low", kind: "message", T: LogicalExprNode },
    { no: 4, name: "high", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BetweenNode {
    return new BetweenNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BetweenNode {
    return new BetweenNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BetweenNode {
    return new BetweenNode().fromJsonString(jsonString, options);
  }

  static equals(a: BetweenNode | PlainMessage<BetweenNode> | undefined, b: BetweenNode | PlainMessage<BetweenNode> | undefined): boolean {
    return proto3.util.equals(BetweenNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.LikeNode
 */
export class LikeNode extends Message<LikeNode> {
  /**
   * @generated from field: bool negated = 1;
   */
  negated = false;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 2;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode pattern = 3;
   */
  pattern?: LogicalExprNode;

  /**
   * @generated from field: string escape_char = 4;
   */
  escapeChar = "";

  constructor(data?: PartialMessage<LikeNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.LikeNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "negated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 3, name: "pattern", kind: "message", T: LogicalExprNode },
    { no: 4, name: "escape_char", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LikeNode {
    return new LikeNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LikeNode {
    return new LikeNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LikeNode {
    return new LikeNode().fromJsonString(jsonString, options);
  }

  static equals(a: LikeNode | PlainMessage<LikeNode> | undefined, b: LikeNode | PlainMessage<LikeNode> | undefined): boolean {
    return proto3.util.equals(LikeNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.ILikeNode
 */
export class ILikeNode extends Message<ILikeNode> {
  /**
   * @generated from field: bool negated = 1;
   */
  negated = false;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 2;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode pattern = 3;
   */
  pattern?: LogicalExprNode;

  /**
   * @generated from field: string escape_char = 4;
   */
  escapeChar = "";

  constructor(data?: PartialMessage<ILikeNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.ILikeNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "negated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 3, name: "pattern", kind: "message", T: LogicalExprNode },
    { no: 4, name: "escape_char", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ILikeNode {
    return new ILikeNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ILikeNode {
    return new ILikeNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ILikeNode {
    return new ILikeNode().fromJsonString(jsonString, options);
  }

  static equals(a: ILikeNode | PlainMessage<ILikeNode> | undefined, b: ILikeNode | PlainMessage<ILikeNode> | undefined): boolean {
    return proto3.util.equals(ILikeNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.SimilarToNode
 */
export class SimilarToNode extends Message<SimilarToNode> {
  /**
   * @generated from field: bool negated = 1;
   */
  negated = false;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 2;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode pattern = 3;
   */
  pattern?: LogicalExprNode;

  /**
   * @generated from field: string escape_char = 4;
   */
  escapeChar = "";

  constructor(data?: PartialMessage<SimilarToNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.SimilarToNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "negated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 3, name: "pattern", kind: "message", T: LogicalExprNode },
    { no: 4, name: "escape_char", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimilarToNode {
    return new SimilarToNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimilarToNode {
    return new SimilarToNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimilarToNode {
    return new SimilarToNode().fromJsonString(jsonString, options);
  }

  static equals(a: SimilarToNode | PlainMessage<SimilarToNode> | undefined, b: SimilarToNode | PlainMessage<SimilarToNode> | undefined): boolean {
    return proto3.util.equals(SimilarToNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.CaseNode
 */
export class CaseNode extends Message<CaseNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: repeated chalk.expression.v1.WhenThen when_then_expr = 2;
   */
  whenThenExpr: WhenThen[] = [];

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode else_expr = 3;
   */
  elseExpr?: LogicalExprNode;

  constructor(data?: PartialMessage<CaseNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.CaseNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "when_then_expr", kind: "message", T: WhenThen, repeated: true },
    { no: 3, name: "else_expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CaseNode {
    return new CaseNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CaseNode {
    return new CaseNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CaseNode {
    return new CaseNode().fromJsonString(jsonString, options);
  }

  static equals(a: CaseNode | PlainMessage<CaseNode> | undefined, b: CaseNode | PlainMessage<CaseNode> | undefined): boolean {
    return proto3.util.equals(CaseNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.WhenThen
 */
export class WhenThen extends Message<WhenThen> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode when_expr = 1;
   */
  whenExpr?: LogicalExprNode;

  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode then_expr = 2;
   */
  thenExpr?: LogicalExprNode;

  constructor(data?: PartialMessage<WhenThen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.WhenThen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "when_expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "then_expr", kind: "message", T: LogicalExprNode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhenThen {
    return new WhenThen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhenThen {
    return new WhenThen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhenThen {
    return new WhenThen().fromJsonString(jsonString, options);
  }

  static equals(a: WhenThen | PlainMessage<WhenThen> | undefined, b: WhenThen | PlainMessage<WhenThen> | undefined): boolean {
    return proto3.util.equals(WhenThen, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.CastNode
 */
export class CastNode extends Message<CastNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: chalk.arrow.v1.ArrowType arrow_type = 2;
   */
  arrowType?: ArrowType;

  constructor(data?: PartialMessage<CastNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.CastNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "arrow_type", kind: "message", T: ArrowType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CastNode {
    return new CastNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CastNode {
    return new CastNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CastNode {
    return new CastNode().fromJsonString(jsonString, options);
  }

  static equals(a: CastNode | PlainMessage<CastNode> | undefined, b: CastNode | PlainMessage<CastNode> | undefined): boolean {
    return proto3.util.equals(CastNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.TryCastNode
 */
export class TryCastNode extends Message<TryCastNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: chalk.arrow.v1.ArrowType arrow_type = 2;
   */
  arrowType?: ArrowType;

  constructor(data?: PartialMessage<TryCastNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.TryCastNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "arrow_type", kind: "message", T: ArrowType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TryCastNode {
    return new TryCastNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TryCastNode {
    return new TryCastNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TryCastNode {
    return new TryCastNode().fromJsonString(jsonString, options);
  }

  static equals(a: TryCastNode | PlainMessage<TryCastNode> | undefined, b: TryCastNode | PlainMessage<TryCastNode> | undefined): boolean {
    return proto3.util.equals(TryCastNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.SortExprNode
 */
export class SortExprNode extends Message<SortExprNode> {
  /**
   * @generated from field: chalk.expression.v1.LogicalExprNode expr = 1;
   */
  expr?: LogicalExprNode;

  /**
   * @generated from field: bool asc = 2;
   */
  asc = false;

  /**
   * @generated from field: bool nulls_first = 3;
   */
  nullsFirst = false;

  constructor(data?: PartialMessage<SortExprNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.SortExprNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: LogicalExprNode },
    { no: 2, name: "asc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "nulls_first", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortExprNode {
    return new SortExprNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortExprNode {
    return new SortExprNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortExprNode {
    return new SortExprNode().fromJsonString(jsonString, options);
  }

  static equals(a: SortExprNode | PlainMessage<SortExprNode> | undefined, b: SortExprNode | PlainMessage<SortExprNode> | undefined): boolean {
    return proto3.util.equals(SortExprNode, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.WindowFrame
 */
export class WindowFrame extends Message<WindowFrame> {
  /**
   * @generated from field: chalk.expression.v1.WindowFrameUnits window_frame_units = 1;
   */
  windowFrameUnits = WindowFrameUnits.UNSPECIFIED;

  /**
   * @generated from field: chalk.expression.v1.WindowFrameBound start_bound = 2;
   */
  startBound?: WindowFrameBound;

  /**
   * @generated from field: optional chalk.expression.v1.WindowFrameBound bound = 3;
   */
  bound?: WindowFrameBound;

  constructor(data?: PartialMessage<WindowFrame>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.WindowFrame";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "window_frame_units", kind: "enum", T: proto3.getEnumType(WindowFrameUnits) },
    { no: 2, name: "start_bound", kind: "message", T: WindowFrameBound },
    { no: 3, name: "bound", kind: "message", T: WindowFrameBound, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowFrame {
    return new WindowFrame().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowFrame {
    return new WindowFrame().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowFrame {
    return new WindowFrame().fromJsonString(jsonString, options);
  }

  static equals(a: WindowFrame | PlainMessage<WindowFrame> | undefined, b: WindowFrame | PlainMessage<WindowFrame> | undefined): boolean {
    return proto3.util.equals(WindowFrame, a, b);
  }
}

/**
 * @generated from message chalk.expression.v1.WindowFrameBound
 */
export class WindowFrameBound extends Message<WindowFrameBound> {
  /**
   * @generated from field: chalk.expression.v1.WindowFrameBoundType window_frame_bound_type = 1;
   */
  windowFrameBoundType = WindowFrameBoundType.UNSPECIFIED;

  /**
   * @generated from field: chalk.arrow.v1.ScalarValue bound_value = 2;
   */
  boundValue?: ScalarValue;

  constructor(data?: PartialMessage<WindowFrameBound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.expression.v1.WindowFrameBound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "window_frame_bound_type", kind: "enum", T: proto3.getEnumType(WindowFrameBoundType) },
    { no: 2, name: "bound_value", kind: "message", T: ScalarValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowFrameBound {
    return new WindowFrameBound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowFrameBound {
    return new WindowFrameBound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowFrameBound {
    return new WindowFrameBound().fromJsonString(jsonString, options);
  }

  static equals(a: WindowFrameBound | PlainMessage<WindowFrameBound> | undefined, b: WindowFrameBound | PlainMessage<WindowFrameBound> | undefined): boolean {
    return proto3.util.equals(WindowFrameBound, a, b);
  }
}

