// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/common/v1/query_log.proto (package chalk.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { OperationKind } from "./operation_kind_pb";
import { QueryStatus } from "./query_status_pb";

/**
 * @generated from message chalk.common.v1.VersionedQueryName
 * @deprecated
 */
export class VersionedQueryName extends Message<VersionedQueryName> {
  /**
   * @generated from field: string query_name = 1;
   */
  queryName = "";

  /**
   * @generated from field: optional string query_name_version = 2;
   */
  queryNameVersion?: string;

  constructor(data?: PartialMessage<VersionedQueryName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.VersionedQueryName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query_name_version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VersionedQueryName {
    return new VersionedQueryName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VersionedQueryName {
    return new VersionedQueryName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VersionedQueryName {
    return new VersionedQueryName().fromJsonString(jsonString, options);
  }

  static equals(a: VersionedQueryName | PlainMessage<VersionedQueryName> | undefined, b: VersionedQueryName | PlainMessage<VersionedQueryName> | undefined): boolean {
    return proto3.util.equals(VersionedQueryName, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.QueryLogFilters
 * @deprecated
 */
export class QueryLogFilters extends Message<QueryLogFilters> {
  /**
   * All of these fields are optional. If any are specified, they will be AND'd together in a where clause
   * Any len-zero options will be ignored. If multiple options are specified for a given key, they will be OR'd together
   * i.e. works similarly to how you filter products on Amazon -- (size 8 or size 9) AND (color == blue OR color == "red")
   *
   * @generated from field: repeated string operation_id = 1;
   */
  operationId: string[] = [];

  /**
   * @generated from field: repeated chalk.common.v1.OperationKind operation_kind = 2;
   */
  operationKind: OperationKind[] = [];

  /**
   * @generated from field: repeated chalk.common.v1.VersionedQueryName query_name = 3;
   */
  queryName: VersionedQueryName[] = [];

  /**
   * @generated from field: repeated string agent_id = 5;
   */
  agentId: string[] = [];

  /**
   * @generated from field: repeated string branch_name = 6;
   */
  branchName: string[] = [];

  /**
   * @generated from field: repeated string correlation_id = 7;
   */
  correlationId: string[] = [];

  /**
   * @generated from field: repeated string trace_id = 8;
   */
  traceId: string[] = [];

  /**
   * @generated from field: repeated string query_plan_id = 9;
   */
  queryPlanId: string[] = [];

  /**
   * @generated from field: repeated string deployment_id = 10;
   */
  deploymentId: string[] = [];

  /**
   * @generated from field: repeated chalk.common.v1.QueryStatus query_status = 11;
   */
  queryStatus: QueryStatus[] = [];

  /**
   * @generated from field: repeated string meta_query_hash = 12;
   */
  metaQueryHash: string[] = [];

  constructor(data?: PartialMessage<QueryLogFilters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.QueryLogFilters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "operation_kind", kind: "enum", T: proto3.getEnumType(OperationKind), repeated: true },
    { no: 3, name: "query_name", kind: "message", T: VersionedQueryName, repeated: true },
    { no: 5, name: "agent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "branch_name", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "correlation_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "trace_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "query_plan_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "deployment_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "query_status", kind: "enum", T: proto3.getEnumType(QueryStatus), repeated: true },
    { no: 12, name: "meta_query_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLogFilters {
    return new QueryLogFilters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLogFilters {
    return new QueryLogFilters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLogFilters {
    return new QueryLogFilters().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLogFilters | PlainMessage<QueryLogFilters> | undefined, b: QueryLogFilters | PlainMessage<QueryLogFilters> | undefined): boolean {
    return proto3.util.equals(QueryLogFilters, a, b);
  }
}

/**
 * Internal protobuf representing a next page token. Contains the operation id and the query timestamp for the last row
 * in the previous batch. Results are sorted query timestamp then by operation id lexicographically, so this is all we
 * need to know where the next page begins
 *
 * @generated from message chalk.common.v1.GetQueryLogEntriesPageToken
 * @deprecated
 */
export class GetQueryLogEntriesPageToken extends Message<GetQueryLogEntriesPageToken> {
  /**
   * @generated from field: string operation_id_hwm = 1;
   */
  operationIdHwm = "";

  /**
   * @generated from field: google.protobuf.Timestamp query_timestamp_hwm = 2;
   */
  queryTimestampHwm?: Timestamp;

  constructor(data?: PartialMessage<GetQueryLogEntriesPageToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.GetQueryLogEntriesPageToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id_hwm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query_timestamp_hwm", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryLogEntriesPageToken {
    return new GetQueryLogEntriesPageToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryLogEntriesPageToken {
    return new GetQueryLogEntriesPageToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryLogEntriesPageToken {
    return new GetQueryLogEntriesPageToken().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryLogEntriesPageToken | PlainMessage<GetQueryLogEntriesPageToken> | undefined, b: GetQueryLogEntriesPageToken | PlainMessage<GetQueryLogEntriesPageToken> | undefined): boolean {
    return proto3.util.equals(GetQueryLogEntriesPageToken, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.GetQueryLogEntriesRequest
 * @deprecated
 */
export class GetQueryLogEntriesRequest extends Message<GetQueryLogEntriesRequest> {
  /**
   * The query log table is partitioned / sorted by timestamp, so we must provide these
   * for the queries to be efficient, even if we are querying for a single operation id
   *
   * @generated from field: google.protobuf.Timestamp query_timestamp_lower_bound_inclusive = 1;
   */
  queryTimestampLowerBoundInclusive?: Timestamp;

  /**
   * If the upper bound is omitted, then the lower bound will be used as an "equality" filter
   *
   * @generated from field: optional google.protobuf.Timestamp query_timestamp_upper_bound_exclusive = 2;
   */
  queryTimestampUpperBoundExclusive?: Timestamp;

  /**
   * Any filters for searching the query log. See the QueryLogFilters message above
   *
   * @generated from field: chalk.common.v1.QueryLogFilters filters = 3;
   */
  filters?: QueryLogFilters;

  /**
   * The (maximum) page size. If zero, the server gets to choose.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize = 0;

  /**
   * When dealing with paginated responses, the next token can be provided to get the next page of responses
   * The query parameters above must be exactly the same when using a next token
   * This is opaque to the clients, but in practice, it is an encoding of the GetQueryLogEntriesPageToken
   *
   * @generated from field: string page_token = 5;
   */
  pageToken = "";

  constructor(data?: PartialMessage<GetQueryLogEntriesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.GetQueryLogEntriesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_timestamp_lower_bound_inclusive", kind: "message", T: Timestamp },
    { no: 2, name: "query_timestamp_upper_bound_exclusive", kind: "message", T: Timestamp, opt: true },
    { no: 3, name: "filters", kind: "message", T: QueryLogFilters },
    { no: 4, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryLogEntriesRequest {
    return new GetQueryLogEntriesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryLogEntriesRequest {
    return new GetQueryLogEntriesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryLogEntriesRequest {
    return new GetQueryLogEntriesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryLogEntriesRequest | PlainMessage<GetQueryLogEntriesRequest> | undefined, b: GetQueryLogEntriesRequest | PlainMessage<GetQueryLogEntriesRequest> | undefined): boolean {
    return proto3.util.equals(GetQueryLogEntriesRequest, a, b);
  }
}

/**
 * This is a proto representation of the SQL QueryLogModel.
 *
 * @generated from message chalk.common.v1.QueryLogEntry
 * @deprecated
 */
export class QueryLogEntry extends Message<QueryLogEntry> {
  /**
   * @generated from field: string operation_id = 1;
   */
  operationId = "";

  /**
   * @generated from field: string environment_id = 2;
   */
  environmentId = "";

  /**
   * @generated from field: string deployment_id = 3;
   */
  deploymentId = "";

  /**
   * @generated from field: chalk.common.v1.OperationKind operation_kind = 4;
   */
  operationKind = OperationKind.UNSPECIFIED;

  /**
   * @generated from field: google.protobuf.Timestamp query_timestamp = 5;
   */
  queryTimestamp?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp execution_started_at = 6;
   */
  executionStartedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp execution_finished_at = 7;
   */
  executionFinishedAt?: Timestamp;

  /**
   * @generated from field: chalk.common.v1.QueryStatus query_status = 8;
   */
  queryStatus = QueryStatus.UNSPECIFIED;

  /**
   * @generated from field: string query_name = 9;
   */
  queryName = "";

  /**
   * @generated from field: string query_name_version = 10;
   */
  queryNameVersion = "";

  /**
   * @generated from field: string agent_id = 11;
   */
  agentId = "";

  /**
   * @generated from field: string branch_name = 12;
   */
  branchName = "";

  /**
   * @generated from field: string correlation_id = 13;
   */
  correlationId = "";

  /**
   * @generated from field: string trace_id = 14;
   */
  traceId = "";

  /**
   * @generated from field: string query_plan_id = 15;
   */
  queryPlanId = "";

  /**
   * @generated from field: repeated string value_tables = 16;
   */
  valueTables: string[] = [];

  /**
   * @generated from field: string meta_query_hash = 17;
   */
  metaQueryHash = "";

  constructor(data?: PartialMessage<QueryLogEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.QueryLogEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "environment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deployment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "operation_kind", kind: "enum", T: proto3.getEnumType(OperationKind) },
    { no: 5, name: "query_timestamp", kind: "message", T: Timestamp },
    { no: 6, name: "execution_started_at", kind: "message", T: Timestamp },
    { no: 7, name: "execution_finished_at", kind: "message", T: Timestamp },
    { no: 8, name: "query_status", kind: "enum", T: proto3.getEnumType(QueryStatus) },
    { no: 9, name: "query_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "query_name_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "agent_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "branch_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "correlation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "trace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "query_plan_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "value_tables", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 17, name: "meta_query_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLogEntry {
    return new QueryLogEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLogEntry {
    return new QueryLogEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLogEntry {
    return new QueryLogEntry().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLogEntry | PlainMessage<QueryLogEntry> | undefined, b: QueryLogEntry | PlainMessage<QueryLogEntry> | undefined): boolean {
    return proto3.util.equals(QueryLogEntry, a, b);
  }
}

/**
 * @generated from message chalk.common.v1.GetQueryLogEntriesResponse
 * @deprecated
 */
export class GetQueryLogEntriesResponse extends Message<GetQueryLogEntriesResponse> {
  /**
   * @generated from field: repeated chalk.common.v1.QueryLogEntry entries = 1;
   */
  entries: QueryLogEntry[] = [];

  /**
   * If the next_page_token is non-empty, then there may be more rows, even if the entires is empty.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<GetQueryLogEntriesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.common.v1.GetQueryLogEntriesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: QueryLogEntry, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryLogEntriesResponse {
    return new GetQueryLogEntriesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryLogEntriesResponse {
    return new GetQueryLogEntriesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryLogEntriesResponse {
    return new GetQueryLogEntriesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryLogEntriesResponse | PlainMessage<GetQueryLogEntriesResponse> | undefined, b: GetQueryLogEntriesResponse | PlainMessage<GetQueryLogEntriesResponse> | undefined): boolean {
    return proto3.util.equals(GetQueryLogEntriesResponse, a, b);
  }
}

