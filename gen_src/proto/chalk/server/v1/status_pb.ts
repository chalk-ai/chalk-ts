// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/server/v1/status.proto (package chalk.server.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Struct } from "@bufbuild/protobuf";

/**
 * @generated from enum chalk.server.v1.HealthCheckStatus
 */
export enum HealthCheckStatus {
  /**
   * @generated from enum value: HEALTH_CHECK_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HEALTH_CHECK_STATUS_OK = 1;
   */
  OK = 1,

  /**
   * @generated from enum value: HEALTH_CHECK_STATUS_FAILING = 2;
   */
  FAILING = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(HealthCheckStatus)
proto3.util.setEnumType(HealthCheckStatus, "chalk.server.v1.HealthCheckStatus", [
  { no: 0, name: "HEALTH_CHECK_STATUS_UNSPECIFIED" },
  { no: 1, name: "HEALTH_CHECK_STATUS_OK" },
  { no: 2, name: "HEALTH_CHECK_STATUS_FAILING" },
]);

/**
 * @generated from message chalk.server.v1.HealthCheck
 */
export class HealthCheck extends Message<HealthCheck> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: chalk.server.v1.HealthCheckStatus status = 2;
   */
  status = HealthCheckStatus.UNSPECIFIED;

  /**
   * @generated from field: optional string message = 3;
   */
  message?: string;

  /**
   * @generated from field: optional google.protobuf.Duration latency = 4;
   */
  latency?: Duration;

  /**
   * @generated from field: optional google.protobuf.Struct kube_data = 5;
   */
  kubeData?: Struct;

  /**
   * @generated from field: map<string, string> metadata = 6;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<HealthCheck>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.HealthCheck";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(HealthCheckStatus) },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "latency", kind: "message", T: Duration, opt: true },
    { no: 5, name: "kube_data", kind: "message", T: Struct, opt: true },
    { no: 6, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck {
    return new HealthCheck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck {
    return new HealthCheck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck {
    return new HealthCheck().fromJsonString(jsonString, options);
  }

  static equals(a: HealthCheck | PlainMessage<HealthCheck> | undefined, b: HealthCheck | PlainMessage<HealthCheck> | undefined): boolean {
    return proto3.util.equals(HealthCheck, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.HealthCheckFilters
 */
export class HealthCheckFilters extends Message<HealthCheckFilters> {
  /**
   * All of these fields are optional. If any are specified, they will be AND'd together in a where clause
   * Any len-zero options will be ignored. If multiple options are specified for a given key, they will be OR'd together
   * i.e. works similarly to how you filter products on Amazon -- (size 8 or size 9) AND (color == blue OR color == "red")
   *
   * @generated from field: repeated string name = 1;
   */
  name: string[] = [];

  /**
   * @generated from field: repeated chalk.server.v1.HealthCheckStatus status = 2;
   */
  status: HealthCheckStatus[] = [];

  constructor(data?: PartialMessage<HealthCheckFilters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.HealthCheckFilters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(HealthCheckStatus), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheckFilters {
    return new HealthCheckFilters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheckFilters {
    return new HealthCheckFilters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheckFilters {
    return new HealthCheckFilters().fromJsonString(jsonString, options);
  }

  static equals(a: HealthCheckFilters | PlainMessage<HealthCheckFilters> | undefined, b: HealthCheckFilters | PlainMessage<HealthCheckFilters> | undefined): boolean {
    return proto3.util.equals(HealthCheckFilters, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.CheckHealthRequest
 */
export class CheckHealthRequest extends Message<CheckHealthRequest> {
  /**
   * @generated from field: optional chalk.server.v1.HealthCheckFilters filters = 1;
   */
  filters?: HealthCheckFilters;

  constructor(data?: PartialMessage<CheckHealthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.CheckHealthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filters", kind: "message", T: HealthCheckFilters, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckHealthRequest {
    return new CheckHealthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckHealthRequest {
    return new CheckHealthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckHealthRequest {
    return new CheckHealthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckHealthRequest | PlainMessage<CheckHealthRequest> | undefined, b: CheckHealthRequest | PlainMessage<CheckHealthRequest> | undefined): boolean {
    return proto3.util.equals(CheckHealthRequest, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.CheckHealthResponse
 */
export class CheckHealthResponse extends Message<CheckHealthResponse> {
  /**
   * @generated from field: repeated chalk.server.v1.HealthCheck checks = 1;
   */
  checks: HealthCheck[] = [];

  constructor(data?: PartialMessage<CheckHealthResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.CheckHealthResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checks", kind: "message", T: HealthCheck, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckHealthResponse {
    return new CheckHealthResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckHealthResponse {
    return new CheckHealthResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckHealthResponse {
    return new CheckHealthResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckHealthResponse | PlainMessage<CheckHealthResponse> | undefined, b: CheckHealthResponse | PlainMessage<CheckHealthResponse> | undefined): boolean {
    return proto3.util.equals(CheckHealthResponse, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.GetHealthRequest
 */
export class GetHealthRequest extends Message<GetHealthRequest> {
  /**
   * @generated from field: optional chalk.server.v1.HealthCheckFilters filters = 1;
   */
  filters?: HealthCheckFilters;

  constructor(data?: PartialMessage<GetHealthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.GetHealthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filters", kind: "message", T: HealthCheckFilters, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHealthRequest {
    return new GetHealthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHealthRequest {
    return new GetHealthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHealthRequest {
    return new GetHealthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetHealthRequest | PlainMessage<GetHealthRequest> | undefined, b: GetHealthRequest | PlainMessage<GetHealthRequest> | undefined): boolean {
    return proto3.util.equals(GetHealthRequest, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.GetHealthResponse
 */
export class GetHealthResponse extends Message<GetHealthResponse> {
  /**
   * @generated from field: repeated chalk.server.v1.HealthCheck checks = 1;
   */
  checks: HealthCheck[] = [];

  constructor(data?: PartialMessage<GetHealthResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.GetHealthResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checks", kind: "message", T: HealthCheck, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHealthResponse {
    return new GetHealthResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHealthResponse {
    return new GetHealthResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHealthResponse {
    return new GetHealthResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetHealthResponse | PlainMessage<GetHealthResponse> | undefined, b: GetHealthResponse | PlainMessage<GetHealthResponse> | undefined): boolean {
    return proto3.util.equals(GetHealthResponse, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.GetClusterMetricsRequest
 */
export class GetClusterMetricsRequest extends Message<GetClusterMetricsRequest> {
  constructor(data?: PartialMessage<GetClusterMetricsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.GetClusterMetricsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterMetricsRequest {
    return new GetClusterMetricsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterMetricsRequest {
    return new GetClusterMetricsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterMetricsRequest {
    return new GetClusterMetricsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterMetricsRequest | PlainMessage<GetClusterMetricsRequest> | undefined, b: GetClusterMetricsRequest | PlainMessage<GetClusterMetricsRequest> | undefined): boolean {
    return proto3.util.equals(GetClusterMetricsRequest, a, b);
  }
}

/**
 * @generated from message chalk.server.v1.GetClusterMetricsResponse
 */
export class GetClusterMetricsResponse extends Message<GetClusterMetricsResponse> {
  /**
   * @generated from field: string metrics = 1;
   */
  metrics = "";

  constructor(data?: PartialMessage<GetClusterMetricsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.server.v1.GetClusterMetricsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metrics", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterMetricsResponse {
    return new GetClusterMetricsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterMetricsResponse {
    return new GetClusterMetricsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterMetricsResponse {
    return new GetClusterMetricsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterMetricsResponse | PlainMessage<GetClusterMetricsResponse> | undefined, b: GetClusterMetricsResponse | PlainMessage<GetClusterMetricsResponse> | undefined): boolean {
    return proto3.util.equals(GetClusterMetricsResponse, a, b);
  }
}

