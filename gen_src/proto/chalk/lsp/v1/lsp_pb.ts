// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file chalk/lsp/v1/lsp.proto (package chalk.lsp.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum chalk.lsp.v1.DiagnosticSeverity
 */
export enum DiagnosticSeverity {
  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_ERROR = 1;
   */
  ERROR = 1,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_WARNING = 2;
   */
  WARNING = 2,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_INFORMATION = 3;
   */
  INFORMATION = 3,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_HINT = 4;
   */
  HINT = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(DiagnosticSeverity)
proto3.util.setEnumType(DiagnosticSeverity, "chalk.lsp.v1.DiagnosticSeverity", [
  { no: 0, name: "DIAGNOSTIC_SEVERITY_UNSPECIFIED" },
  { no: 1, name: "DIAGNOSTIC_SEVERITY_ERROR" },
  { no: 2, name: "DIAGNOSTIC_SEVERITY_WARNING" },
  { no: 3, name: "DIAGNOSTIC_SEVERITY_INFORMATION" },
  { no: 4, name: "DIAGNOSTIC_SEVERITY_HINT" },
]);

/**
 * @generated from message chalk.lsp.v1.LSP
 */
export class LSP extends Message<LSP> {
  /**
   * @generated from field: repeated chalk.lsp.v1.PublishDiagnosticsParams diagnostics = 1;
   */
  diagnostics: PublishDiagnosticsParams[] = [];

  /**
   * @generated from field: repeated chalk.lsp.v1.CodeAction actions = 2;
   */
  actions: CodeAction[] = [];

  constructor(data?: PartialMessage<LSP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.LSP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "diagnostics", kind: "message", T: PublishDiagnosticsParams, repeated: true },
    { no: 2, name: "actions", kind: "message", T: CodeAction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LSP {
    return new LSP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LSP {
    return new LSP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LSP {
    return new LSP().fromJsonString(jsonString, options);
  }

  static equals(a: LSP | PlainMessage<LSP> | undefined, b: LSP | PlainMessage<LSP> | undefined): boolean {
    return proto3.util.equals(LSP, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.PublishDiagnosticsParams
 */
export class PublishDiagnosticsParams extends Message<PublishDiagnosticsParams> {
  /**
   * @generated from field: string uri = 1;
   */
  uri = "";

  /**
   * @generated from field: repeated chalk.lsp.v1.Diagnostic diagnostics = 2;
   */
  diagnostics: Diagnostic[] = [];

  constructor(data?: PartialMessage<PublishDiagnosticsParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.PublishDiagnosticsParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "diagnostics", kind: "message", T: Diagnostic, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishDiagnosticsParams {
    return new PublishDiagnosticsParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishDiagnosticsParams {
    return new PublishDiagnosticsParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishDiagnosticsParams {
    return new PublishDiagnosticsParams().fromJsonString(jsonString, options);
  }

  static equals(a: PublishDiagnosticsParams | PlainMessage<PublishDiagnosticsParams> | undefined, b: PublishDiagnosticsParams | PlainMessage<PublishDiagnosticsParams> | undefined): boolean {
    return proto3.util.equals(PublishDiagnosticsParams, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.Diagnostic
 */
export class Diagnostic extends Message<Diagnostic> {
  /**
   * @generated from field: chalk.lsp.v1.Range range = 1;
   */
  range?: Range;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: chalk.lsp.v1.DiagnosticSeverity severity = 3;
   */
  severity = DiagnosticSeverity.UNSPECIFIED;

  /**
   * @generated from field: optional string code = 4;
   */
  code?: string;

  /**
   * @generated from field: chalk.lsp.v1.CodeDescription code_description = 5;
   */
  codeDescription?: CodeDescription;

  /**
   * @generated from field: repeated chalk.lsp.v1.DiagnosticRelatedInformation related_information = 6;
   */
  relatedInformation: DiagnosticRelatedInformation[] = [];

  constructor(data?: PartialMessage<Diagnostic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.Diagnostic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "range", kind: "message", T: Range },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "severity", kind: "enum", T: proto3.getEnumType(DiagnosticSeverity) },
    { no: 4, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "code_description", kind: "message", T: CodeDescription },
    { no: 6, name: "related_information", kind: "message", T: DiagnosticRelatedInformation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Diagnostic {
    return new Diagnostic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJsonString(jsonString, options);
  }

  static equals(a: Diagnostic | PlainMessage<Diagnostic> | undefined, b: Diagnostic | PlainMessage<Diagnostic> | undefined): boolean {
    return proto3.util.equals(Diagnostic, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.Range
 */
export class Range extends Message<Range> {
  /**
   * @generated from field: chalk.lsp.v1.Position start = 1;
   */
  start?: Position;

  /**
   * @generated from field: chalk.lsp.v1.Position end = 2;
   */
  end?: Position;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Position },
    { no: 2, name: "end", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.Position
 */
export class Position extends Message<Position> {
  /**
   * @generated from field: optional int32 line = 1;
   */
  line?: number;

  /**
   * @generated from field: optional int32 character = 2;
   */
  character?: number;

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "character", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.CodeAction
 */
export class CodeAction extends Message<CodeAction> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: repeated chalk.lsp.v1.Diagnostic diagnostics = 2;
   */
  diagnostics: Diagnostic[] = [];

  /**
   * @generated from field: chalk.lsp.v1.WorkspaceEdit edit = 3;
   */
  edit?: WorkspaceEdit;

  constructor(data?: PartialMessage<CodeAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.CodeAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "diagnostics", kind: "message", T: Diagnostic, repeated: true },
    { no: 3, name: "edit", kind: "message", T: WorkspaceEdit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeAction {
    return new CodeAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeAction {
    return new CodeAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeAction {
    return new CodeAction().fromJsonString(jsonString, options);
  }

  static equals(a: CodeAction | PlainMessage<CodeAction> | undefined, b: CodeAction | PlainMessage<CodeAction> | undefined): boolean {
    return proto3.util.equals(CodeAction, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.WorkspaceEdit
 */
export class WorkspaceEdit extends Message<WorkspaceEdit> {
  /**
   * @generated from field: repeated chalk.lsp.v1.TextDocumentEdit document_changes = 1;
   */
  documentChanges: TextDocumentEdit[] = [];

  constructor(data?: PartialMessage<WorkspaceEdit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.WorkspaceEdit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_changes", kind: "message", T: TextDocumentEdit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkspaceEdit {
    return new WorkspaceEdit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkspaceEdit {
    return new WorkspaceEdit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkspaceEdit {
    return new WorkspaceEdit().fromJsonString(jsonString, options);
  }

  static equals(a: WorkspaceEdit | PlainMessage<WorkspaceEdit> | undefined, b: WorkspaceEdit | PlainMessage<WorkspaceEdit> | undefined): boolean {
    return proto3.util.equals(WorkspaceEdit, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.TextDocumentEdit
 */
export class TextDocumentEdit extends Message<TextDocumentEdit> {
  /**
   * @generated from field: chalk.lsp.v1.TextDocumentIdentifier text_document = 1;
   */
  textDocument?: TextDocumentIdentifier;

  /**
   * @generated from field: repeated chalk.lsp.v1.TextEdit edits = 2;
   */
  edits: TextEdit[] = [];

  constructor(data?: PartialMessage<TextDocumentEdit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.TextDocumentEdit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text_document", kind: "message", T: TextDocumentIdentifier },
    { no: 2, name: "edits", kind: "message", T: TextEdit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextDocumentEdit {
    return new TextDocumentEdit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextDocumentEdit {
    return new TextDocumentEdit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextDocumentEdit {
    return new TextDocumentEdit().fromJsonString(jsonString, options);
  }

  static equals(a: TextDocumentEdit | PlainMessage<TextDocumentEdit> | undefined, b: TextDocumentEdit | PlainMessage<TextDocumentEdit> | undefined): boolean {
    return proto3.util.equals(TextDocumentEdit, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.TextDocumentIdentifier
 */
export class TextDocumentIdentifier extends Message<TextDocumentIdentifier> {
  /**
   * @generated from field: string uri = 1;
   */
  uri = "";

  constructor(data?: PartialMessage<TextDocumentIdentifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.TextDocumentIdentifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextDocumentIdentifier {
    return new TextDocumentIdentifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextDocumentIdentifier {
    return new TextDocumentIdentifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextDocumentIdentifier {
    return new TextDocumentIdentifier().fromJsonString(jsonString, options);
  }

  static equals(a: TextDocumentIdentifier | PlainMessage<TextDocumentIdentifier> | undefined, b: TextDocumentIdentifier | PlainMessage<TextDocumentIdentifier> | undefined): boolean {
    return proto3.util.equals(TextDocumentIdentifier, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.TextEdit
 */
export class TextEdit extends Message<TextEdit> {
  /**
   * @generated from field: chalk.lsp.v1.Range range = 1;
   */
  range?: Range;

  /**
   * @generated from field: string new_text = 2;
   */
  newText = "";

  constructor(data?: PartialMessage<TextEdit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.TextEdit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "range", kind: "message", T: Range },
    { no: 2, name: "new_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextEdit {
    return new TextEdit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextEdit {
    return new TextEdit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextEdit {
    return new TextEdit().fromJsonString(jsonString, options);
  }

  static equals(a: TextEdit | PlainMessage<TextEdit> | undefined, b: TextEdit | PlainMessage<TextEdit> | undefined): boolean {
    return proto3.util.equals(TextEdit, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.CodeDescription
 */
export class CodeDescription extends Message<CodeDescription> {
  /**
   * @generated from field: string href = 1;
   */
  href = "";

  constructor(data?: PartialMessage<CodeDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.CodeDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "href", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeDescription {
    return new CodeDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeDescription {
    return new CodeDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeDescription {
    return new CodeDescription().fromJsonString(jsonString, options);
  }

  static equals(a: CodeDescription | PlainMessage<CodeDescription> | undefined, b: CodeDescription | PlainMessage<CodeDescription> | undefined): boolean {
    return proto3.util.equals(CodeDescription, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.DiagnosticRelatedInformation
 */
export class DiagnosticRelatedInformation extends Message<DiagnosticRelatedInformation> {
  /**
   * @generated from field: chalk.lsp.v1.Location location = 1;
   */
  location?: Location;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<DiagnosticRelatedInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.DiagnosticRelatedInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "message", T: Location },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiagnosticRelatedInformation {
    return new DiagnosticRelatedInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiagnosticRelatedInformation {
    return new DiagnosticRelatedInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiagnosticRelatedInformation {
    return new DiagnosticRelatedInformation().fromJsonString(jsonString, options);
  }

  static equals(a: DiagnosticRelatedInformation | PlainMessage<DiagnosticRelatedInformation> | undefined, b: DiagnosticRelatedInformation | PlainMessage<DiagnosticRelatedInformation> | undefined): boolean {
    return proto3.util.equals(DiagnosticRelatedInformation, a, b);
  }
}

/**
 * @generated from message chalk.lsp.v1.Location
 */
export class Location extends Message<Location> {
  /**
   * @generated from field: string uri = 1;
   */
  uri = "";

  /**
   * @generated from field: chalk.lsp.v1.Range range = 2;
   */
  range?: Range;

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chalk.lsp.v1.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "message", T: Range },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(a: Location | PlainMessage<Location> | undefined, b: Location | PlainMessage<Location> | undefined): boolean {
    return proto3.util.equals(Location, a, b);
  }
}

